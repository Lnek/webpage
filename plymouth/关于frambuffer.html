               <!DOCTYPE html><html  id="customDoc"><!--STATUS OK--> <head> <meta http-equiv=Content-Type content="text/html; charset=utf-8"> <title> 关于frambuffer_逍遥空间_百度空间</title> <link rel="shortcut icon" href="http://hi.bdimg.com/static/qbase/img/mod/16_favicon.ico?v=116ba471.ico" type=image/x-icon>   <meta name=keywords content="关于frambuffer,嵌入式"> <meta name=description content="高兴就来,关于frambuffer"><script>window.wpo={start:new Date*1,pid:109,page:'qing'}</script><!--[if IE]><script type="text/javascript">(function(){var a="abbr,article,aside,audio,canvas,datalist,details,dialog,eventsource,figure,footer,header,hgroup,mark,menu,meter,nav,output,progress,section,time,video".split(","),b=a.length;while(b--)document.createElement(a[b])})();</script><![endif]--><script>window.qDomain={"qing":"http://hi.baidu.com","static":"http://hi.bdimg.com","passport":"https://passport.baidu.com","portrait":"http://tx.bdimg.com","hiup":"http://hiup.baidu.com","photo":"http://hiphotos.baidu.com","message":"http://msg.baidu.com","friend":"http://frd.baidu.com","mp3":"http://mp3.baidu.com","ting":"http://ting.baidu.com","image":"http://img.baidu.com","qup":"http://upload.hi.baidu.com","www":"http://www.baidu.com"};window.qUserInfo={"userName":"gejunxiao1","nickname":"gejunxiao1","portrait":"6934647265616d6d65726765eb00","qingUrl":"\/dreammerge","spaceName":"逍遥空间","right":"0","avatarStatus":"1","flagNeedInvite":"0","flagNotInvited":"0","version":"2"};window.qVisitorInfo={"userName":"","nickname":"","portrait":"","isHost": false,"isRandUrl": false,"isForceMoved": false,"loginStatus":"not_login","isOldUser":0,"qingUrl":"","right":"0","version":"0"};window.qPageInfo={"pageUrl":"http:\/\/hi.baidu.com\/dreammerge\/item\/1299481588c0360fd0d66d82","referUrl":"http:\/\/www.baidu.com\/s?ie=utf-8&bs=variable_screen_info&f=8&rsv_bp=1&rsv_spt=3&wd=fb_var_screeninfo&rsv_n=2&rsv_sug3=1&rsv_sug1=1&rsv_sug4=9&inputT=1990"};window.qUserAvatar={size20:"http://hiphotos.baidu.com/space/scrop=20;q=100/sign=a1a1ae954b36acaf5dbed1a30ce4bf20/730e0cf3d7ca7bcb60082a83be096b63f624a82f.jpg",size40:"http://hiphotos.baidu.com/space/scrop=40;q=100/sign=217874332edda3cc0fbaff7f71d40d31/730e0cf3d7ca7bcb60082a83be096b63f624a82f.jpg",size65:"http://hiphotos.baidu.com/space/scrop=65;q=100/sign=44937b507cd98d10728a4b6e51028e3b/730e0cf3d7ca7bcb60082a83be096b63f624a82f.jpg",size110:"http://hiphotos.baidu.com/space/scrop=110;q=100/sign=f80b0e14d43f8794d7a10f71a2263fc5/730e0cf3d7ca7bcb60082a83be096b63f624a82f.jpg",size160:"http://hiphotos.baidu.com/space/scrop=160;q=100/sign=f80b0e14d43f8794d7a10f71a2263fc2/730e0cf3d7ca7bcb60082a83be096b63f624a82f.jpg"};window.qVisitorAvatar={size20:"",size40:"",size65:"",size110:"",size160:""};window.qBdsToken="the fisrt two args should be string type:0,1!";window.qErrorInfo={"no":"0","msg":""};window.qServerInfo={"timeStamp":"1369363788"};window.qLongPolling={"url":"http:\/\/m.hi.baidu.com\/i\/msg\/listen"}</script><!--[if (lt IE 8.0)]><link href="http://hi.bdimg.com/static/qbase/css/qbase.css?v=215fffd7.css" type=text/css rel=stylesheet><![endif]--><!--[if (!IE)|(gte IE 8.0)]><!--><link href="http://hi.bdimg.com/static/qbase/css/qbase_datauri.css?v=e77db79b.css" type=text/css rel=stylesheet><!--<![endif]-->     <!--[if (lt IE 8.0)]><link rel=stylesheet type=text/css href="http://hi.bdimg.com/static/qcomment/css/qcomment.css?v=5ba753ab.css"><![endif]--><!--[if (!IE)|(gte IE 8.0)]><!--><link rel=stylesheet type=text/css href="http://hi.bdimg.com/static/qcomment/css/qcomment_datauri.css?v=a90beb01.css"><!--<![endif]--><link rel=stylesheet type=text/css href="http://hi.bdimg.com/static/qhome/css/common/mod_userInfo.css?v=86bf4259.css">   <!--[if (lt IE 8.0)]><link type=text/css rel=stylesheet href="http://hi.bdimg.com/static/qhome/css/detail/20001/detail.css?v=635ae796.css"><![endif]--><!--[if (!IE)|(gte IE 8.0)]><!--><link type=text/css rel=stylesheet href="http://hi.bdimg.com/static/qhome/css/detail/20001/detail_datauri.css?v=0f094a12.css"><!--<![endif]-->    <link rel=stylesheet type=text/css href="http://hi.bdimg.com/static/qpublish/css/editor/shCoreDefault.css?v=79e715f0.css">     <script src="http://hi.bdimg.com/static/qbase/js/qing/qing.js?v=058da7b0.js"></script>  <script>
    /*最终页页面变量*/ 
    window.detailPage = {
        threadId : "1299481588c0360fd0d66d82",
        blogTitle: "关于frambuffer" || "无标题",
        contentType : "text",
        originAuthorName : "",
        originPortrait : "",
        originThreadId : ""
    }; 
    </script><script>wpo.head=new Date*1;</script> </head> <body>  <header class=mod-topbar id=modTopbar><iframe class=mod-topbar-bgframe></iframe><div class=mod-topbar-pseudo-real><div class="wrapper-box clearfix"><div class=left-box><a href="http://hi.baidu.com" class=logo-box><span id=baiduSpaceLogo class=q-logo></span></a></div> <div class=center-box><ul class=q-menubox>  <li class="q-menuitem q-newicon"> <a href=http://xiangce.baidu.com target=_blank>相册</a>  <li class="q-menuitem " id=qMenuRecommend><a href="http://hi.baidu.com/index/">广场</a></ul></div>  <div class=right-box><ul class=q-navbox><li class=q-navitem><a href="http://hi.baidu.com/go/login" class=q-goto-login>登录</a><li class="q-navitem q-nav-sp"><span></span><li class=q-navitem><a href="http://hi.baidu.com/go/reg?pmfrom=qingtop">注册</a> </ul><div class="right mod-qhome-follow-box"><a href="#" class="follow-btn a-btn-follow qing-stat-nsclick" data-nsclick=20121012follow_hdbtnaddcare>关注此空间</a></div> </div> </div></div></header>  <section class=mod-page-body> <div class="mod-page-main wordwrap clearfix">  <div class=x-page-container>    <section class="mod-topspaceinfo mod-cs-header"><div class=head-topbar></div><div class=container><h1><a class="space-name cs-header-spacename" href="/dreammerge">逍遥空间</a></h1><p class="space-description cs-header-spacesummary">高兴就来</p></div><div class=head-footer></div></section>   <div class=mod-blogpage-wraper> <div class="blog-bg-main-repeat hide"></div>  <div class="grid-80 mod-blogpage"> <div class="blog-bg-main hide"></div>    <div class="mod-text-content mod-post-content mod-cs-contentblock"> <div class=cs-contentblock-bg></div>   <div class="content-head clearfix">  <div class=content-other-info>  <span>2009-04-09 14:21</span>  </div>   <h2 class="title content-title">关于frambuffer</h2>  </div>  <div id=content class="content mod-cs-content text-content clearfix"> <p>FrameBuffer的原理</p><p>FrameBuffer 是出现在 2.2.xx 内核当中的一种驱动程序接口。</p><p>Linux是工作在保护模式下，所以用户态进程是无法象DOS那样使用显卡BIOS里提供的中断调用来实现直接写屏，Linux抽象出FrameBuffer这个设备来供用户态进程实现直接写屏。Framebuffer机制模仿显卡的功能，将显卡硬件结构抽象掉，可以通过Framebuffer的读写直接对显存进行操作。用户可以将Framebuffer看成是显示内存的一个映像，将其映射到进程地址空间之后，就可以直接进行读写操作，而写操作可以立即反应在屏幕上。这种操作是抽象的，统一的。用户不必关心物理显存的位置、换页机制等等具体细节。这些都是由Framebuffer设备驱动来完成的。</p><p>但Framebuffer本身不具备任何运算数据的能力,就只好比是一个暂时存放水的水池.CPU将运算后的结果放到这个水池,水池再将结果流到显示器.中间不会对数据做处理. 应用程序也可以直接读写这个水池的内容.在这种机制下，尽管Framebuffer需要真正的显卡驱动的支持，但所有显示任务都有CPU完成,因此CPU负担很重.</p><p>framebuffer的设备文件一般是 /dev/fb0、/dev/fb1 等等。</p><p>可以用命令: #dd if=/dev/zero of=/dev/fb 清空屏幕.</p><p>如果显示模式是 1024x768-8 位色，用命令：$ dd if=/dev/zero of=/dev/fb0 bs=1024 count=768 清空屏幕</p><p>用命令: #dd if=/dev/fb of=fbfile  可以将fb中的内容保存下来；</p><p>可以重新写回屏幕: #dd if=fbfile of=/dev/fb</p><p>在使用Framebuffer时，Linux是将显卡置于图形模式下的．</p><p>在应用程序中，一般通过将 FrameBuffer 设备映射到进程地址空间的方式使用，比如下面的程序就打开 /dev/fb0 设备，并通过 mmap 系统调用进行地址映射，随后用 memset 将屏幕清空（这里假设显示模式是 1024x768-8 位色模式，线性内存模式）：</p><p>int fb;</p><p>unsigned char* fb_mem;</p><p>fb = open (&quot;/dev/fb0&quot;, O_RDWR);</p><p>fb_mem = mmap (NULL, 1024*768, PROT_READ|PROT_WRITE,MAP_SHARED,fb,0);</p><p>memset (fb_mem, 0, 1024*768);</p><p>FrameBuffer 设备还提供了若干 ioctl 命令，通过这些命令，可以获得显示设备的一些固定信息（比如显示内存大小）、与显示模式相关的可变信息（比如分辨率、象素结构、每扫描线的字节宽度），以及伪彩色模式下的调色板信息等等。</p><p>通过 FrameBuffer 设备，还可以获得当前内核所支持的加速显示卡的类型（通过固定信息得到），这种类型通常是和特定显示芯片相关的。比如目前最新的内核（2.4.9）中，就包含有对 S3、Matrox、nVidia、3Dfx 等等流行显示芯片的加速支持。在获得了加速芯片类型之后，应用程序就可以将 PCI 设备的内存I/O（memio）映射到进程的地址空间。这些 memio 一般是用来控制显示卡的寄存器，通过对这些寄存器的操作，应用程序就可以控制特定显卡的加速功能。</p><p>PCI 设备可以将自己的控制寄存器映射到物理内存空间，而后，对这些控制寄存器的访问，给变成了对物理内存的访问。因此，这些寄存器又被称为&quot;memio&quot;。一旦被映射到物理内存，Linux 的普通进程就可以通过 mmap 将这些内存 I/O 映射到进程地址空间，这样就可以直接访问这些寄存器了。</p><p>当然，因为不同的显示芯片具有不同的加速能力，对memio 的使用和定义也各自不同，这时，就需要针对加速芯片的不同类型来编写实现不同的加速功能。比如大多数芯片都提供了对矩形填充的硬件加速支持，但不同的芯片实现方式不同，这时，就需要针对不同的芯片类型编写不同的用来完成填充矩形的函数。</p><p>FrameBuffer 只是一个提供显示内存和显示芯片寄存器从物理内存映射到进程地址空间中的设备。所以，对于应用程序而言，如果希望在 FrameBuffer 之上进行图形编程，还需要自己动手完成其他许多工作。</p><p>&lt;!--[if !supportEmptyParas]--&gt; &lt;!--[endif]--&gt;</p><p>&lt;!--[if !supportLists]--&gt;二、&lt;!--[endif]--&gt;FrameBuffer在LINUX中实现和机制</p><p>Framebuffer对应的源文件在linux/drivers/video/目录下。总的抽象设备文件为fbcon.c，在这个目录下还有与各种显卡驱动相关的源文件。</p><p>(一)、分析Framebuffer设备驱动</p><p>&nbsp;&nbsp;&nbsp;  需要特别提出的是在INTEL平台上，老式的VESA 1.2 卡，如CGA/EGA卡，是不能支持Framebuffer的，因为Framebuffer要求显卡支持线性帧缓冲，即CPU可以访问显缓冲中的每一位，但是VESA 1.2 卡只能允许CPU一次访问64K的地址空间。</p><p>FrameBuffer设备驱动基于如下两个文件：</p><p>1) linux/include/linux/fb.h<br />2) linux/drivers/video/fbmem.c</p><p>下面分析这两个文件。</p><p>1、fb.h</p><p>&nbsp;&nbsp;  几乎主要的结构都是在这个中文件定义的。这些结构包括：</p><p>1）fb_var_screeninfo</p><p>&nbsp;&nbsp;  这个结构描述了显示卡的特性：</p><p>struct fb_var_screeninfo</p><p>{<br />__u32 xres; /* visible resolution */<br />__u32 yres;<br />__u32 xres_virtual; /* virtual resolution */<br />__u32 yres_virtual;<br />__u32 xoffset; /* offset from virtual to visible resolution */<br />__u32 yoffset;</p><p>__u32 bits_per_pixel; /* guess what */<br />__u32 grayscale; /* != 0 Gray levels instead of colors */</p><p>struct fb_bitfield red; /* bitfield in fb mem if true color, */<br />struct fb_bitfield green; /* else only length is significant */<br />struct fb_bitfield blue;<br />struct fb_bitfield transp; /* transparency */</p><p>__u32 nonstd; /* != 0 Non standard pixel format */</p><p>__u32 activate; /* see FB_ACTIVATE_* */</p><p>__u32 height; /* height of picture in mm */<br />__u32 width; /* width of picture in mm */</p><p>__u32 accel_flags; /* acceleration flags (hints) */</p><p>/* Timing: All values in pixclocks, except pixclock (of course) */<br />__u32 pixclock; /* pixel clock in ps (pico seconds) */<br />__u32 left_margin; /* time from sync to picture */<br />__u32 right_margin; /* time from picture to sync */<br />__u32 upper_margin; /* time from sync to picture */<br />__u32 lower_margin;<br />__u32 hsync_len; /* length of horizontal sync */<br />__u32 vsync_len; /* length of vertical sync */<br />__u32 sync; /* see FB_SYNC_* */<br />__u32 vmode; /* see FB_VMODE_* */<br />__u32 reserved[6]; /* Reserved for future compatibility */<br />};</p><p>2) fb_fix_screeninfon<br />这个结构在显卡被设定模式后创建，它描述显示卡的属性，并且系统运行时不能被修改；比如FrameBuffer内存的起始地址。它依赖于被设定的模式，当一个模式被设定后，内存信息由显示卡硬件给出，内存的位置等信息就不可以修改。</p><p>struct fb_fix_screeninfo {<br />char id[16]; /* identification string eg &quot;TT Builtin&quot; */<br />unsigned long smem_start; /* Start of frame buffer mem */<br />/* (physical address) */<br />__u32 smem_len; /* Length of frame buffer mem */<br />__u32 type; /* see FB_TYPE_* */<br />__u32 type_aux; /* Interleave for interleaved Planes */<br />__u32 visual; /* see FB_VISUAL_* */<br />__u16 xpanstep; /* zero if no hardware panning */<br />__u16 ypanstep; /* zero if no hardware panning */<br />__u16 ywrapstep; /* zero if no hardware ywrap */<br />__u32 line_length; /* length of a line in bytes */<br />unsigned long mmio_start; /* Start of Memory Mapped I/O */<br />/* (physical address) */<br />__u32 mmio_len; /* Length of Memory Mapped I/O */<br />__u32 accel; /* Type of acceleration available */<br />__u16 reserved[3]; /* Reserved for future compatibility */<br />};</p><p>3) fb_cmap<br />描述设备无关的颜色映射信息。可以通过FBIOGETCMAP 和 FBIOPUTCMAP 对应的ioctl操作设定或获取颜色映射信息.</p><p>struct fb_cmap {<br />__u32 start; /* First entry */<br />__u32 len; /* Number of entries */<br />__u16 *red; /* Red values */<br />__u16 *green;<br />__u16 *blue;<br />__u16 *transp; /* transparency, can be NULL */<br />};</p><p>4) fb_info<br />定义当显卡的当前状态；fb_info结构仅在内核中可见，在这个结构中有一个fb_ops指针， 指向驱动设备工作所需的函数集。</p><p>struct fb_info {<br />char modename[40]; /* default video mode */<br />kdev_t node;<br />int flags;<br />int open; /* Has this been open already ? */<br />#define FBINFO_FLAG_MODULE 1 /* Low-level driver is a module */<br />struct fb_var_screeninfo var; /* Current var */<br />struct fb_fix_screeninfo fix; /* Current fix */<br />struct fb_monspecs monspecs; /* Current Monitor specs */<br />struct fb_cmap cmap; /* Current cmap */<br />struct fb_ops *fbops;<br />char *screen_base; /* Virtual address */<br />struct display *disp; /* initial display variable */<br />struct vc_data *display_fg; /* Console visible on this display */<br />char fontname[40]; /* default font name */<br />devfs_handle_t devfs_handle; /* Devfs handle for new name */<br />devfs_handle_t devfs_lhandle; /* Devfs handle for compat. symlink */<br />int (*changevar)(int); /* tell console var has changed */<br />int (*switch_con)(int, struct fb_info*);<br />/* tell fb to switch consoles */<br />int (*updatevar)(int, struct fb_info*);<br />/* tell fb to update the vars */<br />void (*blank)(int, struct fb_info*); /* tell fb to (un)blank the screen */<br />/* arg = 0: unblank */<br />/* arg &gt; 0: VESA level (arg-1) */<br />void *pseudo_palette; /* Fake palette of 16 colors and<br />the cursor's color for non<br />palette mode */<br />/* From here on everything is device dependent */<br />void *par;<br />};</p><p>5) struct fb_ops<br />用户应用可以使用ioctl()系统调用来操作设备，这个结构就是用一支持ioctl()的这些操作的。</p><p>struct fb_ops {<br />/* open/release and usage marking */<br />struct module *owner;<br />int (*fb_open)(struct fb_info *info, int user);<br />int (*fb_release)(struct fb_info *info, int user);<br />/* get non settable parameters */<br />int (*fb_get_fix)(struct fb_fix_screeninfo *fix, int con,<br />struct fb_info *info);<br />/* get settable parameters */<br />int (*fb_get_var)(struct fb_var_screeninfo *var, int con,<br />struct fb_info *info);<br />/* set settable parameters */<br />int (*fb_set_var)(struct fb_var_screeninfo *var, int con,<br />struct fb_info *info);<br />/* get colormap */<br />int (*fb_get_cmap)(struct fb_cmap *cmap, int kspc, int con,<br />struct fb_info *info);<br />/* set colormap */<br />int (*fb_set_cmap)(struct fb_cmap *cmap, int kspc, int con,<br />struct fb_info *info);<br />/* pan display (optional) */<br />int (*fb_pan_display)(struct fb_var_screeninfo *var, int con,<br />struct fb_info *info);<br />/* perform fb specific ioctl (optional) */<br />int (*fb_ioctl)(struct inode *inode, struct file *file, unsigned int cmd,<br />unsigned long arg, int con, struct fb_info *info);<br />/* perform fb specific mmap */<br />int (*fb_mmap)(struct fb_info *info, struct file *file, struct vm_area_struct *vma);<br />/* switch to/from raster image mode */<br />int (*fb_rasterimg)(struct fb_info *info, int start);<br />};</p><p>6) structure map<br />struct fb_info_gen | struct fb_info | fb_var_screeninfo<br />| | fb_fix_screeninfo<br />| | fb_cmap<br />| | modename[40]<br />| | fb_ops ---|---&gt;ops on var<br />| | ... | fb_open<br />| | | fb_release<br />| | | fb_ioctl<br />| | | fb_mmap<br />| struct fbgen_hwswitch -|-&gt; detect<br />| | encode_fix<br />| | encode_var<br />| | decode_fix<br />| | decode_var<br />| | get_var<br />| | set_var<br />| | getcolreg<br />| | setcolreg<br />| | pan_display<br />| | blank<br />| | set_disp</p><p>[编排有点困难，第一行的第一条竖线和下面的第一列竖线对齐，第一行的第二条竖线和下面的第二列竖线对齐就可以了]<br />这个结构 fbgen_hwswitch抽象了硬件的操作.虽然它不是必需的，但有时候很有用.</p><p>2、 fbmem.c<br />fbmem.c 处于Framebuffer设备驱动技术的中心位置.它为上层应用程序提供系统调用 也为下一层的特定硬件驱动提供接口；那些底层硬件驱动需要用到这儿的接口来向系统内核注册它们自己. fbmem.c 为所有支持FrameBuffer的设备驱动提供了通用的接口，避免重复工作.</p><p>1) 全局变量</p><p>struct fb_info *registered_fb[FB_MAX];<br />int num_registered_fb;</p><p><br />这两变量记录了所有fb_info 结构的实例，fb_info 结构描述显卡的当前状态，所有设备对应的fb_info 结构都保存在这个数组中，当一个FrameBuffer设备驱动向系统注册自己时，其对应的fb_info 结构就会添加到这个结构中，同时num_registered_fb 为自动加1.</p><p>static struct {<br />const char *name;<br />int (*init)(void);<br />int (*setup)(void);<br />} fb_drivers[] __initdata= { ....};</p><p>如果FrameBuffer设备被静态链接到内核，其对应的入口就会添加到这个表中；如果是动态加载的，即使用insmod/rmmod,就不需要关心这个表。</p><p>static struct file_operations fb_ops ={<br />owner: THIS_MODULE,<br />read: fb_read,<br />write: fb_write,<br />ioctl: fb_ioctl,<br />mmap: fb_mmap,<br />open: fb_open,<br />release: fb_release<br />};<br />这是一个提供给应用程序的接口.</p><p>2）fbmem.c 实现了如下函数.</p><p>register_framebuffer(struct fb_info *fb_info);<br />unregister_framebuffer(struct fb_info *fb_info);</p><p>这两个是提供给下层FrameBuffer设备驱动的接口，设备驱动通过这两函数向系统注册或注销自己。几乎底层设备驱动所要做的所有事情就是填充fb_info结构然后向系统注册或注销它。</p><p>（二）一个LCD显示芯片的驱动实例</p><p>以Skeleton LCD 控制器驱动为例，在LINUX中存有一个/fb/skeleton.c的skeleton的Framebuffer驱动程序，很简单，仅仅是填充了fb_info结构，并且注册/注销自己。设备驱动是向用户程序提供系统调用接口，所以我们需要实现底层硬件操作并且定义file_operations结构来向系统提供系统调用接口，从而实现更有效的LCD控制器驱动程序。</p><p>1）在系统内存中分配显存<br />在fbmem.c文件中可以看到, file_operations 结构中的open()和release()操作不需底层支持，但read()、write()和 mmap()操作需要函数fb_get_fix()的支持.因此需要重新实现函数fb_get_fix()。另外还需要在系统内存中分配显存空间，大多数的LCD控制器都没有自己的显存空间，被分配的地址空间的起始地址与长度将会被填充到fb_fix_screeninfo 结构的smem_start 和smem_len 的两个变量中.被分配的空间必须是物理连续的。</p><p>2）实现 fb_ops 中的函数<br />用户应用程序通过ioctl()系统调用操作硬件，fb_ops 中的函数就用于支持这些操作。（注： fb_ops结构与file_operations 结构不同，fb_ops是底层操作的抽象,而file_operations是提供给上层系统调用的接口，可以直接调用.<br />  ioctl()系统调用在文件fbmem.c中实现，通过观察可以发现ioctl()命令与fb_ops&rsquo;s 中函数的关系:<br />FBIOGET_VSCREENINFO fb_get_var<br />FBIOPUT_VSCREENINFO fb_set_var<br />FBIOGET_FSCREENINFO fb_get_fix<br />FBIOPUTCMAP fb_set_cmap<br />FBIOGETCMAP fb_get_cmap<br />FBIOPAN_DISPLAY fb_pan_display</p><p><br />如果我们定义了fb_XXX_XXX 方法，用户程序就可以使用FBIOXXXX宏的ioctl()操作来操作硬件。</p><p>文件linux/drivers/video/fbgen.c或者linux/drivers/video目录下的其它设备驱动是比较好的参考资料。在所有的这些函数中fb_set_var()是最重要的，它用于设定显示卡的模式和其它属性，下面是函数fb_set_var()的执行步骤：</p><p>1)检测是否必须设定模式<br />2)设定模式</p><p>3)设定颜色映射</p><p>4) 根据以前的设定重新设置LCD控制器的各寄存器。</p><p>第四步表明了底层操作到底放置在何处。在系统内存中分配显存后，显存的起始地址及长度将被设定到LCD控制器的各寄存器中（一般通过fb_set_var() 函数），显存中的内容将自动被LCD控制器输出到屏幕上。另一方面，用户程序通过函数mmap()将显存映射到用户进程地址空间中，然后用户进程向映射空间发送的所有数据都将会被显示到LCD显示器上。</p><p>&lt;!--[if !supportEmptyParas]--&gt; &lt;!--[endif]--&gt;</p><p>&lt;!--[if !supportLists]--&gt;三、&lt;!--[endif]--&gt;FrameBuffer的应用</p><p>（一）、一个使用FrameBuffer的例子</p><p>1、FrameBuffer主要是根据VESA标准的实现的，所以只能实现最简单的功能。</p><p>2、由于涉及内核的问题，FrameBuffer是不允许在系统起来后修改显示模式等一系列操作。（好象很多人都想要这样干，这是不被允许的，当然如果你自己写驱动的话，是可以实现的）.</p><p>3、对FrameBuffer的操作，会直接影响到本机的所有控制台的输出，包括XWIN的图形界面。</p><p>好，现在可以让我们开始实现直接写屏：</p><p>1、打开一个FrameBuffer设备</p><p>2、通过mmap调用把显卡的物理内存空间映射到用户空间</p><p>3、直接写内存。</p><p>/********************************</p><p>File name : fbtools.h</p><p>*/</p><p>#ifndef _FBTOOLS_H_</p><p>#define _FBTOOLS_H_</p><p>＃i nclude &lt;linux/fb.h&gt;</p><p>//a framebuffer device structure;</p><p>typedef struct fbdev{</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  int fb;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  unsigned long fb_mem_offset;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  unsigned long fb_mem;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  struct fb_fix_screeninfo fb_fix;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  struct fb_var_screeninfo fb_var;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  char dev[20];</p><p>} FBDEV, *PFBDEV;</p><p>//open &amp; init a frame buffer</p><p>//to use this function,</p><p>//you must set FBDEV.dev=&quot;/dev/fb0&quot;</p><p>//or &quot;/dev/fbX&quot;</p><p>//it's your frame buffer.</p><p>int fb_open(PFBDEV pFbdev);</p><p>//close a frame buffer</p><p>int fb_close(PFBDEV pFbdev);</p><p>//get display depth</p><p>int get_display_depth(PFBDEV pFbdev);</p><p>//full screen clear</p><p>void fb_memset(void *addr, int c, size_t len);</p><p>#endif</p><p>&lt;!--[if !supportEmptyParas]--&gt; &lt;!--[endif]--&gt;</p><p>/******************</p><p>File name : fbtools.c</p><p>*/</p><p>＃i nclude &lt;stdio.h&gt;</p><p>＃i nclude &lt;stdlib.h&gt;</p><p>＃i nclude &lt;fcntl.h&gt;</p><p>＃i nclude &lt;unistd.h&gt;</p><p>＃i nclude &lt;string.h&gt;</p><p>＃i nclude &lt;sys/ioctl.h&gt;</p><p>＃i nclude &lt;sys/mman.h&gt;</p><p>＃i nclude &lt;asm/page.h&gt;</p><p>＃i nclude &quot;fbtools.h&quot;</p><p>#define TRUE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  1</p><p>#define FALSE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  0</p><p>#define MAX(x,y)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  ((x)&gt;(y)?(x)y))</p><p>#define MIN(x,y)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  ((x)&lt;(y)?(x)y))</p><p>//open &amp; init a frame buffer</p><p>int fb_open(PFBDEV pFbdev)</p><p>{</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  pFbdev-&gt;fb = open(pFbdev-&gt;dev, O_RDWR);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  if(pFbdev-&gt;fb &lt; 0)</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  printf(&quot;Error opening %s: %m. Check kernel config\n&quot;, pFbdev-&gt;dev);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  return FALSE;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  }</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  if (-1 == ioctl(pFbdev-&gt;fb,FBIOGET_VSCREENINFO,&amp;(pFbdev-&gt;fb_var)))</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  printf(&quot;ioctl FBIOGET_VSCREENINFO\n&quot;);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  return FALSE;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  }</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  if (-1 == ioctl(pFbdev-&gt;fb,FBIOGET_FSCREENINFO,&amp;(pFbdev-&gt;fb_fix)))</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  printf(&quot;ioctl FBIOGET_FSCREENINFO\n&quot;);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  return FALSE;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  }</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  //map physics address to virtual address</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  pFbdev-&gt;fb_mem_offset = (unsigned long)(pFbdev-&gt;fb_fix.smem_start) &amp; (~PAGE_MASK);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  pFbdev-&gt;fb_mem = (unsigned long int)mmap(NULL, pFbdev-&gt;fb_fix.smem_len + pFbdev-&gt;fb_mem_offset,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  PROT_READ | PROT_WRITE, MAP_SHARED, pFbdev-&gt;fb, 0);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  if (-1L == (long) pFbdev-&gt;fb_mem)</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  printf(&quot;mmap error! mem:%d offset:%d\n&quot;, pFbdev-&gt;fb_mem, pFbdev-&gt;fb_mem_offset);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  return FALSE;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  }</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  return TRUE;</p><p>}</p><p>//close frame buffer</p><p>int fb_close(PFBDEV pFbdev)</p><p>{</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  close(pFbdev-&gt;fb);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  pFbdev-&gt;fb=-1;</p><p>}</p><p>//get display depth</p><p>int get_display_depth(PFBDEV pFbdev);</p><p>{</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  if(pFbdev-&gt;fb&lt;=0)</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  printf(&quot;fb device not open, open it first\n&quot;);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  return FALSE;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  }</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  return pFbdev-&gt;fb_var.bits_per_pixel;</p><p>}</p><p>//full screen clear</p><p>void fb_memset (void *addr, int c, size_t len)</p><p>{</p><p>&nbsp;&nbsp;&nbsp;  memset(addr, c, len);</p><p>}</p><p>//use by test</p><p>#define DEBUG</p><p>#ifdef DEBUG</p><p>main()</p><p>{</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  FBDEV fbdev;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  memset(&amp;fbdev, 0, sizeof(FBDEV));</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  strcpy(fbdev.dev, &quot;/dev/fb0&quot;);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  if(fb_open(&amp;fbdev)==FALSE)</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  printf(&quot;open frame buffer error\n&quot;);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  return;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  }</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  fb_memset(fbdev.fb_mem + fbdev.fb_mem_offset, 0, fbdev.fb_fix.smem_len);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  fb_close(&amp;fbdev);</p><p>}</p><p>（二）基于Linux核心的汉字显示的尝试</p><p>我们以一个简单的例子来说明字符显示的过程。我们假设是在虚拟终端1（/dev/tty1）下运行一个如下的简单程序。</p><p>main ( )</p><p>{</p><p>puts(&quot;hello, world.\n&quot;);</p><p>}</p><p>puts 函数向缺省输出文件(/dev/tty1)发出写的系统调用write(2)。系统调用到linux核心里面对应的核心函数是console.c中的 con_write()，con_write()最终会调用do_con_write( )。在do_con_write( )中负责把&quot;hello, world.\n&quot;这个字符串放到tty1对应的缓冲区中去。</p><p>do_con_write( )还负责处理控制字符和光标的位置。让我们来看一下do_con_write()这个函数的声明。</p><p>static int do_con_write(struct tty_struct * tty, int from_user, const unsigned char *buf, int count)</p><p>其中tty是指向tty_struct结构的指针，这个结构里面存放着关于这个tty的所有信息（请参照 linux/include/linux/tty.h）。Tty_struct结构中定义了通用（或高层）tty的属性（例如宽度和高度等）。在do_con_write( )函数中用到了tty_struct结构中的driver_data变量。driver_data是一个vt_struct指针。在vt_struct结构中包含这个tty的序列号（我们正使用tty1，所以这个序号为1）。Vt_struct结构中有一个vc结构的数组vc_cons，这个数组就是各虚拟终端的私有数据。</p><p>static int do_con_write(struct tty_struct * tty, int from_user,const unsigned char *buf, int count)</p><p>{</p><p>struct vt_struct *vt = (struct vt_struct *)tty-&gt;driver_data;//我们用到了driver_data变量</p><p>. . . . .</p><p>currcons = vt-&gt;vc_num; file://我们在这里的vc_nums就是1</p><p>. . . . .</p><p>}</p><p>要访问虚拟终端的私有数据，需使用vc_cons〔currcons〕.d指针。这个指针指向的结构含有当前虚拟终端上光标的位置、缓冲区的起始地址、缓冲区大小等等。</p><p>&quot;hello, world.\n&quot;中的每一个字符都要经过conv_uni_to_pc( )这个函数转换成８位的显示字符。这要做的主要目的是使不同语言的国家能把１６位的UniCode码映射到8位的显示字符集上，目前还是主要针对欧洲国家的语言，映射结果为8位，不包含对双字节（double byte）的范围。</p><p>这种UNICODE到显示字符的映射关系可以由用户自行定义。在缺省的映射表上，会把中文的字符映射到其他的字符上，这是我们不希望看到也是不需要的。所以我们有两个选择∶</p><p>1不进行conv_uni_to_pc( )的转换。</p><p>2加载符合双字节处理的映射关系，即对非控制字符进行1对1的不变映射。我们自己定制的符合这种映射关系的UNICODE码表是direct.uni。要想查看/装载当前系统的unicode映射表，可使外部命令loadunimap。</p><p>经过conv_uni_to_pc( )转换之后，&quot;hello, world.\n&quot;中的字符被一个一个地填写到tty1的缓冲区中。然后do_con_write( )调用下层的驱动，把缓冲区中的内容输出到显示器上（也就相当于把缓冲区的内容拷贝到VGA显存中去）。</p><p>sw-&gt;con_putcs(vc_cons〔currcons〕.d, (u16 *)draw_from, (u16*)draw_to-(u16 *)draw_from, y, draw_x);</p><p>之所以要调用底层驱动，是因为存在不同的显示设备，其对应VGA显存的存取方式也不一样。</p><p>上面的Sw-&gt;con_putcs( )就会调用到fbcon.c中的fbcon_putcs()函数（con_putcs是一个函数的指针，在Framebuffer模式下指向 fbcon_putcs()函数）。也就是说在do_con_write( )函数中是直接调用了fbcon_putcs()函数来进行字符的绘制。比如说在256色模式下，真正负责输出的函数是void fbcon_cfb8_putcs(struct vc_data *conp, struct display *p,const unsigned short *s, int count, int yy, int xx)</p><p>显示中文</p><p>比如说我们试图输出一句中文∶putcs(你好\n );（你好的内码为0xc4,0xe3,0xba,0xc3）。这时候会怎么样呢，有一点可以肯定，＂你好＂肯定不会出现在屏幕上，国为核心中没有汉字字库，中文显示就是无米之炊了．</p><p>1 在负责字符显示的void fbcon_cfb8_putcs( )函数中，原有操作如下∶对于每个要显示的字符，依次从虚拟终端缓冲区中以WORD为单位读取（低位字节是ASCII码，高8位是字符的属性），由于汉字是双字节编码方式，所以这种操作是不可能显示出汉字的，只能显示出xxxx_putcs()是一个一个VGA字符．</p><p>要解决的问题∶</p><p>确保在do_con_write( )时uni□pc转换不会改变原有编码。一个很直接的实现方式就是加载一个我们自己定制的UNICODE映射表，loadunimapdirect.uni，或者直接把direct.uni置为核心的缺省映射表。</p><p>针对如上问题，我们要做的第一个尝试方案是如下。</p><p>首先需要在核心中加载汉字字库，然后修改fbcon_cfb8_putcs()函数，在fbcon_cfb8_putcs( )中一次读两个WORD，检查这两个WORD的低位字节是否能拼成一个汉字，如果发现能拼成一个汉字，就算出这个汉字在汉字字库中的偏移，然后把它当成一个16 x 16的VGA字符来显示。</p><p>试验的结果表明∶</p><p>1能够输出汉字，但仍有许多不理想的地方，比如说，输出以半个汉字开始的一串汉字，则这半个汉字后面的汉字都会是乱码。这是半个汉字的问题。</p><p>2光标移动会破坏汉字的显示。表现为，光标移动过的汉字会变成乱码。这是因为光标的更新是通过xxxx_putc( )函数来完成的。</p><p>xxxx_putc( )函数与xxxx_putcs( )函数实现的功能类似，但是xxxx_putc()函数只刷新一个字符而不是一个字符串，因而xxxx_putc()的输入参数是一个整数，而不是一个字符串的地址。Xxxx_putc( )函数的声明如下∶void fbcon_cfb8_putc(struct vc_data *conp, struct display *p, int c, int yy, int xx)</p><p>下一个尝试方案就是同时修改xxxx_putcs( )函数和xxxx_putc()函数。为了解决半个汉字的问题，每一次输出之前，都从屏幕当前行的起始位置开始扫描，以确定要输出的字符是否落在半个汉字的位置上。如果是半个汉字的位置，则进行相应的调整，即从向前移动一个字节的位置开始输出。</p><p>这个方案有一个困难，即xxxx_putc( )函数不用缓冲区的地址，而是用一个整数作为参数。所以xxxx_putc( )无法直接利用相邻的字符来判别该定符是否是汉字。</p><p>解决方案是，利用xxxx_putc( )的光标位置参数（yy, xx），可以逆推出该字符在缓冲区中的位置。但仍有一些小麻烦，在Linux的虚拟终端下，用户可能会上卷该屏幕（shift + pageup），导致光标的y座标和相应字符在缓冲区的行数不一致。相应的解决方案是，在逆推的过程中，考虑卷屏的参量。</p><p>这样一来，我们就又进了一步，得到了一个相对更好的版本。但仍有问题没有解决。敲入turbonetcfg，会发现菜单的边框字符也被当成汉字显示。这是因为，这种边框字符是扩展字符，也使用了字符的第8位，因而被当作汉字来显示。例如，单线一的制表符内码为0xC4，当连成一条长线就是由一连串0xC4组成，而0xC4C4正是汉字哪。于是水平的制表符被一连串的哪字替代了。要解决这个问题就非常不容易了，因为制表符的种类比较多，而且垂直制表符与其后面字符的组合型式又多种多样，因而很难判断出相应位置的字符是不是制表符，从理论上说，无论采取什么样的排除算法，都必然存在误判的情况，因为总存在二义性，没有充足的条件来推断出当前字符究竟是制表符还是汉字。</p><p>我们一方面寻找更好的排除组合算法，一方面试图寻找其它的解决方案。要想从根本上解决定个问题，必须利用其它的辅助信息，仅仅从缓冲区的字符来判断是不够的。</p><p>经过一番努力，我们发现，在UNIX中使用扩展字符时，都要先输出字符转义序列（Escape sequence）来切换当前字符集。字符转义序列是以控制字符Esc为首的控制命令，在UNIX的虚拟终端中完成终端控制命令，这种命令包括，移动光标座标、卷屏、删除、切换字符集等等。也就是说在输出代表制表符的字符串之前，通常是要先输出特定的字符转义序列。在console.c里，有根据字符转义序列命令来记录字符状态的变量。结合该变量提供的信息，就可以非常干净地把制表符与汉字区别开来。</p><p>在如上思路的指引下，我们又产生了新的解决方案。经过改动得到了另一各版本．</p><p>在这个新版本上，turbonetcfg在初次绘制的时候，制表符与汉字被清晰地区分开来，结果是非常正确的。但还有新的问题存在∶turbonetcfg 在重绘的时候（如切换虚拟终端或是移动鼠标光标的时候），制表符还是变成了汉字，因为重绘完全依赖于缓冲区，而这时用来记录字符集状态的变量并不反映当前字符集状态。问题还是没有最终解决。我们又回到了起点。∶( 看来问题的最终解决手段必须是把字符集的状态伴随每一个字符存在缓冲区中。让我们来研究一下缓冲区的结构。每一个字符占用16bit的缓冲区，低8位是ASCII值，完全被利用，高8位包含前景颜色和背景颜色的属性，也没有多余的空间可以利用。因而只能另外开辟新的缓冲区。为了保持一致性，我们决定在原来的缓冲区后面添加相同大小的缓冲区，用来存放是否是汉字的信息。</p><p>也许有读者会问，我们只需要为每个字符添加一bit</p> </div>    <div class="mod-tagbox clearfix">   <a class="tag" href="/tag/%E5%B5%8C%E5%85%A5%E5%BC%8F/feeds">#嵌入式</a>  </div> <div class="mod-post-info clearfix">  <div class=x-bdshare>  <div id=bdshare class="bdshare_t bds_tools get-codes-bdshare" data="{'wbuid':1727466295}"> <span class=bds_more>分享到：</span> <a class=bds_qzone></a> <a class=bds_tsina></a> <a class=bds_tqq></a> <a class=bds_renren></a> </div> <script id=bdshare_js data="type=tools&amp;uid=713670"></script> <script id=bdshell_js></script> <script>
        var bds_config = {'bdTop':240};
                    var all_img = qing.g('content').getElementsByTagName('img');
            if(all_img.length>0){
                bds_config.bdPic = all_img[0].src;
            }
                document.getElementById("bdshell_js").src = "http://bdimg.share.baidu.com/static/js/shell_v2.js?v=66280422.js?cdnversion=" + Math.ceil(new Date()/3600000);
    </script> </div> <div class="op-box mod-cs-opBox">  <a class="report-btn hide" target=_blank href="#"> 举报 </a>  <span class=pv>浏览(371)</span> <a class=comment-bnt id=commentBnt href="#" onclick="return false"> 评论<span class=comment-nub>(1)</span> </a>   <a href="#" id=shareBnt onclick="return false" class=share-bnt> 转载<span id=shareNub class=share-nub>(1)</span> </a>   </div> </div>   </div>    <div class=mod-share-detail id=shareDetail style=display:none></div>   <div class=mod-relate-blogs id=relateBlog> <h3 class=relate-title>你可能也喜欢</h3> <ul class="relate-blog-list clearfix">   <li  class=first > <a href="http://hi.baidu.com/ixiqicom/item/9f74e44c8b23e58560d7b94a" target=_blank class=qing-stat-nsclick data-nsclick=m_20121105_detail_relates_img> <img src="http://f.hiphotos.baidu.com/space/scrop=90/sign=2233f1821b4c510faa9aa54510641c1d/6609c93d70cf3bc73a4ae2a6d000baa1cd112a35.jpg" class=relate-img alt="大鱼吃小鱼~可爱的灯具和椅子组合：Catch Collection" title="大鱼吃小鱼~可爱的灯具和椅子组合：Catch Collection"> </a> <a href="http://hi.baidu.com/ixiqicom/item/9f74e44c8b23e58560d7b94a" target=_blank class="relate-txt qing-stat-nsclick" data-nsclick=m_20121105_detail_relates_txt>大鱼吃小鱼~可爱的灯具和椅子组合：Catch Collection</a>    <li > <a href="http://hi.baidu.com/gunxueqiu8888/item/1654862bb8771de2a4275a71" target=_blank class=qing-stat-nsclick data-nsclick=m_20121105_detail_relates_img> <img src="http://g.hiphotos.baidu.com/space/scrop=90/sign=e4efec79908fa0ec7b99235256aa60de/ca1349540923dd54d0718922d009b3de9c82487d.jpg" class=relate-img alt="意想不到的创意家居" title="意想不到的创意家居"> </a> <a href="http://hi.baidu.com/gunxueqiu8888/item/1654862bb8771de2a4275a71" target=_blank class="relate-txt qing-stat-nsclick" data-nsclick=m_20121105_detail_relates_txt>意想不到的创意家居</a>    <li > <a href="http://hi.baidu.com/maimijiaju/item/23a8ef07e75185d0ff240d40" target=_blank class=qing-stat-nsclick data-nsclick=m_20121105_detail_relates_img> <img src="http://e.hiphotos.baidu.com/space/scrop=90/sign=75ea682fb219ebc4c42631c6f21bf6cc/a044ad345982b2b7dc796e8e30adcbef77099b91.jpg" class=relate-img alt="DIY创意小家居：废旧灯泡再利用" title="DIY创意小家居：废旧灯泡再利用"> </a> <a href="http://hi.baidu.com/maimijiaju/item/23a8ef07e75185d0ff240d40" target=_blank class="relate-txt qing-stat-nsclick" data-nsclick=m_20121105_detail_relates_txt>DIY创意小家居：废旧灯泡再利用</a>    <li > <a href="http://hi.baidu.com/duduguizu/item/48250547f39fccd21381da70" target=_blank class=qing-stat-nsclick data-nsclick=m_20121105_detail_relates_img> <img src="http://h.hiphotos.baidu.com/space/scrop=90/sign=341d8b88b3119313c31db8ef150535e7/1ad5ad6eddc451dae69549a1b7fd5266d016321c.jpg" class=relate-img alt="120平三居家居装修效果 现代简约" title="120平三居家居装修效果 现代简约"> </a> <a href="http://hi.baidu.com/duduguizu/item/48250547f39fccd21381da70" target=_blank class="relate-txt qing-stat-nsclick" data-nsclick=m_20121105_detail_relates_txt>120平三居家居装修效果 现代简约</a>    <li > <a href="http://hi.baidu.com/ssly7/item/4e1e4653caeffc07abf6d7a7" target=_blank class=qing-stat-nsclick data-nsclick=m_20121105_detail_relates_img> <img src="http://a.hiphotos.baidu.com/space/scrop=90/sign=e5e14984e5dde711e38c04a9d7d2f72b/78310a55b319ebc487c68f188226cffc1f1716f0.jpg" class=relate-img alt="浪漫地中海家装设计 家的度假旅程" title="浪漫地中海家装设计 家的度假旅程"> </a> <a href="http://hi.baidu.com/ssly7/item/4e1e4653caeffc07abf6d7a7" target=_blank class="relate-txt qing-stat-nsclick" data-nsclick=m_20121105_detail_relates_txt>浪漫地中海家装设计 家的度假旅程</a>    <li > <a href="http://hi.baidu.com/yirenjiaju1/item/1ad6255d9d3d16bb8c12edd1" target=_blank class=qing-stat-nsclick data-nsclick=m_20121105_detail_relates_img> <img src="http://a.hiphotos.baidu.com/space/scrop=90/sign=e1e1418983025aafd76c39948bd09254/c75c10385343fbf282e3a16ab17eca8064388faf.jpg" class=relate-img alt="老房华丽蜕变 真的难以想像" title="老房华丽蜕变 真的难以想像"> </a> <a href="http://hi.baidu.com/yirenjiaju1/item/1ad6255d9d3d16bb8c12edd1" target=_blank class="relate-txt qing-stat-nsclick" data-nsclick=m_20121105_detail_relates_txt>老房华丽蜕变 真的难以想像</a>    <li > <a href="http://hi.baidu.com/dreammerge/item/1dd3d3cdbbd51524a0b50a82" target=_blank class=qing-stat-nsclick data-nsclick=m_20121105_detail_relates_img> <img src="http://c.hiphotos.baidu.com/space/scrop=90/sign=964d4ad9d688d43ff4f7d6ad0d23eb2b/730e0cf3d7ca7bcb60082a83be096b63f624a82f.jpg" class=relate-img alt="能吃苦才可以创业" title="能吃苦才可以创业"> </a> <a href="http://hi.baidu.com/dreammerge/item/1dd3d3cdbbd51524a0b50a82" target=_blank class="relate-txt qing-stat-nsclick" data-nsclick=m_20121105_detail_relates_txt>能吃苦才可以创业</a>   </ul> </div>   <div class="mod-detail-pager clearfix">  <div class=detail-nav-pre> <a href="http://hi.baidu.com/dreammerge/item/b1359694eb0e6cd91b49df86" hidefocus title="上一篇"></a> </div>   <div class=detail-nav-next> <a href="http://hi.baidu.com/dreammerge/item/b35fc5133069cceb9813d686" hidefocus title="下一篇"></a> </div>  </div>   <div id=commentDetail class="mod-comment-detail clearfix mod-cs-comment">   <div class=mod-recent-readers> <h3 class=recent-readers-title>本文最近访客</h3> <ul class="readers-list clearfix">    <li  class=first > <a target=_blank href="http://hi.baidu.com/aggio"> <img src="http://hiphotos.baidu.com/space/scrop%3D65%3Bq%3D100/sign%3Dedbb2e63828ba61edbb08f703109a13f/adaf2edda3cc7cd9d19e1c703901213fb90e91e3.jpg" title="code_ant" alt="code_ant" class=portrait> </a> <a target=_blank href="http://hi.baidu.com/aggio" class=user-name title="code_ant"> code_ant </a> <div class=visit-time data-visit-time="1366264507"></div>    </ul> </div>  <div class=comment-title>评论</div> <div class=comment-content></div> </div>   </div>  </div>  </div> </div> </section>  <footer class="mod-footer mod-cs-footer"><div class="clearfix hidden-box"></div><div class=footer-box><div class=inner-box><a href=http://help.baidu.com/question?prod_en=hi target=_blank>帮助中心</a><span>&nbsp;|&nbsp;</span><a href=http://tieba.baidu.com/p/1781683739 target=_blank>空间客服</a><span>&nbsp;|&nbsp;</span><a href=http://tousu.baidu.com/hi/add target=_blank>投诉中心</a><span>&nbsp;|&nbsp;</span><a href=http://www.baidu.com/search/hi_contract.html target=_blank>空间协议</a></div><div class=copy-box>&copy;2013&nbsp;Baidu</div></div></footer>  <script src="http://hi.bdimg.com/static/qbase/js/mod/mod_foot.js?v=747a1d59.js"></script> <script>
        	qing.dom.ready(function(){
                if (qVisitorInfo.loginStatus == 'activated'){
                    qext.stat.ns('m_20121012_loga_num');
					qext.fn.setStoken();
				}
			});
        </script>        <script>qext.stat.ns('m_20120425_');</script>  <script src="http://hi.bdimg.com/static/qcomment/js/qcmt_import.js?v=ac96f988.js"></script>  <script src="http://hi.bdimg.com/static/qpublish/js/editor/shCore.js?v=bcf5a2e1.js"></script> <script>
        SyntaxHighlighter.highlight();
    </script>   <script src="http://hi.bdimg.com/static/qhome/js/detail/20001/detail.js?v=7ff54b94.js"></script>   <script>wpo.tti=new Date*1;</script><script src="http://hi.baidu.com/cm/static/js/allsite.js?v=68594928.js?v=201305241049"></script><script>document.write(unescape("%3Cscript src='http://hm.baidu.com/h.js%3F8c869b543955d43e496c2efee5b55823' type='text/javascript'%3E%3C/script%3E"));qext.stat.ns('m_20120713_qing_pv');</script>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>详解linux下的串口通讯开发 - SunBo - 博客园</title>
<link type="text/css" rel="stylesheet" href="http://common.cnblogs.com/blog/css/common.css?id=20130323"/>
<link id="MainCss" type="text/css" rel="stylesheet" href="http://common.cnblogs.com/Skins/BlackSun/style.css?id=20130323"/>
<link type="text/css" rel="stylesheet" href="http://common.cnblogs.com/blog/css/common2.css"/>
<link type="text/css" rel="stylesheet" href="http://common.cnblogs.com/css/shStyle.css"/>
<link title="RSS" type="application/rss+xml" rel="alternate" href="http://www.cnblogs.com/sunyubo/rss"/>
<link title="RSD" type="application/rsd+xml" rel="EditURI" href="http://www.cnblogs.com/sunyubo/rsd.xml"/>
<link type="application/wlwmanifest+xml" rel="wlwmanifest" href="http://www.cnblogs.com/sunyubo/wlwmanifest.xml"/>
<script src="http://common.cnblogs.com/script/jquery.js" type="text/javascript"></script>  
<script type="text/javascript">
var currentBlogApp = 'sunyubo';
</script>
<script src="http://common.cnblogs.com/blog/script/common.js?id=20130323" type="text/javascript"></script> 
<script src="http://common.cnblogs.com/script/json2.js" type="text/javascript"></script>
<script type="text/javascript" src="http://common.cnblogs.com/script/syntaxHighlighter.js"></script>
</head>
<body>
<a name="top"></a>

<div id="top">
	
<div>
	<table class="HeaderTitles">
		<tr>
			<td>
				<h1 class="HeaderTitle"><a id="Header1_HeaderTitle" class="HeaderMainTitle" href="http://www.cnblogs.com/sunyubo/">SunBo</a></h1>
				<p id="tagline"></p>
			</td>
		</tr>
	</table>
</div>
<div>
	<table id="HeaderBar" class="HeaderBar">
		<tr>
			<td class="HeaderBarTab" nowrap>
				
&nbsp;
<a id="Header1_MyLinks1_HomeLink" href="http://www.cnblogs.com/">博客园</a>&nbsp;::
<a id="Header1_MyLinks1_MyHomeLink" href="http://www.cnblogs.com/sunyubo/">首页</a>&nbsp;::
<a id="Header1_MyLinks1_NewPostLink" rel="nofollow" href="http://www.cnblogs.com/sunyubo/admin/EditPosts.aspx?opt=1">新随笔</a>&nbsp;::
<a id="Header1_MyLinks1_ContactLink" accesskey="9" rel="nofollow" href="http://space.cnblogs.com/msg/send/SunBo">联系</a>&nbsp;::
<a id="Header1_MyLinks1_Syndication" href="http://www.cnblogs.com/sunyubo/rss">订阅</a>
<a id="Header1_MyLinks1_XMLLink" class="XMLLink" href="http://www.cnblogs.com/sunyubo/rss"><img src="http://www.cnblogs.com/images/xml.gif" alt="订阅" /></a>&nbsp;::
<a id="Header1_MyLinks1_Admin" rel="nofollow" href="http://www.cnblogs.com/sunyubo/admin/EditPosts.aspx">管理</a>

			</td>
			
			<td class="HeaderBarTabBack" nowrap width="100%">
				

	<table class="BlogStatsBar">
		<tr>
			<td width="100%">
			</td>
			<td class="BlogStatsBar" nowrap>
				&nbsp;
				337 
				Posts&nbsp;::
				0 Stories
				::
				3 Comments
				::
				0 Trackbacks
			</td>
		</tr>
	</table>

			</td>
		</tr>
	</table>
</div>

</div>
<table id="maintable">
	<tr><td id="leftmenu">
	
		
<h3>公告</h3>
<div class="News">
	<div id="blog-news"></div>
</div>

		<div id="blog-sidecolumn"></div>
	
</td><td id="main">
	
	
<div class="post">
			<div class="postTitle">
				<a id="cb_post_title_url" href="http://www.cnblogs.com/sunyubo/archive/2010/09/26/2282116.html">详解linux下的串口通讯开发</a>
			</div>
	
	<div class="postText">
		<div id="cnblogs_post_body"><p>串行口是计算机一种常用的接口，具有连接线少，通讯简单，得到广泛的使用。常用的串口是RS-232-C接口(又称EIA RS-232-C)它是在1970年由美国电子工业协会(EIA)联合贝尔系统、调制解调器厂家及计算机终端生产厂家共同制定的用于串行通讯的标准。串口通讯指的是计算机依次以位（bit）为单位来传送数据，串行通讯使用的范围很广，在嵌入式系统开发过程中串口通讯也经常用到通讯方式之一。</p>
<p>Linux对所有设备的访问是通过设备文件来进行的，串口也是这样，为了访问串口，只需打开其设备文件即可操作串口设备。在linux系统下面，每一个串口设备都有设备文件与其关联，设备文件位于系统的/dev目录下面。如linux下的/ttyS0，/ttyS1分别表示的是串口1和串口2。下面来详细介绍linux下是如何使用串口的：</p>
<p>1. 串口操作需要用到的头文件</p>
<p>#include /*标准输入输出定义*/</p>
<p>#include /*标准函数库定义*/</p>
<p>#include /*Unix 标准函数定义*/</p>
<p>#include </p>
<p>#include </p>
<p>#include /*文件控制定义*/</p>
<p>#include /*POSIX 终端控制定义*/</p>
<p>#include /*错误号定义*/</p>
<p>#include /*字符串功能函数*/</p>
<p>2. 串口通讯波特率设置</p>
<p>波特率的设置定义在，其包含在头文件里。</p>
<p>常用的波特率常数如下：</p>
<p>B0-------&agrave;0 B1800-------&agrave;1800</p>
<p>B50-----&agrave;50 B2400------&agrave;2400</p>
<p>B75-----&agrave;75 B4800------&agrave;4800</p>
<p>B110----&agrave;110 B9600------&agrave;9600</p>
<p>B134----&agrave;134.5 B19200-----&agrave;19200</p>
<p>B200----&agrave;200 B38400------&agrave;38400</p>
<p>B300----&agrave;300 B57600------&agrave;57600</p>
<p>B600----&agrave;600 B76800------&agrave;76800</p>
<p>B1200---&agrave;1200 B115200-----&agrave;115200</p>
<p>假定程序中想要设置通讯的波特率，使用cfsetispeed( )和cfsetospeed( )函数来操作，获取波特率信息是通过cfgetispeed（）和cfgetospeed（）函数来完成的。比如可以这样来指定串口通讯的波特率：</p>
<p>#include //头文件定义</p>
<p>........</p>
<p>........</p>
<p>.......</p>
<p>struct termios opt； /*定义指向termios 结构类型的指针opt*/</p>
<p>/***************以下设置通讯波特率****************/</p>
<p>cfsetispeed(&amp;opt，B9600 )； /*指定输入波特率，9600bps*/</p>
<p>cfsetospeed(&amp;opt，B9600)；/*指定输出波特率，9600bps*/</p>
<p>/************************************************/</p>
<p>.........</p>
<p>..........</p>
<p>一般来说，输入、输出的波特率应该是一致的。</p>
<p>3. 串口属性配置</p>
<p>在程序中，很容易配置串口的属性，这些属性定义在结构体struct termios中。为在程序中使用该结构体，需要包含文件，该头文件定义了结构体struct termios。该结构体定义如下：</p>
<p>#define NCCS 19</p>
<p>struct termios {</p>
<p>tcflag_t c_iflag; /* 输入参数 */</p>
<p>tcflag_t c_oflag; /* 输出参数 */</p>
<p>tcflag_t c_cflag; /* 控制参数*/</p>
<p>tcflag_t c_ispeed; /* 输入波特率 */</p>
<p>tcflag_t c_ospeed; /* 输出波特率 */</p>
<p>cc_t c_line; /* 线控制 */</p>
<p>cc_t c_cc[NCCS]; /* 控制字符*/</p>
<p>};</p>
<p>其中成员c_line在POSIX(Portable Operating System Interface for UNIX)系统中不使用。对于支持POSIX终端接口的系统中，对于端口属性的设置和获取要用到两个重要的函数是：</p>
<p>（1）.int tcsetattr（int fd，int opt_DE，*ptr）</p>
<p>该函数用来设置终端控制属性，其参数说明如下：</p>
<p>l fd：待操作的文件描述符</p>
<p>l opt_DE：选项值，有三个选项以供选择：</p>
<p>TCSANOW： 不等数据传输完毕就立即改变属性</p>
<p>TCSADRAIN：等待所有数据传输结束才改变属性</p>
<p>TCSAFLUSH：清空输入输出缓冲区才改变属性</p>
<p>l *ptr：指向termios结构的指针</p>
<p>函数返回值：成功返回0，失败返回－1。</p>
<p>（2）.int tcgetattr（int fd，*ptr）</p>
<p>该函数用来获取终端控制属性，它把串口的默认设置赋给了termios数据数据结构，其参数说明如下：</p>
<p>l fd：待操作的文件描述符</p>
<p>l *ptr：指向termios结构的指针</p>
<p>函数返回值：成功返回0，失败返回－1。</p>
<p>4. 打开串口</p>
<p>在前面已经提到linux下的串口访问是以设备文件形式进行的，所以打开串口也即是打开文件的操作。函数原型可以如下所示：</p>
<p>int open（&ldquo;DE_name&rdquo;，int open_Status）</p>
<p>参数说明：</p>
<p>（1）.DE_name：要打开的设备文件名</p>
<p>比如要打开串口1，即为/dev/ttyS0。</p>
<p>（2）.open_Status：文件打开方式，可采用下面的文件打开模式：</p>
<p>l O_RDONLY：以只读方式打开文件</p>
<p>l O_WRONLY：以只写方式打开文件</p>
<p>l O_RDWR：以读写方式打开文件</p>
<p>l O_APPEND：写入数据时添加到文件末尾</p>
<p>l O_CREATE：如果文件不存在则产生该文件，使用该标志需要设置访问权限位mode_t</p>
<p>l O_EXCL：指定该标志，并且指定了O_CREATE标志，如果打开的文件存在则会产生一个错误</p>
<p>l O_TRUNC：如果文件存在并且成功以写或者只写方式打开，则清除文件所有内容，使得文件长度变为0 </p>
<p>l O_NOCTTY：如果打开的是一个终端设备，这个程序不会成为对应这个端口的控制终端，如果没有该标志，任何一个输入，例如键盘中止信号等，都将影响进程。</p>
<p>l O_NONBLOCK：该标志与早期使用的O_NDELAY标志作用差不多。程序不关心DCD信号线的状态，如果指定该标志，进程将一直在休眠状态，直到DCD信号线为0。</p>
<p>函数返回值：</p>
<p>成功返回文件描述符，如果失败返回-1 </p>
<p>例如假定以可读写方式打开/dev/ttyS0设备，就可以这样操作：</p>
<p>#include //头文件包含</p>
<p>......</p>
<p>......</p>
<p>int fd; /* 文件描述符 */ </p>
<p>fd = open("/dev/ttyS0", O_RDWR | 0_NOCTTY)； /*以读写方式打开设备*/</p>
<p>if(fd == -1)</p>
<p>perror("Can not open Serial_Port 1/n！")；/*打开失败时的错误提示*/</p>
<p>........ </p>
<p>........</p>
<p>5. 串口读操作（接收端）</p>
<p>用open函数打开设备文件，函数返回一个文件描述符(file descriptors,fd)，通过文件描述符来访问文件。读串口操作是通过read函数来完成的。函数原型如下：</p>
<p>int read(int fd, *buffer,length)；</p>
<p>参数说明：</p>
<p>（1）.int fd：文件描述符</p>
<p>（2）.*buffer：数据缓冲区</p>
<p>（3）.length：要读取的字节数</p>
<p>函数返回值：</p>
<p>读操作成功读取返回读取的字节数，失败则返回-1。</p>
<p>6. 串口写操作（发送端）</p>
<p>写串口操作是通过write函数来完成的。函数原型如下：</p>
<p>write(int fd, *buffer,length); </p>
<p>参数说明：</p>
<p>（1）.fd：文件描述符</p>
<p>（2）.*buffer：存储写入数据的数据缓冲区</p>
<p>（3）.length：写入缓冲去的数据字节数</p>
<p>函数返回值：</p>
<p>成功返回写入数据的字节数,该值通常等于length，如果写入失败返回-1。</p>
<p>例如：向终端设备发送初始化命令</p>
<p>#include //头文件包含</p>
<p>......</p>
<p>......</p>
<p>int n </p>
<p>sbuf[]={Hello，this is a Serial_Port test！/n }；//待发送数据</p>
<p>int len_send="sizeof"（sbuf）；//发送缓冲区字节数定义</p>
<p>n = write(fd,sbuf,len_send); //写缓冲区</p>
<p>if(n == -1) </p>
<p>{ </p>
<p>printf("Wirte sbuf error./n"); </p>
<p>} </p>
<p>......</p>
<p>......</p>
<p>7. 关闭串口</p>
<p>对设备文件的操作与对普通文件的操作一样，打开操作之后还需要关闭，关闭串口用函数close( )来操作，函数原型为：</p>
<p>int close(int fd); </p>
<p>参数说明：</p>
<p>fd：文件描述符</p>
<p>函数返回值：</p>
<p>成功返回0，失败返回-1。</p>
<h4>NAME</h4>
<p>termios, tcgetattr, tcsetattr, tcsendbreak, tcdrain, tcflush, tcflow, cfmakeraw, cfgetospeed, cfgetispeed, cfsetispeed, cfsetospeed - 获取和设置终端属性，行控制，获取和设置波特率 <a name="lbAC"></a></p>
<h4>SYNOPSIS 总览</h4>
<p><strong>#include &lt;<a href="file:///usr/include/termios.h">termios.h</a>&gt; <br />#include &lt;<a href="file:///usr/include/unistd.h">unistd.h</a>&gt; </strong></p>
<p><strong>int tcgetattr(int </strong><em>fd</em><strong>, struct termios *</strong><em>termios_p</em><strong>);</strong></p>
<p><strong>int tcsetattr(int </strong><em>fd</em><strong>, int </strong><em>optional_actions</em><strong>, struct termios *</strong><em>termios_p</em><strong>);</strong></p>
<p><strong>int tcsendbreak(int </strong><em>fd</em><strong>, int </strong><em>duration</em><strong>);</strong></p>
<p><strong>int tcdrain(int </strong><em>fd</em><strong>);</strong></p>
<p><strong>int tcflush(int </strong><em>fd</em><strong>, int </strong><em>queue_selector</em><strong>);</strong></p>
<p><strong>int tcflow(int </strong><em>fd</em><strong>, int </strong><em>action</em><strong>);</strong></p>
<p><strong>int cfmakeraw(struct termios *</strong><em>termios_p</em><strong>);</strong></p>
<p><strong>speed_t cfgetispeed(struct termios *</strong><em>termios_p</em><strong>);</strong></p>
<p><strong>speed_t cfgetospeed(struct termios *</strong><em>termios_p</em><strong>);</strong></p>
<p><strong>int cfsetispeed(struct termios *</strong><em>termios_p</em><strong>, speed_t </strong><em>speed</em><strong>);</strong></p>
<p><strong>int cfsetospeed(struct termios *</strong><em>termios_p</em><strong>, speed_t </strong><em>speed</em><strong>);</strong> <a name="lbAD"></a></p>
<h4>DESCRIPTION 描述</h4>
<p>termios 函数族提供了一个常规的终端接口，用于控制非同步通信端口。 </p>
<p>这里描述的大部分属性有一个 <em>termios_p</em> 类型的参数，它是指向一个 <strong>termios</strong> 结构的指针。这个结构包含了至少下列成员： </p>
<dl><dt></dt><dd>
<pre>tcflag_t <em>c_iflag</em>;      /* 输入模式 */<br />tcflag_t <em>c_oflag</em>;      /* 输出模式 */<br />tcflag_t <em>c_cflag</em>;      /* 控制模式 */<br />tcflag_t <em>c_lflag</em>;      /* 本地模式 */<br />cc_t <em>c_cc</em>[<strong>NCCS</strong>];       /* 控制字符 */<br /></pre>
</dd></dl>
<p><em>c_iflag</em> 标志常量： </p>
<dl><dt><strong>IGNBRK</strong></dt><dd>忽略输入中的 BREAK 状态。 </dd><dt><strong>BRKINT</strong></dt><dd>如果设置了 <strong>IGNBRK</strong>，将忽略 BREAK。如果没有设置，但是设置了 <strong>BRKINT</strong>，那么 BREAK 将使得输入和输出队列被刷新，如果终端是一个前台进程组的控制终端，这个进程组中所有进程将收到 <strong>SIGINT</strong> 信号。如果既未设置 <strong>IGNBRK</strong> 也未设置 <strong>BRKINT</strong>，BREAK 将视为与 NUL 字符同义，除非设置了 <strong>PARMRK</strong>，这种情况下它被视为序列 /377 /0 /0。 </dd><dt><strong>IGNPAR</strong></dt><dd>忽略桢错误和奇偶校验错。 </dd><dt><strong>PARMRK</strong></dt><dd>如果没有设置 <strong>IGNPAR</strong>，在有奇偶校验错或桢错误的字符前插入 /377 /0。如果既没有设置 <strong>IGNPAR</strong> 也没有设置 <strong>PARMRK</strong>，将有奇偶校验错或桢错误的字符视为 /0。 </dd><dt><strong>INPCK</strong></dt><dd>启用输入奇偶检测。 </dd><dt><strong>ISTRIP</strong></dt><dd>去掉第八位。 </dd><dt><strong>INLCR</strong></dt><dd>将输入中的 NL 翻译为 CR。 </dd><dt><strong>IGNCR</strong></dt><dd>忽略输入中的回车。 </dd><dt><strong>ICRNL</strong></dt><dd>将输入中的回车翻译为新行 (除非设置了 <strong>IGNCR</strong>)。 </dd><dt><strong>IUCLC</strong></dt><dd>(不属于 POSIX) 将输入中的大写字母映射为小写字母。 </dd><dt><strong>IXON</strong></dt><dd>启用输出的 XON/XOFF 流控制。 </dd><dt><strong>IXANY</strong></dt><dd>(不属于 POSIX.1；XSI) 允许任何字符来重新开始输出。(?) </dd><dt><strong>IXOFF</strong></dt><dd>启用输入的 XON/XOFF 流控制。 </dd><dt><strong>IMAXBEL</strong></dt><dd>(不属于 POSIX) 当输入队列满时响零。Linux 没有实现这一位，总是将它视为已设置。 </dd></dl>
<p>POSIX.1 中定义的 <em>c_oflag</em> 标志常量： </p>
<dl><dt><strong>OPOST</strong></dt><dd>启用具体实现自行定义的输出处理。 </dd></dl>
<p>其余 <em>c_oflag</em> 标志常量定义在 POSIX 1003.1-2001 中，除非另外说明。 </p>
<dl><dt><strong>OLCUC</strong></dt><dd>(不属于 POSIX) 将输出中的小写字母映射为大写字母。 </dd><dt><strong>ONLCR</strong></dt><dd>(XSI) 将输出中的新行符映射为回车-换行。 </dd><dt><strong>OCRNL</strong></dt><dd>将输出中的回车映射为新行符 </dd><dt><strong>ONOCR</strong></dt><dd>不在第 0 列输出回车。 </dd><dt><strong>ONLRET</strong></dt><dd>不输出回车。 </dd><dt><strong>OFILL</strong></dt><dd>发送填充字符作为延时，而不是使用定时来延时。 </dd><dt><strong>OFDEL</strong></dt><dd>(不属于 POSIX) 填充字符是 ASCII DEL (0177)。如果不设置，填充字符则是 ASCII NUL。 </dd><dt><strong>NLDLY</strong></dt><dd>新行延时掩码。取值为 <strong>NL0</strong> 和 <strong>NL1</strong>。 </dd><dt><strong>CRDLY</strong></dt><dd>回车延时掩码。取值为 <strong>CR0</strong>, <strong>CR1</strong>, <strong>CR2</strong>, 或 <strong>CR3</strong>。 </dd><dt><strong>TABDLY</strong></dt><dd>水平跳格延时掩码。取值为 <strong>TAB0</strong>, <strong>TAB1</strong>, <strong>TAB2</strong>, <strong>TAB3</strong> (或 <strong>XTABS</strong>)。取值为 TAB3，即 XTABS，将扩展跳格为空格 (每个跳格符填充 8 个空格)。(?) </dd><dt><strong>BSDLY</strong></dt><dd>回退延时掩码。取值为 <strong>BS0</strong> 或 <strong>BS1</strong>。(从来没有被实现过) </dd><dt><strong>VTDLY</strong></dt><dd>竖直跳格延时掩码。取值为 <strong>VT0</strong> 或 <strong>VT1</strong>。 </dd><dt><strong>FFDLY</strong></dt><dd>进表延时掩码。取值为 <strong>FF0</strong> 或 <strong>FF1</strong>。 </dd></dl>
<p><em>c_cflag</em> 标志常量： </p>
<dl><dt><strong>CBAUD</strong></dt><dd>(不属于 POSIX) 波特率掩码 (4+1 位)。 </dd><dt><strong>CBAUDEX</strong></dt><dd>(不属于 POSIX) 扩展的波特率掩码 (1 位)，包含在 CBAUD 中。 </dd></dl>
<p>(POSIX 规定波特率存储在 termios 结构中，并未精确指定它的位置，而是提供了函数 <strong>cfgetispeed()</strong> 和 <strong>cfsetispeed()</strong> 来存取它。一些系统使用 <em>c_cflag</em> 中 CBAUD 选择的位，其他系统使用单独的变量，例如 <em>sg_ispeed</em> 和 <em>sg_ospeed</em> 。) </p>
<dl><dt><strong>CSIZE</strong></dt><dd>字符长度掩码。取值为 <strong>CS5</strong>, <strong>CS6</strong>, <strong>CS7</strong>, 或 <strong>CS8</strong>。 </dd><dt><strong>CSTOPB</strong></dt><dd>设置两个停止位，而不是一个。 </dd><dt><strong>CREAD</strong></dt><dd>打开接受者。 </dd><dt><strong>PARENB</strong></dt><dd>允许输出产生奇偶信息以及输入的奇偶校验。 </dd><dt><strong>PARODD</strong></dt><dd>输入和输出是奇校验。 </dd><dt><strong>HUPCL</strong></dt><dd>在最后一个进程关闭设备后，降低 modem 控制线 (挂断)。(?) </dd><dt><strong>CLOCAL</strong></dt><dd>忽略 modem 控制线。 </dd><dt><strong>LOBLK</strong></dt><dd>(不属于 POSIX) 从非当前 shell 层阻塞输出(用于 <strong>shl</strong> )。(?) </dd><dt><strong>CIBAUD</strong></dt><dd>(不属于 POSIX) 输入速度的掩码。CIBAUD 各位的值与 CBAUD 各位相同，左移了 IBSHIFT 位。 </dd><dt><strong>CRTSCTS</strong></dt><dd>(不属于 POSIX) 启用 RTS/CTS (硬件) 流控制。 </dd></dl>
<p><em>c_lflag</em> 标志常量： </p>
<dl><dt><strong>ISIG</strong></dt><dd>当接受到字符 INTR, QUIT, SUSP, 或 DSUSP 时，产生相应的信号。 </dd><dt><strong>ICANON</strong></dt><dd>启用标准模式 (canonical mode)。允许使用特殊字符 EOF, EOL, EOL2, ERASE, KILL, LNEXT, REPRINT, STATUS, 和 WERASE，以及按行的缓冲。 </dd><dt><strong>XCASE</strong></dt><dd>(不属于 POSIX; Linux 下不被支持) 如果同时设置了 <strong>ICANON</strong>，终端只有大写。输入被转换为小写，除了以 / 前缀的字符。输出时，大写字符被前缀 /，小写字符被转换成大写。 </dd><dt><strong>ECHO</strong></dt><dd>回显输入字符。 </dd><dt><strong>ECHOE</strong></dt><dd>如果同时设置了 <strong>ICANON</strong>，字符 ERASE 擦除前一个输入字符，WERASE 擦除前一个词。 </dd><dt><strong>ECHOK</strong></dt><dd>如果同时设置了 <strong>ICANON</strong>，字符 KILL 删除当前行。 </dd><dt><strong>ECHONL</strong></dt><dd>如果同时设置了 <strong>ICANON</strong>，回显字符 NL，即使没有设置 ECHO。 </dd><dt><strong>ECHOCTL</strong></dt><dd>(不属于 POSIX) 如果同时设置了 <strong>ECHO</strong>，除了 TAB, NL, START, 和 STOP 之外的 ASCII 控制信号被回显为 ^X, 这里 X 是比控制信号大 0x40 的 ASCII 码。例如，字符 0x08 (BS) 被回显为 ^H。 </dd><dt><strong>ECHOPRT</strong></dt><dd>(不属于 POSIX) 如果同时设置了 <strong>ICANON</strong> 和 <strong>IECHO</strong>，字符在删除的同时被打印。 </dd><dt><strong>ECHOKE</strong></dt><dd>(不属于 POSIX) 如果同时设置了 <strong>ICANON</strong>，回显 KILL 时将删除一行中的每个字符，如同指定了 <strong>ECHOE</strong> 和 <strong>ECHOPRT</strong> 一样。 </dd><dt><strong>DEFECHO</strong></dt><dd>(不属于 POSIX) 只在一个进程读的时候回显。 </dd><dt><strong>FLUSHO</strong></dt><dd>(不属于 POSIX; Linux 下不被支持) 输出被刷新。这个标志可以通过键入字符 DISCARD 来开关。 </dd><dt><strong>NOFLSH</strong></dt><dd>禁止在产生 SIGINT, SIGQUIT 和 SIGSUSP 信号时刷新输入和输出队列。 </dd><dt><strong>TOSTOP</strong></dt><dd>向试图写控制终端的后台进程组发送 SIGTTOU 信号。 </dd><dt><strong>PENDIN</strong></dt><dd>(不属于 POSIX; Linux 下不被支持) 在读入下一个字符时，输入队列中所有字符被重新输出。(<strong>bash</strong> 用它来处理 typeahead) </dd><dt><strong>IEXTEN</strong></dt><dd>启用实现自定义的输入处理。这个标志必须与 <strong>ICANON</strong> 同时使用，才能解释特殊字符 EOL2，LNEXT，REPRINT 和 WERASE，<strong>IUCLC</strong> 标志才有效。 </dd></dl>
<p><em>c_cc</em> 数组定义了特殊的控制字符。符号下标 (初始值) 和意义为： </p>
<dl><dt><strong>VINTR</strong></dt><dd>(003, ETX, Ctrl-C, or also 0177, DEL, rubout) 中断字符。发出 SIGINT 信号。当设置 ISIG 时可被识别，不再作为输入传递。 </dd><dt><strong>VQUIT</strong></dt><dd>(034, FS, Ctrl-/) 退出字符。发出 SIGQUIT 信号。当设置 ISIG 时可被识别，不再作为输入传递。 </dd><dt><strong>VERASE</strong></dt><dd>(0177, DEL, rubout, or 010, BS, Ctrl-H, or also #) 删除字符。删除上一个还没有删掉的字符，但不删除上一个 EOF 或行首。当设置 ICANON 时可被识别，不再作为输入传递。 </dd><dt><strong>VKILL</strong></dt><dd>(025, NAK, Ctrl-U, or Ctrl-X, or also @) 终止字符。删除自上一个 EOF 或行首以来的输入。当设置 ICANON 时可被识别，不再作为输入传递。 </dd><dt><strong>VEOF</strong></dt><dd>(004, EOT, Ctrl-D) 文件尾字符。更精确地说，这个字符使得 tty 缓冲中的内容被送到等待输入的用户程序中，而不必等到 EOL。如果它是一行的第一个字符，那么用户程序的 <em>read()</em> 将返回 0，指示读到了 EOF。当设置 ICANON 时可被识别，不再作为输入传递。 </dd><dt><strong>VMIN</strong></dt><dd>非 canonical 模式读的最小字符数。 </dd><dt><strong>VEOL</strong></dt><dd>(0, NUL) 附加的行尾字符。当设置 ICANON 时可被识别。 </dd><dt><strong>VTIME</strong></dt><dd>非 canonical 模式读时的延时，以十分之一秒为单位。 </dd><dt><strong>VEOL2</strong></dt><dd>(not in POSIX; 0, NUL) 另一个行尾字符。当设置 ICANON 时可被识别。 </dd><dt><strong>VSWTCH</strong></dt><dd>(not in POSIX; not supported under Linux; 0, NUL) 开关字符。(只为 <strong>shl</strong> 所用。) </dd><dt><strong>VSTART</strong></dt><dd>(021, DC1, Ctrl-Q) 开始字符。重新开始被 Stop 字符中止的输出。当设置 IXON 时可被识别，不再作为输入传递。 </dd><dt><strong>VSTOP</strong></dt><dd>(023, DC3, Ctrl-S) 停止字符。停止输出，直到键入 Start 字符。当设置 IXON 时可被识别，不再作为输入传递。 </dd><dt><strong>VSUSP</strong></dt><dd>(032, SUB, Ctrl-Z) 挂起字符。发送 SIGTSTP 信号。当设置 ISIG 时可被识别，不再作为输入传递。 </dd><dt><strong>VDSUSP</strong></dt><dd>(not in POSIX; not supported under Linux; 031, EM, Ctrl-Y) 延时挂起信号。当用户程序读到这个字符时，发送 SIGTSTP 信号。当设置 IEXTEN 和 ISIG，并且系统支持作业管理时可被识别，不再作为输入传递。 </dd><dt><strong>VLNEXT</strong></dt><dd>(not in POSIX; 026, SYN, Ctrl-V) 字面上的下一个。引用下一个输入字符，取消它的任何特殊含义。当设置 IEXTEN 时可被识别，不再作为输入传递。 </dd><dt><strong>VWERASE</strong></dt><dd>(not in POSIX; 027, ETB, Ctrl-W) 删除词。当设置 ICANON 和 IEXTEN 时可被识别，不再作为输入传递。 </dd><dt><strong>VREPRINT</strong></dt><dd>(not in POSIX; 022, DC2, Ctrl-R) 重新输出未读的字符。当设置 ICANON 和 IEXTEN 时可被识别，不再作为输入传递。 </dd><dt><strong>VDISCARD</strong></dt><dd>(not in POSIX; not supported under Linux; 017, SI, Ctrl-O) 开关：开始/结束丢弃未完成的输出。当设置 IEXTEN 时可被识别，不再作为输入传递。 </dd><dt><strong>VSTATUS</strong></dt><dd>(not in POSIX; not supported under Linux; status request: 024, DC4, Ctrl-T). </dd></dl>
<p>这些符号下标值是互不相同的，除了 VTIME，VMIN 的值可能分别与 VEOL，VEOF 相同。 (在 non-canonical 模式下，特殊字符的含义更改为延时含义。MIN 表示应当被读入的最小字符数。TIME 是以十分之一秒为单位的计时器。如果同时设置了它们，read 将等待直到至少读入一个字符，一旦读入 MIN 个字符或者从上次读入字符开始经过了 TIME 时间就立即返回。如果只设置了 MIN，read 在读入 MIN 个字符之前不会返回。如果只设置了 TIME，read 将在至少读入一个字符，或者计时器超时的时候立即返回。如果都没有设置，read 将立即返回，只给出当前准备好的字符。) (?) </p>
<p><strong>tcgetattr()</strong> 得到与 <em>fd</em> 指向的对象相关的参数，将它们保存于 <em>termios_p</em> 引用的 <strong>termios</strong> 结构中。函数可以从后台进程中调用；但是，终端属性可能被后来的前台进程所改变。 </p>
<p><strong>tcsetattr()</strong> 设置与终端相关的参数 (除非需要底层支持却无法满足)，使用 <em>termios_p</em> 引用的 <strong>termios</strong> 结构。<em>optional_actions</em> 指定了什么时候改变会起作用： </p>
<dl><dt><strong>TCSANOW</strong></dt><dd>改变立即发生 </dd><dt><strong>TCSADRAIN</strong></dt><dd>改变在所有写入 <em>fd</em> 的输出都被传输后生效。这个函数应当用于修改影响输出的参数时使用。 </dd><dt><strong>TCSAFLUSH</strong></dt><dd>改变在所有写入 <em>fd</em> 引用的对象的输出都被传输后生效，所有已接受但未读入的输入都在改变发生前丢弃。 </dd></dl>
<p><strong>tcsendbreak()</strong> 传送连续的 0 值比特流，持续一段时间，如果终端使用异步串行数据传输的话。如果 <em>duration</em> 是 0，它至少传输 0.25 秒，不会超过 0.5 秒。如果 <em>duration</em> 非零，它发送的时间长度由实现定义。 </p>
<p>如果终端并非使用异步串行数据传输，<strong>tcsendbreak()</strong> 什么都不做。 </p>
<p><strong>tcdrain()</strong> 等待直到所有写入 <em>fd</em> 引用的对象的输出都被传输。 </p>
<p><strong>tcflush()</strong> 丢弃要写入 引用的对象，但是尚未传输的数据，或者收到但是尚未读取的数据，取决于 <em>queue_selector</em> 的值： </p>
<dl><dt><strong>TCIFLUSH</strong></dt><dd>刷新收到的数据但是不读 </dd><dt><strong>TCOFLUSH</strong></dt><dd>刷新写入的数据但是不传送 </dd><dt><strong>TCIOFLUSH</strong></dt><dd>同时刷新收到的数据但是不读，并且刷新写入的数据但是不传送 </dd></dl>
<p><strong>tcflow()</strong> 挂起 <em>fd</em> 引用的对象上的数据传输或接收，取决于 <em>action</em> 的值： </p>
<dl><dt><strong>TCOOFF</strong></dt><dd>挂起输出 </dd><dt><strong>TCOON</strong></dt><dd>重新开始被挂起的输出 </dd><dt><strong>TCIOFF</strong></dt><dd>发送一个 STOP 字符，停止终端设备向系统传送数据 </dd><dt><strong>TCION</strong></dt><dd>发送一个 START 字符，使终端设备向系统传输数据 </dd></dl>
<p>打开一个终端设备时的默认设置是输入和输出都没有挂起。 </p>
<p>波特率函数被用来获取和设置 <strong>termios</strong> 结构中，输入和输出波特率的值。新值不会马上生效，直到成功调用了 <strong>tcsetattr()</strong> 函数。 </p>
<p>设置速度为 <strong>B0</strong> 使得 modem "挂机"。与 <strong>B38400</strong> 相应的实际比特率可以用 <strong><a href="http://localhost/cgi-bin/man/man2html?8+setserial">setserial</a></strong>(8) 调整。 </p>
<p>输入和输出波特率被保存于 <strong>termios</strong> 结构中。 </p>
<p><strong>cfmakeraw</strong> 设置终端属性如下： </p>
<pre>            termios_p-&gt;c_iflag &amp;= ~(IGNBRK|BRKINT|PARMRK|ISTRIP<br />                            |INLCR|IGNCR|ICRNL|IXON);<br />            termios_p-&gt;c_oflag &amp;= ~OPOST;<br />            termios_p-&gt;c_lflag &amp;= ~(ECHO|ECHONL|ICANON|ISIG|IEXTEN);<br />            termios_p-&gt;c_cflag &amp;= ~(CSIZE|PARENB);<br />            termios_p-&gt;c_cflag |= CS8;<br /></pre>
<p><strong>cfgetospeed()</strong> 返回 <em>termios_p</em> 指向的 <strong>termios</strong> 结构中存储的输出波特率 </p>
<p><strong>cfsetospeed()</strong> 设置 <em>termios_p</em> 指向的 <strong>termios</strong> 结构中存储的输出波特率为 <em>speed</em>。取值必须是以下常量之一： </p>
<pre><strong>        B0<br />        B50<br />        B75<br />        B110<br />        B134<br />        B150<br />        B200<br />        B300<br />        B600<br />        B1200<br />        B1800<br />        B2400<br />        B4800<br />        B9600<br />        B19200<br />        B38400<br />        B57600<br />        B115200<br />        B230400<br /></strong></pre>
<p>零值 <strong>B0</strong> 用来中断连接。如果指定了 B0，不应当再假定存在连接。通常，这样将断开连接。<strong>CBAUDEX</strong> 是一个掩码，指示高于 POSIX.1 定义的速度的那一些 (57600 及以上)。因此，<strong>B57600</strong> &amp; <strong>CBAUDEX</strong> 为非零。 </p>
<p><strong>cfgetispeed()</strong> 返回 <strong>termios</strong> 结构中存储的输入波特率。 </p>
<p><strong>cfsetispeed()</strong> 设置 <strong>termios</strong> 结构中存储的输入波特率为 <em>speed</em>。如果输入波特率被设为<em>0，实际输入波特率将等于输出波特率。</em> <a name="lbAE"></a></p>
<h4>RETURN VALUE 返回值</h4>
<p><strong>cfgetispeed()</strong> 返回 <strong>termios</strong> 结构中存储的输入波特率。 </p>
<p><strong>cfgetospeed()</strong> 返回 <strong>termios</strong> 结构中存储的输出波特率。 </p>
<p>其他函数返回： </p>
<dl><dt>0 </dt><dd>成功 </dd><dt>-1 </dt><dd>失败，并且为 <em>errno</em> 置值来指示错误。 </dd></dl>
<p>注意 <strong>tcsetattr()</strong> 返回成功，如果任何所要求的修改可以实现的话。因此，当进行多重修改时，应当在这个函数之后再次调用 <strong>tcgetattr()</strong> 来检测是否所有修改都成功实现。 </p>
<p><a name="lbAF"></a></p>
<h4>NOTES 注意</h4>
<p>Unix V7 以及很多后来的系统有一个波特率的列表，在十四个值 B0, ..., B9600 之后可以看到两个常数 EXTA, EXTB ("External A" and "External B")。很多系统将这个列表扩展为更高的波特率。 </p>
<p><strong>tcsendbreak</strong> 中非零的 <em>duration</em> 有不同的效果。SunOS 指定中断 <em>duration</em><strong>*</strong><em>N</em> 秒，其中 <em>N</em> 至少为 0.25，不高于 0.5 。Linux, AIX, DU, Tru64 发送 <em>duration</em> 微秒的 break 。FreeBSD, NetBSD, HP-UX 以及 MacOS 忽略 <em>duration</em> 的值。在 Solaris 和 Unixware 中， <strong>tcsendbreak</strong> 搭配非零的 <em>duration</em> 效果类似于 <strong>tcdrain</strong>。&nbsp; <a name="lbAG"><br /></a></p>
<p><a name="lbAG"></a></p>
<p><a name="lbAG"></a></p>
<p><a name="lbAG"></a></p>
<p><a name="lbAG"></a></p>
<p><a name="lbAG"></a></p>
<h4><a name="s3"></a></h4>
<p>所有的范例来源自 <code>miniterm.c</code>. The type ahead 暂存器被限制在 255 个字元, 就跟标准输入程序的最大字串长度相同 (<code></code> 或 <code></code>). </p>
<p>参考程序码中的注解它会解释不同输入模式的使用. 我希望这些程序码都能被了解. 标准输入程序的程序范例的注解写得最好, 其它的范例都只在不同于其它范例的地方做注解. </p>
<p>叙述不是很完整, 但可以激励你对这范例做实验, 以延生出合于你所需应用程序的最佳解. </p>
<p>别忘记要把序列埠的权限设定正确 (也就是: <code>chmod a+rw /dev/ttyS1</code>)! </p>
<h4><a name="ss3.1">3.1 标准输入程序</a></h4>
<blockquote>
<pre>#include <br />#include <br />#include <br />#include <br />#include <br /><br />/* 鲍率设定被定义在 , 这在  被引入 */<br />#define BAUDRATE B38400            <br />/* 定义正确的序列埠 */<br />#define MODEMDEVICE "/dev/ttyS1"<br />#define _POSIX_SOURCE 1 /* POSIX 系统兼容 */<br /><br />#define FALSE 0<br />#define TRUE 1<br /><br />volatile int STOP=FALSE; <br /><br />main()<br />{<br />  int fd,c, res;<br />  struct termios oldtio,newtio;<br />  char buf[255];<br />/* <br />  开启数据机装置以读取并写入而不以控制 tty 的模式<br />  因为我们不想程序在送出 CTRL-C 后就被杀掉.<br />*/<br /> fd = open(MODEMDEVICE, O_RDWR | O_NOCTTY ); <br /> if (fd &lt;0) {perror(MODEMDEVICE); exit(-1); }<br /><br /> tcgetattr(fd,&amp;oldtio); /* 储存目前的序列埠设定 */<br /> bzero(&amp;newtio, sizeof(newtio)); /* 清除结构体以放入新的序列埠设定值 */<br /><br />/* <br />  BAUDRATE: 设定 bps 的速度. 你也可以用 cfsetispeed 及 cfsetospeed 来设定.<br />  CRTSCTS : 输出资料的硬件流量控制 (只能在具完整线路的缆线下工作<br />            参考 Serial-HOWTO 第七节)<br />  CS8     : 8n1 (8 位元, 不做同位元检查,1 个终止位元)<br />  CLOCAL  : 本地连线, 不具数据机控制功能<br />  CREAD   : 致能接收字元<br />*/<br /> newtio.c_cflag = BAUDRATE | CRTSCTS | CS8 | CLOCAL | CREAD;<br /> <br />/*<br />  IGNPAR  : 忽略经同位元检查后, 错误的位元组<br />  ICRNL   : 比 CR 对应成 NL (否则当输入信号有 CR 时不会终止输入)<br />            在不然把装置设定成 raw 模式(没有其它的输入处理)<br />*/<br /> newtio.c_iflag = IGNPAR | ICRNL;<br /> <br />/*<br /> Raw 模式输出.<br />*/<br /> newtio.c_oflag = 0;<br /> <br />/*<br />  ICANON  : 致能标准输入, 使所有回应机能停用, 并不送出信号以叫用程序<br />*/<br /> newtio.c_lflag = ICANON;<br /> <br />/* <br />  初始化所有的控制特性<br />  预设值可以在 /usr/include/termios.h 找到, 在注解中也有,<br />  但我们在这不需要看它们<br />*/<br /> newtio.c_cc[VINTR]    = 0;     /* Ctrl-c */ <br /> newtio.c_cc[VQUIT]    = 0;     /* Ctrl-/ */<br /> newtio.c_cc[VERASE]   = 0;     /* del */<br /> newtio.c_cc[VKILL]    = 0;     /* @ */<br /> newtio.c_cc[VEOF]     = 4;     /* Ctrl-d */<br /> newtio.c_cc[VTIME]    = 0;     /* 不使用分割字元组的计时器 */<br /> newtio.c_cc[VMIN]     = 1;     /* 在读取到 1 个字元前先停止 */<br /> newtio.c_cc[VSWTC]    = 0;     /* '/0' */<br /> newtio.c_cc[VSTART]   = 0;     /* Ctrl-q */ <br /> newtio.c_cc[VSTOP]    = 0;     /* Ctrl-s */<br /> newtio.c_cc[VSUSP]    = 0;     /* Ctrl-z */<br /> newtio.c_cc[VEOL]     = 0;     /* '/0' */<br /> newtio.c_cc[VREPRINT] = 0;     /* Ctrl-r */<br /> newtio.c_cc[VDISCARD] = 0;     /* Ctrl-u */<br /> newtio.c_cc[VWERASE]  = 0;     /* Ctrl-w */<br /> newtio.c_cc[VLNEXT]   = 0;     /* Ctrl-v */<br /> newtio.c_cc[VEOL2]    = 0;     /* '/0' */<br /><br />/* <br />  现在清除数据机线并启动序列埠的设定<br />*/<br /> tcflush(fd, TCIFLUSH);<br /> tcsetattr(fd,TCSANOW,&amp;newtio);<br /><br />/*<br />  终端机设定完成, 现在处理输入信号<br />  在这个范例, 在一行的开始处输入 'z' 会退出此程序.<br />*/<br /> while (STOP==FALSE) {     /* 回圈会在我们发出终止的信号后跳出 */<br /> /* 即使输入超过 255 个字元, 读取的程序段还是会一直等到行终结符出现才停止.<br />    如果读到的字元组低于正确存在的字元组, 则所剩的字元会在下一次读取时取得.<br />    res 用来存放真正读到的字元组个数 */<br />    res = read(fd,buf,255); <br />    buf[res]=0;             /* 设定字串终止字元, 所以我们能用 printf */<br />    printf(":%s:%d/n", buf, res);<br />    if (buf[0]=='z') STOP=TRUE;<br /> }<br /> /* 回存旧的序列埠设定值 */<br /> tcsetattr(fd,TCSANOW,&amp;oldtio);<br />}<br /><br /></pre>
</blockquote>
<h4><a name="ss3.2">3.2 非标准输入程序</a></h4>
<p>在非标准的输入程序模式下, 输入的资料不会被组合成一行而输入后的处理功能 (清除, 杀掉, 删除, 等等.) 都不能使用. 这个模式有两个功能控制参数: <code>c_cc[VTIME]</code> 设定字元输入时间计时器, 及 <code>c_cc[VMIN]</code> 设定满足读取功能的最低字元接收个数. </p>
<p>如果 MIN &gt; 0 且 TIME = 0, MIN 设定为满足读取功能的最低字元接收个数. 由于 TIME 是 零, 所以计时器将不被使用. </p>
<p>如果 MIN = 0 且 TIME &gt; 0, TIME 将被当做逾时设定值. 满足读取功能的情况为读取到单一字元, 或者超过 TIME 所定义的时间 (t = TIME *0.1 s). 如果超过 TIME 所定义的时间, 则不会传回任何字元. </p>
<p>如果 MIN &gt; 0 且 TIME &gt; 0, TIME 将被当做一个分割字元组的计时器. 满足读取功能的条件为接收到 MIN 个数的字元, 或两个字元的间隔时间超过 TIME 所定义的值. 计时器会在每读到一个字元后重新计时, 且只会在第一个字元收到后才会启动. </p>
<p>如果 MIN = 0 且 TIME = 0, 读取功能就马上被满足. 目前所存在的字元组个数, 或者 将回传的字元组个数. 根据 Antonino (参考 贡献) 所说, 你可以用 <code>fcntl(fd, F_SETFL, FNDELAY);</code> 在读取前得到相同的结果. </p>
<p>藉由修改 <code>newtio.c_cc[VTIME]</code> 及 <code>newtio.c_cc[VMIN]</code> 上述的模式就可以测试了. </p>
<blockquote>
<pre>#include <br />#include <br />#include <br />#include <br />#include <br /><br />#define BAUDRATE B38400<br />#define MODEMDEVICE "/dev/ttyS1"<br />#define _POSIX_SOURCE 1 /* POSIX 系统兼容 */<br />#define FALSE 0<br />#define TRUE 1<br /><br />volatile int STOP=FALSE; <br /><br />main()<br />{<br />  int fd,c, res;<br />  struct termios oldtio,newtio;<br />  char buf[255];<br /><br /> fd = open(MODEMDEVICE, O_RDWR | O_NOCTTY ); <br /> if (fd &lt;0) {perror(MODEMDEVICE); exit(-1); }<br /><br /> tcgetattr(fd,&amp;oldtio); /* 储存目前的序列埠设定 */<br /><br /> bzero(&amp;newtio, sizeof(newtio));<br /> newtio.c_cflag = BAUDRATE | CRTSCTS | CS8 | CLOCAL | CREAD;<br /> newtio.c_iflag = IGNPAR;<br /> newtio.c_oflag = 0;<br /><br /> /* 设定输入模式 (非标准型, 不回应,...) */<br /> newtio.c_lflag = 0;<br /> <br /> newtio.c_cc[VTIME]    = 0;   /* 不使用分割字元组计时器 */<br /> newtio.c_cc[VMIN]     = 5;   /* 在读取到 5 个字元前先停止 */<br /><br /> tcflush(fd, TCIFLUSH);<br /> tcsetattr(fd,TCSANOW,&amp;newtio);<br /><br /><br /> while (STOP==FALSE) {       /* 输入回圈 */<br />   res = read(fd,buf,255);   /* 在输入 5 个字元后即返回 */<br />   buf[res]=0;               /* 所以我们能用 printf... */<br />   printf(":%s:%d/n", buf, res);<br />   if (buf[0]=='z') STOP=TRUE;<br /> }<br /> tcsetattr(fd,TCSANOW,&amp;oldtio);<br />}<br /></pre>
</blockquote>
<h4><a name="ss3.3">3.3 非同步式输入</a></h4>
<blockquote>
<pre>#include <br />#include <br />#include <br />#include <br />#include <br />#include <br /><br />#define BAUDRATE B38400<br />#define MODEMDEVICE "/dev/ttyS1"<br />#define _POSIX_SOURCE 1 /* POSIX 系统兼容 */<br />#define FALSE 0<br />#define TRUE 1<br /><br />volatile int STOP=FALSE; <br /><br />void signal_handler_IO (int status);   /* 定义信号处理程序 */<br />int wait_flag=TRUE;                    /* 没收到信号的话就会是 TRUE */<br /><br />main()<br />{<br />  int fd,c, res;<br />  struct termios oldtio,newtio;<br />  struct sigaction saio;           /* definition of signal action */<br />  char buf[255];<br /><br />  /* 开启装置为 non-blocking (读取功能会马上结束返回) */<br />  fd = open(MODEMDEVICE, O_RDWR | O_NOCTTY | O_NONBLOCK);<br />  if (fd &lt;0) {perror(MODEMDEVICE); exit(-1); }<br /><br />  /* 在使装置非同步化前, 安装信号处理程序 */<br />  saio.sa_handler = signal_handler_IO;<br />  saio.sa_mask = 0;<br />  saio.sa_flags = 0;<br />  saio.sa_restorer = NULL;<br />  sigaction(SIGIO,&amp;saio,NULL);<br />  <br />  /* 允许行程去接收 SIGIO 信号*/<br />  fcntl(fd, F_SETOWN, getpid());<br />  /* 使文档ake the file descriptor 非同步 (使用手册上说只有 O_APPEND 及<br />  O_NONBLOCK, 而 F_SETFL 也可以用...) */<br />  fcntl(fd, F_SETFL, FASYNC);<br /><br />  tcgetattr(fd,&amp;oldtio); /* 储存目前的序列埠设定值 */<br />  /* 设定新的序列埠为标准输入程序 */<br />  newtio.c_cflag = BAUDRATE | CRTSCTS | CS8 | CLOCAL | CREAD;<br />  newtio.c_iflag = IGNPAR | ICRNL;<br />  newtio.c_oflag = 0;<br />  newtio.c_lflag = ICANON;<br />  newtio.c_cc[VMIN]=1;<br />  newtio.c_cc[VTIME]=0;<br />  tcflush(fd, TCIFLUSH);<br />  tcsetattr(fd,TCSANOW,&amp;newtio);<br /> <br />  /* 等待输入信号的回圈. 很多有用的事我们将在这做 */ <br />  while (STOP==FALSE) {<br />    printf("./n");usleep(100000);<br />    /* 在收到 SIGIO 后, wait_flag = FALSE, 输入信号存在则可以被读取 */<br />    if (wait_flag==FALSE) { <br />      res = read(fd,buf,255);<br />      buf[res]=0;<br />      printf(":%s:%d/n", buf, res);<br />      if (res==1) STOP=TRUE; /* 如果只输入 CR 则停止回圈 */<br />      wait_flag = TRUE;      /* 等待新的输入信号 */<br />    }<br />  }<br />  /* 回存旧的序列埠设定值 */<br />  tcsetattr(fd,TCSANOW,&amp;oldtio);<br />}<br /><br />/***************************************************************************<br />* 信号处理程序. 设定 wait_flag 为 FALSE, 以使上述的回圈能接收字元          *<br />***************************************************************************/<br /><br />void signal_handler_IO (int status)<br />{<br />  printf("received SIGIO signal./n");<br />  wait_flag = FALSE;<br />}<br /></pre>
</blockquote>
<h4><a name="ss3.4">3.4 等待来自多个信号来源的输入</a></h4>
<p>这一段很短. 它只能被拿来当成写程序时的提示, 故范例程序也很简短. 但这个范例不只能用在序列埠上, 还可以用在被当成文档来使用的装置上. </p>
<p>select 呼叫及伴随它所引发的巨集共用 <code>fd_set</code>. <code>fd_set</code> 则是一个位元阵列, 而其中每一个位元代表一个有效的文档叙述结构. <code>select</code> 呼叫接受一个有效的文档叙述结构并传回 <code>fd_set</code> 位元阵列, 而该位元阵列中若有某一个位元为 1, 就表示相对映的文档叙述结构的文档发生了输入, 输出或有例外事件. 而这些巨集提供了所有处理 <code>fd_set</code> 的功能. 亦可参考手册 select(2). </p>
<blockquote>
<pre>#include <br />#include <br />#include <br /><br />main()<br />{<br />   int    fd1, fd2;  /* 输入源 1 及 2 */<br />   fd_set readfs;    /* 文档叙述结构设定 */<br />   int    maxfd;     /* 最大可用的文档叙述结构 */<br />   int    loop=1;    /* 回圈在 TRUE 时成立 */ <br /><br />   /* open_input_source 开启一个装置, 正确的设定好序列埠,<br />      并回传回此文档叙述结构体 */<br />   fd1 = open_input_source("/dev/ttyS1");   /* COM2 */<br />   if (fd1&lt;0) exit(0);<br />   fd2 = open_input_source("/dev/ttyS2");   /* COM3 */<br />   if (fd2&lt;0) exit(0);<br />   maxfd = MAX (fd1, fd2)+1;  /* 测试最大位元输入 (fd) */<br /><br />   /* 输入回圈 */<br />   while (loop) {<br />     FD_SET(fd1, &amp;readfs);  /* 测试输入源 1 */<br />     FD_SET(fd2, &amp;readfs);  /* 测试输入源 2 */<br />     /* block until input becomes available */<br />     select(maxfd, &amp;readfs, NULL, NULL, NULL);<br />     if (FD_ISSET(fd1))         /* 如果输入源 1 有信号 */<br />       handle_input_from_source1();<br />     if (FD_ISSET(fd2))         /* 如果输入源 2 有信号 */<br />       handle_input_from_source2();<br />   }<br /><br />}   <br /></pre>
</blockquote>
<p>这个范例程序在等待输入信号出现前, 不能确定它会停顿下来. 如果你需要在输入时加入逾时功能, 只需把 select 呼叫换成: </p>
<blockquote>
<pre>int res;<br />struct timeval Timeout;<br /><br />/* 设定输入回圈的逾时值 */<br />Timeout.tv_usec = 0;  /* 毫秒 */<br />Timeout.tv_sec  = 1;  /* 秒 */<br />res = select(maxfd, &amp;readfs, NULL, NULL, &amp;Timeout);<br />if (res==0)<br />/* 文档叙述结构数在 input = 0 时, 会发生输入逾时. */ <br /></pre>
</blockquote>
<p>这个程序会在 1 秒钟后逾时. 如果超过时间, select 会传回 0, 但是应该留意 <code>Timeout</code> 的时间递减是由 <code>select</code> 所等待输入信号的时间为基准. 如果逾时的值是 0, select 会马上结束返回.</p>
<p>Linux 环境下使用RS-232接口 <br />RS是英文 "推荐标准"的缩写 <br />232为标识号 <br />RS-485 <br />串口通信表示计算机一次传送一个位的数据， <br />当使用串行通信时，每个字的数据是一个位一个位的传输或接收的， <br />每个位不是高电平，就是低电平. <br />串行通信的速率通常是使用"位/每秒"的方式来表示的，即波特率。 <br />全双工--计算机可以同时收发数据, <br />它有两个独立的数据通道，一个输入，一个输出， <br />半双工意味着计算机不能同时收发信息， <br />只能有一人通道进行通信. <br />流控: <br />&nbsp;&nbsp;&nbsp; 通常，当数据在两个串行接口之间进行传输时需要对其进行控制. <br />&nbsp;&nbsp;&nbsp; 这通常依赖于串行通信连接的各种规定， <br />&nbsp;&nbsp;&nbsp; 对异步数据传输的控制有两种方法. <br />&nbsp;&nbsp;&nbsp; 一种叫：&ldquo;软件&rdquo;流控 。 <br />&nbsp;&nbsp;&nbsp; 一种叫： &ldquo;硬件"流控 。 <br />串口设备： <br />打开一个串行口 <br />#include <br />#include <br />#include <br />#include &nbsp; // 文件控制定义 <br />#include <br />#include &nbsp; //POSIX终端控制定义 <br />/* <br />* open_port() --打开串行口 <br />* <br />* 成功的话，返回文件描述符，错误则返回 -1. <br />*/ <br />int&nbsp; open_port(void) <br />{ <br />&nbsp;&nbsp;&nbsp; int fd; <br />&nbsp;&nbsp;&nbsp; fd=open("/dev/ttyS0",O_RDWR|O_NOCTTY|O_NDELAY); <br />&nbsp;&nbsp;&nbsp; if (fd == -1) <br />&nbsp;&nbsp;&nbsp; { <br />&nbsp;&nbsp;&nbsp; /*无法打开串口*/ <br />&nbsp;&nbsp;&nbsp; perror("open_port : Unable to open /dev/ttyS0"); <br />&nbsp;&nbsp;&nbsp; } <br />&nbsp;&nbsp;&nbsp; else <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fcntl(fd,F_SETFL,0); <br />&nbsp;&nbsp;&nbsp; return (fd); <br />} <br />//O_NOCTTY 标志 ，该程序不想成为此端口的&ldquo;控制终端"。 <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 如果没有强调这一点， <br />//O_NDELAY标志 , 标志告诉Linux ,该程序并不关注DCD信叼线所处的状态, <br />即不管另外一端的设备是在运行还是被挂起。如果没有指定该标志，那么程序就会被设置睡 <br />眠状态， <br />（2）向端口写数据 <br />&nbsp;&nbsp;&nbsp; 向端口写数据是很容易的，只要使用write()系统调用就可以了。 <br />&nbsp;&nbsp;&nbsp; 例如: <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; n=write(fd,"ATZ/r",4); <br />&nbsp;&nbsp;&nbsp; if (n&lt;0) <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fputs("write() of 4 bytes failed!/n",stderr); <br />&nbsp;&nbsp;&nbsp; write函数返回发送数据的个数，如果出现错误，则返回 -1。 <br />(3) 读端口数据 <br />&nbsp;&nbsp;&nbsp; 从端口读数据则需要些技巧。如果在原始数据的模式下对端口进行操作, <br />&nbsp;&nbsp;&nbsp; read()系统调用将返回串行口输入缓冲区中所有的字符数据，不管有多少， <br />&nbsp;&nbsp;&nbsp; 如果没有数据，那么该调用将被阻塞.处于等待状态，直到有字符输入， <br />&nbsp;&nbsp;&nbsp; 或者到了规定的时限和出现错误为止, <br />&nbsp;&nbsp;&nbsp; 通过以下方法，能使read函数立即返回。 <br />&nbsp;&nbsp;&nbsp; fcntl(fd,F_SETFL,FNDELAY); <br />&nbsp;&nbsp;&nbsp; FNDELAY 函数使read函数在端口没月字符存在的情况下，立刻返回0, <br />&nbsp;&nbsp;&nbsp; 如果要恢复正常(阻塞)状态,可以调用fcntl()函数，不要FNDELAY参数, <br />&nbsp;&nbsp;&nbsp; 如下所示： <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fcntl(Fd,F_SETFL,0); <br />&nbsp;&nbsp;&nbsp; 在使用O_NDELAY参数打开串行口后，同样与使用了该函数调用。 <br />&nbsp;&nbsp;&nbsp; fcntl(fd,F_SETFL,0); <br />POSIX终端接口 <br />&nbsp;&nbsp;&nbsp; 串口，波特率，字符大小等, <br />&nbsp;&nbsp;&nbsp; POSIX函数是 tcgetattr()和tcsetattr() <br />&nbsp;&nbsp;&nbsp; 获取和设置终端的属性， <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 可以提供 structrure termios的指针 <br /><a href="http://hi.csdn.net/attachment/201009/26/0_1285494194hbP0.gif"><img style="border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px" title="ScrollR" src="http://hi.csdn.net/attachment/201009/26/0_1285494195fFgL.gif" border="0" alt="ScrollR" width="23" height="19" /></a></p></div><div id="MySignature"></div>
<script type="text/javascript">
var isLogined = false;
var cb_blogId = 104085;
var cb_entryId = 2282116;
var cb_blogApp = currentBlogApp;
var cb_blogUserGuid = "fd55889e-74e6-df11-ac81-842b2b196315";
var cb_entryCreatedDate = '2010/9/26 9:43:00';
var enableGoogleAd = true;
var googletag = googletag || {};
googletag.cmd = googletag.cmd || [];
</script>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
<script type="text/javascript">
    //SyntaxHighlighter.config.strings.expandSource = '<span><img src="http://static.cnblogs.com/images/expand-code.gif" alt="" class="expand-code-icon"/>View Code</span>';
    $(function () {             
        fixPostBodyFormat();
        loadAdUnderPost();
        loadBlogSignature();
        LoadPostInfoBlock(cb_blogId, cb_entryId, cb_blogApp, cb_blogUserGuid);
        GetPrevNextPost(cb_entryId, cb_blogId, cb_entryCreatedDate);        
        GetHistoryToday(cb_blogId, cb_blogApp, cb_entryCreatedDate);        
    });
</script>
	</div>
	
	<div class="postfoot">
		posted on <span id="post-date">2010-09-26 09:43</span> <a href='http://www.cnblogs.com/sunyubo/'>SunBo</a> 阅读(2160) 评论(<span id="post-comment-count">0</span>)  <a href ="http://www.cnblogs.com/sunyubo/admin/EditPosts.aspx?postid=2282116" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(2282116);return false;">收藏</a>
	</div>
</div>
<img src ="http://www.cnblogs.com/sunyubo/aggbug/2282116.html?type=1&amp;webview=1" width="1" height="1" alt=""/>

<div id="blog-comments-placeholder"></div><script type="text/javascript">var commentManager = new blogCommentManager();commentManager.loadComments();</script>
<div id="comment_form" class="commentform">
<div id="divCommentShow"></div>
<div id="comment_nav"><span id="span_refresh_tips"></span><a href="javascript:void(0);" id="lnk_RefreshComments" onclick="return RefreshCommentList();">刷新评论</a><a href="#" onclick="return RefreshPage();">刷新页面</a><a href="#top">返回顶部</a></div>
<div id="comment_form_container"></div>

<script type="text/javascript">
    if (typeof commentManager === 'undefined') {
        commentManager = new blogCommentManager();
    }
    commentManager.loadCommentForm();   
</script>

<div class="ad_text_commentbox" id="ad_text_under_commentbox"></div>
<div id="site_nav_under"><a href="http://www.cnblogs.com/" target="_blank" title="程序员的网上家园">博客园首页</a><a href="http://q.cnblogs.com/" target="_blank" title="程序员问答社区">博问</a><a href="http://news.cnblogs.com/" target="_blank" title="IT新闻">新闻</a><a href="http://home.cnblogs.com/ing/" target="_blank">闪存</a><a href="http://job.cnblogs.com/" target="_blank">程序员招聘</a><a href="http://kb.cnblogs.com/" target="_blank">知识库</a></div>
<div id="ad_under_post_holder"></div>
<div id="HistoryToday" class="c_ad_block"></div>
</div>





</tr>
</table>

<p id="footer">
	Copyright @
	SunBo<BR>
	Powered by:
	<a href="http://scottwater.com/blog" target=_blank>.Text</a> and 
	<a href="http://asp.net" target=_blank>ASP.NET</a>
	<br>
	Theme by: <a href="http://www.DotNetMonster.com" target=_blank>.NET Monster</a>
</p>


<script type="text/javascript" src="http://common.cnblogs.com/script/google-analytics.js"></script>
</body>
</html>

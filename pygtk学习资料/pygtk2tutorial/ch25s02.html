<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>25.2. Separate your data model from your interface</title><link rel="stylesheet" type="text/css" href="style.css"><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"><link rel="home" href="index.html" title="PyGTK 2.0 Tutorial"><link rel="up" href="ch-TipsForWritingPyGTKApplications.html" title="Chapter 25. Tips For Writing PyGTK Applications"><link rel="prev" href="ch-TipsForWritingPyGTKApplications.html" title="Chapter 25. Tips For Writing PyGTK Applications"><link rel="next" href="ch25s03.html" title="25.3. How to Separate Callback Methods From Signal Handlers"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">25.2. Separate your data model from your interface</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch-TipsForWritingPyGTKApplications.html">Prev</a> </td><th width="60%" align="center">Chapter 25. Tips For Writing PyGTK Applications</th><td width="20%" align="right"> <a accesskey="n" href="ch25s03.html">Next</a></td></tr></table><hr></div><div class="sect1" title="25.2. Separate your data model from your interface"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp3594168"></a>25.2. Separate your data model from your interface</h2></div></div></div><p>Python's flexible, duck-typed object system lowers the cost of
architectural options that are more difficult to exercise in more
rigid languages (yes, we <span class="emphasis"><em>are</em></span> thinking of C++).
One of these is carefully separating your data model (the classes and
data structures that represent whatever state your application is
designed to manipulate) from your controller (the classes that
implement your user interface.</p><p>In Python, a design pattern that frequently applies is to have
one master editor/controller class that encapsulates your user interface
(with, possibly, small helper classes for stateful widgets) and one
master model class that encapsulates your application state (probably
with some members that are themselves instances of small data-representation
classes).  The controller calls methods in the model to do all its
data manipulation; the model delegates screen-painting and
input-event processing to the controller.</p><p>Narrowing the interface between model and controller makes it
easier to avoid being locked into early decisions about either part
by adhesions with the other one.  It also makes downstream 
maintainance and bug diagnosis easier.</p></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch-TipsForWritingPyGTKApplications.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="ch-TipsForWritingPyGTKApplications.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="ch25s03.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter 25. Tips For Writing PyGTK Applications </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 25.3. How to Separate Callback Methods From Signal Handlers</td></tr></table></div></body></html>

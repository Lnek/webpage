               <!DOCTYPE html><html  id="customDoc"><!--STATUS OK--> <head> <meta http-equiv=Content-Type content="text/html; charset=utf-8"> <title> Linux的TCP/IP协议栈学习（转）_407433544的空间_百度空间</title> <link rel="shortcut icon" href="http://hi.bdimg.com/static/qbase/img/mod/16_favicon.ico?v=116ba471.ico" type=image/x-icon>   <meta name=keywords content="Linux的TCP/IP协议栈学习（转）,网络"> <meta name=description content="Android平台底层软件开发技术交流,Linux的TCP/IP协议栈学习（转）"><script>window.wpo={start:new Date*1,pid:109,page:'qing'}</script><!--[if IE]><script type="text/javascript">(function(){var a="abbr,article,aside,audio,canvas,datalist,details,dialog,eventsource,figure,footer,header,hgroup,mark,menu,meter,nav,output,progress,section,time,video".split(","),b=a.length;while(b--)document.createElement(a[b])})();</script><![endif]--><script>window.qDomain={"qing":"http://hi.baidu.com","static":"http://hi.bdimg.com","passport":"https://passport.baidu.com","portrait":"http://tx.bdimg.com","hiup":"http://hiup.baidu.com","photo":"http://hiphotos.baidu.com","message":"http://msg.baidu.com","friend":"http://frd.baidu.com","mp3":"http://mp3.baidu.com","ting":"http://ting.baidu.com","image":"http://img.baidu.com","qup":"http://upload.hi.baidu.com","www":"http://www.baidu.com"};window.qUserInfo={"userName":"407433544","nickname":"407433544","portrait":"4cff3430373433333534347c02","qingUrl":"\/407433544","spaceName":"407433544的空间","right":"0","avatarStatus":"1","flagNeedInvite":"0","flagNotInvited":"0","version":"2"};window.qVisitorInfo={"userName":"","nickname":"","portrait":"","isHost": false,"isRandUrl": false,"isForceMoved": false,"loginStatus":"not_login","isOldUser":0,"qingUrl":"","right":"0","version":"0"};window.qPageInfo={"pageUrl":"http:\/\/hi.baidu.com\/407433544\/item\/67e9404324d910a961d7b99e","referUrl":"http:\/\/cn.bing.com\/search?q=eth_type_trans&qs=n&form=QBRE&pq=eth_type_trans&sc=8-10&sp=-1&sk="};window.qUserAvatar={size20:"http://hiphotos.baidu.com/space/scrop=20;q=100/sign=dfc776c2252dd42a5b5746f473066985/e824b899a9014c0866eb0b0e0a7b02087af4f44c.jpg",size40:"http://hiphotos.baidu.com/space/scrop=40;q=100/sign=2dc0c2b12834349b705829dab9d721fe/e824b899a9014c0866eb0b0e0a7b02087af4f44c.jpg",size65:"http://hiphotos.baidu.com/space/scrop=65;q=100/sign=20d92200033b5bb5ba8967a146eee30c/e824b899a9014c0866eb0b0e0a7b02087af4f44c.jpg",size110:"http://hiphotos.baidu.com/space/scrop=110;q=100/sign=c4527a1a800a19d8cf5dc35a43c7b3ba/e824b899a9014c0866eb0b0e0a7b02087af4f44c.jpg",size160:"http://hiphotos.baidu.com/space/scrop=160;q=100/sign=c4527a1a800a19d8cf5dc35a43c7b3bd/e824b899a9014c0866eb0b0e0a7b02087af4f44c.jpg"};window.qVisitorAvatar={size20:"",size40:"",size65:"",size110:"",size160:""};window.qBdsToken="the fisrt two args should be string type:0,1!";window.qErrorInfo={"no":"0","msg":""};window.qServerInfo={"timeStamp":"1368694900"};window.qLongPolling={"url":"http:\/\/m.hi.baidu.com\/i\/msg\/listen"}</script><!--[if (lt IE 8.0)]><link href="http://hi.bdimg.com/static/qbase/css/qbase.css?v=215fffd7.css" type=text/css rel=stylesheet><![endif]--><!--[if (!IE)|(gte IE 8.0)]><!--><link href="http://hi.bdimg.com/static/qbase/css/qbase_datauri.css?v=e77db79b.css" type=text/css rel=stylesheet><!--<![endif]-->     <!--[if (lt IE 8.0)]><link rel=stylesheet type=text/css href="http://hi.bdimg.com/static/qcomment/css/qcomment.css?v=5ba753ab.css"><![endif]--><!--[if (!IE)|(gte IE 8.0)]><!--><link rel=stylesheet type=text/css href="http://hi.bdimg.com/static/qcomment/css/qcomment_datauri.css?v=a90beb01.css"><!--<![endif]--><link rel=stylesheet type=text/css href="http://hi.bdimg.com/static/qhome/css/common/mod_userInfo.css?v=86bf4259.css">   <!--[if (lt IE 8.0)]><link type=text/css rel=stylesheet href="http://hi.bdimg.com/static/qhome/css/detail/20001/detail.css?v=635ae796.css"><![endif]--><!--[if (!IE)|(gte IE 8.0)]><!--><link type=text/css rel=stylesheet href="http://hi.bdimg.com/static/qhome/css/detail/20001/detail_datauri.css?v=0f094a12.css"><!--<![endif]-->    <link rel=stylesheet type=text/css href="http://hi.bdimg.com/static/qpublish/css/editor/shCoreDefault.css?v=79e715f0.css">     <script src="http://hi.bdimg.com/static/qbase/js/qing/qing.js?v=058da7b0.js"></script>  <script>
    /*最终页页面变量*/ 
    window.detailPage = {
        threadId : "67e9404324d910a961d7b99e",
        blogTitle: "Linux的TCP\/IP协议栈学习（转）" || "无标题",
        contentType : "text",
        originAuthorName : "",
        originPortrait : "",
        originThreadId : ""
    }; 
    </script><script>wpo.head=new Date*1;</script> </head> <body>  <header class=mod-topbar id=modTopbar><iframe class=mod-topbar-bgframe></iframe><div class=mod-topbar-pseudo-real><div class="wrapper-box clearfix"><div class=left-box><a href="http://hi.baidu.com" class=logo-box><span id=baiduSpaceLogo class=q-logo></span></a></div> <div class=center-box><ul class=q-menubox>  <li class="q-menuitem q-newicon"> <a href=http://xiangce.baidu.com target=_blank>相册</a>  <li class="q-menuitem " id=qMenuRecommend><a href="http://hi.baidu.com/index/">广场</a></ul></div>  <div class=right-box><ul class=q-navbox><li class=q-navitem><a href="http://hi.baidu.com/go/login" class=q-goto-login>登录</a><li class="q-navitem q-nav-sp"><span></span><li class=q-navitem><a href="http://hi.baidu.com/go/reg?pmfrom=qingtop">注册</a> </ul><div class="right mod-qhome-follow-box"><a href="#" class="follow-btn a-btn-follow qing-stat-nsclick" data-nsclick=20121012follow_hdbtnaddcare>关注此空间</a></div> </div> </div></div></header>  <section class=mod-page-body> <div class="mod-page-main wordwrap clearfix">  <div class=x-page-container>    <section class="mod-topspaceinfo mod-cs-header"><div class=head-topbar></div><div class=container><h1><a class="space-name cs-header-spacename" href="/407433544">407433544的空间</a></h1><p class="space-description cs-header-spacesummary">Android平台底层软件开发技术交流</p></div><div class=head-footer></div></section>   <div class=mod-blogpage-wraper> <div class="blog-bg-main-repeat hide"></div>  <div class="grid-80 mod-blogpage"> <div class="blog-bg-main hide"></div>    <div class="mod-text-content mod-post-content mod-cs-contentblock"> <div class=cs-contentblock-bg></div>   <div class="content-head clearfix">  <div class=content-other-info>  <span>2011-10-28 13:50</span>  </div>   <h2 class="title content-title">Linux的TCP/IP协议栈学习（转）</h2>  </div>  <div id=content class="content mod-cs-content text-content clearfix"> <p>转自：<a href="http://blog.goodusahost.com/archives/2392.html" target="_blank">http://blog.goodusahost.com/archives/2392.html</a></p><p>1 从init/main.c的start_kernel函数说起。在这个函数里面调用kernel_thread启动了init进程，这个进程对应的函数是同一个文件里面的init函数，在init函数里面调用了一个叫do_basic_setup的在同一个文件里面的函数，这个函数调用了net/socket.c里面的sock_init函数，这个函数就是TCP/IP协议栈，也包括ipx等的入口。<br /><br />首先sock_init函数里面有很多ifdef这样的东东，我觉得对于一个普通的主机来说，这些都不会配置的，它们包括：SLAB_SKB,CONFIG_WAN_ROUTER,CONFIG_FIREWALL,CONFIG_RTNETLINK, CONFIG_NETLINK_DEV不过说实话除了CONFIG_WAN_ROUTER和CONFIG_FIREWALL可以看出来是什么意思以外，其它的我都是因为没有见过所以认为不会配置的。<br /> 去掉了这些编译选项以后就剩下这样的代码：<br /> for (i = 0; i &lt; NPROTO; i++)<br /> net_families = NULL;<br /> sk_init();<br /> proto_init();<br /><br />其中net_families在include/linux/net.h里面定义，是这样的：<br /> struct net_proto_family<br /> {<br />int family;<br />int (*create)(struct socket *sock, int protocol);<br /> /* These are counters for the number of different methods of<br /> each we support */<br />short authentication;<br />short encryption;<br />short encrypt_net;<br /> };<br /> 其中有用的只有前两项，那个create的callback函数是每个协议，例如AF_INET等初始化上层协议如TCP/ICMP协议需要的，以后还会遇到的，这里先放着把sk_init函数在net/core/sock.c里面，没什么说的..<br /> struct sock *sk_alloc(int family, int priority, int zero_it)<br /> {<br /> struct sock *sk = kmem_cache_alloc(sk_cachep, priority);<br />if(sk) {<br /> if (zero_it)<br /> memset(sk, 0, sizeof(struct sock));<br /> sk-&gt;family = family;<br /> }<br /> return sk;<br /> }<br /><br />proto_init函数在同一个文件里面：<br /> void __init proto_init(void)<br /> {<br /> extern struct net_proto protocols[];<br /> struct net_proto *pro;<br /> pro = protocols;<br /> while (pro-&gt;name != NULL)<br /> {<br /> (*pro-&gt;init_func)(pro);<br /> pro++;<br /> }<br /> }<br /><br />struct net_proto在include/linux/net.h里面是这样的：<br /> struct net_proto<br /> {<br /> const char *name; /* Protocol name */<br /> void (*init_func)(struct net_proto *); /* Bootstrap */<br /> };<br /> 这个protocols的数组是在net/protocols.c里面定义的，包含了一堆的协议初始化结构体，其中我只注意两个：AF_INET和AF_PACKET它们的初始化函数分别是inet_proto_init和packet_proto_init<br /><br />2 首先看PACKET协议，首先我们假定PACKET协议是编译在核心里面的，而不是一个MODULE，这样得到packet_proto_init函数在net/packet/af_packet.c<br /><br />里面是这样的： <br /><br />void __init packet_proto_init(struct net_proto *pro) <br /><br />{ <br /> sock_register(&amp; packet_family_ops);<br /> register_netdevice_notifier(&amp; packet_netdev_notifier);<br /> } <br /><br />其中sock_register函数在net/socket.c里面，就是简单的 设置前面说的net_families数组中间对应的值：<br /> int sock_register(struct net_proto_family *ops) <br /> { <br /> if (ops-&gt;family &gt;= NPROTO) { <br /><br />printk(KERN_CRIT “protocol %d &gt;= NPROTO(%d)\n”, ops-&gt;family, NPROTO); <br /> return -ENOBUFS; <br /> } <br /><br />net_families[ops-&gt;family]=ops;<br /><br />return 0; <br /> } <br /><br />这里要说明的是 packet_netdev_notifier是一个struct notifier_block类型，这个struct是在include/linux/notifier.h里面的：<br /><br />struct notifier_block <br /> { <br /> int (*notifier_call)(struct notifier_block *self, unsigned long, void *); <br /><br />struct notifier_block *next; <br /> int priority; <br /> }; <br /><br />而register_netdevice_notifier函数在net/core/dev.c里面，是这样的： <br /> int register_netdevice_notifier(struct notifier_block *nb) <br /> { <br /> return notifier_chain_register(&amp;netdev_chain, nb); <br /> } <br /><br />而 notifier_chain_register函数在include/linux/notifier.h里面，是这样的: <br /><br />extern __inline__ int notifier_chain_register(struct notifier_block **list, struct notifier_block *n)<br /> { <br /><br />while(*list) <br /> { <br /> if(n-&gt;priority &gt; (*list)-&gt;priority) <br /> break; <br /><br />list= &amp;((*list)-&gt;next); <br /> } <br /><br />n-&gt;next = *list; <br /><br />*list=n; <br /><br />return 0; <br /> } <br /><br />显然就是根据每个block的优先级把这个block排列在一个block的链表里面，在notifier_chain_register函数里面我们可以发现这个链表是netdev_chain。实际上这个链表的作用就是在每个interface打开，关闭<br /> 状态改变或者外界调用相应的ioctl的时候通知这个链表上面的所有相关的设备，而每一个协议都调用register_netdevice_notifier注册了一个netdev_notifier的结构体，这样就可以在interface改变的时候得到通知了(通过调用每个notifier_call函数)。<br /><br />下面来看 inet_proto_init函数，这个函数在net/ipv4/af_inet.c中间，里面也有很多ifdef的编译选项，假定下面几个是没有定义的：<br /><br />CONFIG_NET_IPIP，CONFIG_NET_IPGRE，CONFIG_IP_FIREWALL，<br /> CONFIG_IP_MASQUERADE，CONFIG_IP_MROUTE <br /><br />假定下面几个是定义了的： <br /> CONFIG_INET_RARP,CONFIG_PROC_FS <br /> 下面是整理后的代码： <br /><br />(void) sock_register(&amp;inet_family_ops); <br /> for(p = inet_protocol_base; p != NULL;) { <br /><br />struct inet_protocol *tmp=(struct inet_protocol *)p-&gt;next; <br /> inet_add_protocol(p); <br /><br />printk(“%s%s”,p-&gt;name,tmp?”, “:”\n”); <br /> p = tmp; <br /> } <br /><br />arp_init(); <br /> ip_init(); <br /> tcp_v4_init(&amp;inet_family_ops); <br /> tcp_init(); <br /><br />icmp_init(&amp;inet_family_ops); <br /> rarp_ioctl_hook = rarp_ioctl; <br /><br />proc_net_register(&amp;proc_net_rarp); <br /> proc_net_register(&amp;proc_net_raw); <br /> proc_net_register(&amp;proc_net_snmp); <br /><br />proc_net_register(&amp;proc_net_netstat); <br /> proc_net_register(&amp;proc_net_sockstat); <br /> proc_net_register(&amp;proc_net_tcp); <br /> proc_net_register(&amp;proc_net_udp);<br /><br />其中的sock_register函数的作用已经在前面说了，现在来看看struct inet_protocol和inet_add_protocol函数。前面的结构体是在include/net/protocol.h里面：<br /> struct inet_protocol <br />{<br /> int (*handler)(struct sk_buff *skb, unsigned short len);<br /> void (*err_handler)(struct sk_buff *skb, unsigned char *dp, int len);<br /> struct inet_protocol *next;<br /> unsigned char protocol;<br /> unsigned char copy:1;<br /> void *data;<br /> const char *name;<br /> };<br /> 第一个函数是用来接收数据的callback函数，第二个是错误处理函数，<br /> 其它的copy是用来协议共享的，这个以后再说，data当然就是这个结构体的私有数据了。<br /><br />inet_add_protocol函数是在net/ipv4/protocol.c里面的： <br /> void inet_add_protocol(struct inet_protocol *prot)<br /> {<br /> unsigned char hash;<br /> struct inet_protocol *p2;<br /><br />hash = prot-&gt;protocol &amp; (MAX_INET_PROTOS – 1);<br /> prot -&gt;next = inet_protos[hash];<br />inet_protos[hash] = prot;<br />prot-&gt;copy = 0;<br /><br /> p2 = (struct inet_protocol *) prot-&gt;next;<br /> while(p2 != NULL) <br /> {<br /> if (p2-&gt;protocol == prot-&gt;protocol) <br /> {<br />prot-&gt;copy = 1;<br /> break;<br /> }<br /> p2 = (struct inet_protocol *) p2-&gt;next;<br /> }<br /> }<br /> 显然这个函数就是作乐一个hash表，然后每个hash表项都是一个链表头，然后通过这个hash表加链表的方式访问每个协议结构体。在这里你也见到了copy成员的用法了把。<br /><br />arp_init函数是在net/ipv4/arp.c里面的(假定没有定义CONFIG_SYSCTL)：<br /><br />neigh_table_init(&amp;arp_tbl); <br />dev_add_pack(&amp;arp_packet_type);<br /> proc_net_register(&amp;proc_net_arp);<br /><br />不知道是不是有人眼睛一亮啊，呵呵，看到了dev_add_pack函数。 <br /> 还是一步步来把。<br /> neigh_table_init函数在net/core/neighbour.c中间：<br /> void neigh_table_init(struct neigh_table *tbl)<br /> {<br /> unsigned long now = jiffies;<br /><br /> tbl-&gt;parms.reachable_time = neigh_rand_reach_time(tbl-&gt;parms.base_reachable_time);<br />init_timer(&amp;tbl-&gt;gc_timer);<br />tbl-&gt;gc_timer.data = (unsigned long)tbl;<br /> tbl-&gt;gc_timer.function = neigh_periodic_timer;<br /> tbl-&gt;gc_timer.expires = now + tbl-&gt;gc_interval + tbl-&gt;parms.reachable_time;<br />add_timer(&amp;tbl-&gt;gc_timer);<br /> init_timer(&amp;tbl-&gt;proxy_timer);<br /> tbl-&gt;proxy_timer.data = (unsigned long)tbl;<br /> tbl-&gt;proxy_timer.function = neigh_proxy_process;<br /> skb_queue_head_init(&amp;tbl-&gt;proxy_queue);<br /> tbl-&gt;last_flush = now;<br /> tbl-&gt;last_rand = now + tbl-&gt;parms.reachable_time*20;<br /> tbl-&gt;next = neigh_tables;<br /> neigh_tables = tbl;<br /> }<br /> jiffies是当前系统的时间，在i386系统上面好象一个jiffies代表50ms，显然这个函数就是生成两个timer将一个放在系统的timerlist里面。那个gc_timer的意思是garbage collect timer，因为每过一段时间arp<br /> 的cache就应该更新，所以要有一个expires时间，这段时间过了以后就要更新arp地址了，那个proxy_timer还没有看是什么，不过我假 定我的机器不使用proxy也不做成proxy，所以proxy相关的都没有管:P那个timer的function显然是时钟到期的回调函数，data 是这个回调函数要使用的私有数据了。<br /><br />下面是dev_add_pack函数，它在net/core/dev.c里面：<br /> void dev_add_pack(struct packet_type *pt)<br /> {<br /> int hash;<br /> #ifdef CONFIG_NET_FASTROUTE<br /> /* Hack to detect packet socket */<br /> if (pt-&gt;data) {<br /> netdev_fastroute_obstacles++;<br /> dev_clear_fastroute(pt-&gt;dev);<br /> }<br /> #endif<br /> if(pt-&gt;type==htons(ETH_P_ALL))<br /> {<br /> netdev_nit++;<br /> pt-&gt;next=ptype_all;<br /> ptype_all=pt;<br /> }<br /> else<br /> { <br /> hash=ntohs(pt-&gt;type)&amp;15;<br /> pt-&gt;next = ptype_base[hash];<br /> ptype_base[hash] = pt;<br /> }<br /> }<br /> 显然系统保留了两个表，一个是ptype_all，用来接收所有类型的包的链表，一个是一个hash数组+链表的结构，用来接收特定类型的包。那个fastroute不知道是什么东西。<br /><br />struct packet_type的定义在include/linux/netdevice.h里面，我保留原来的注释，这样就不用我多说了:) <br /> {<br /> unsigned short type; <br /> /* This is really htons(ether_type). */<br /> struct device *dev; <br /> /* NULL is wildcarded here */<br /> int (*func) (struct sk_buff *, <br /> struct device *, struct packet_type *);<br /> void *data; <br /> /* Private to the packet type */<br /> struct packet_type *next;<br /> };<br /> 其中的func当然是回调函数了,举个例子来说，arp_packet_type是这样的：<br /> static struct packet_type arp_packet_type =<br /> {<br /> __constant_htons(ETH_P_ARP),<br /> NULL, /* All devices */<br /> arp_rcv,<br /> NULL,<br /> NULL<br /> };<br /><br />arp_init函数还有最后一个proc_net_register函数，这个函数在include/linux/proc_fs.h里面： <br /> static inline int proc_net_register(struct proc_dir_entry * x)<br /> {<br /> return proc_register(proc_net, x);<br /> }<br /><br />而proc_register在fs/proc/root.c里面，这个函数就不帖了主要就是在proc_net对应的目录下面生成每个协议的子目录。这 个函数的作用就是对每一个协议，例如TCP等在/proc目录下面生成相应的目录，用户可以通过访问/proc/net目录下面的相应目录得到每个协议的 统计参数。<br /><br />3 下面是ip_init函数，它在net/ipv4/ip_output.c里面：(下面假定定义了CONFIG_PROC_FS，CONFIG_IP_MULTICAST和CONFIG_NET_CLS_ROUTE)<br /> __initfunc(void ip_init(void))<br /> {<br /> dev_add_pack(&amp;ip_packet_type);<br /> ip_rt_init();<br /> proc_net_register(&amp;proc_net_igmp);<br /> }<br /><br />前面的dev_add_pack是说过的，这里就不再说了，而且proc_net_register也是前面提过的，这里都不说了，先来看看ip_rt_init函数把，它在net/ipv4/route.c里面，函数是这样的： <br /> __initfunc(void ip_rt_init(void))<br /> {<br /> struct proc_dir_entry *ent;<br /> devinet_init();<br /> ip_fib_init();<br /> rt_periodic_timer.function = rt_check_expire;<br /> /* All the timers, started at system startup tend<br /> to synchronize. Perturb it a bit.<br /> */<br /> rt_periodic_timer.expires = jiffies + net_random()%<br /> ip_rt_gc_interval + ip_rt_gc_interval;<br /> add_timer(&amp;rt_periodic_timer);<br /><br />proc_net_register(&amp;(struct proc_dir_entry) { <br /> PROC_NET_RTCACHE, 8, “rt_cache”,<br /> S_IFREG | S_IRUGO, 1, 0, 0,<br /> 0, &amp;proc_net_inode_operations,<br /> rt_cache_get_info<br /> });<br /> ent = create_proc_entry(“net/rt_acct”, 0, 0);<br /> ent-&gt;read_proc = ip_rt_acct_read;<br /> }<br /> 这个函数总的看来就是注册几个notifier(后面还要看的)和初始化路由表的timer，最后就在/proc目录下面创建一个目录项。其中 proc_net_register函数就不说了，而create_proc_entry函数就是在/proc/net目录下面创建一个rt_acct， 就是路由参数统计(account)目录，读函数就是ip_rt_acct_read，这个函数就是从全局变量ip_rt_acct中间拷贝数据到用户缓 冲中而已。<br /> devinet_init函数是net/ipv4/devinet.c里面的函数，整理后如下:<br /> register_gifconf(PF_INET, inet_gifconf);<br /> register_netdevice_notifier(&amp;ip_netdev_notifier);<br /><br />register_netdevice_notifier函数在说PACKET协议的时候提过，这里不说了，register_gifconf函数是用来 注册对应SIOCGIFCONF这个系统调用的协议无关的一个回调函数，这个函数对于PF_INET来说就是inet_gifconf函数。其中 inet_gifconf函数是net/ipv4/devinet.c里面的，我大概的看了一点，主 <br /> 要好象是在所有的interface里面做一个循环，得到相应的name和address然后返回的。不过不是非常确定。大家参谋呀:)<br /> 而register_gifconf函数本身是在net/core/dev.c里面的，如下：<br /> static gifconf_func_t * gifconf_list [NPROTO];<br /><br />int register_gifconf(unsigned int family, gifconf_func_t * gifconf) <br /> {<br /> if (family&gt;=NPROTO)<br /> return -EINVAL;<br /> gifconf_list[family] = gifconf;<br /> return 0;<br /> }<br /><br />这个函数的意义一目了然，就不说了。gifconf_list里的函数会在dev_ifconf函数中间被调用，而dev_ifconf函数被dev_ioctl函数调用，dev_ioctl函数负责所有的针对interface的I/O控制。所以 <br /> 我们调用的interface的ioctl函数有一部分就会分到每个协议的gifconf函数里面来，我猜gifconf大概是generous interface configure的意思。就是通用接口配置的意思。<br /> 下面再看ip_fib_init函数，它在net/ipv4/fib_frontend.c中间，如下：(假定没有define CONFIG_IP_MULTIPLE_TABLES，这个参数好象是要创建两个路由表，一个是local的，一个叫main，我想大概一般系统上面只有 一个路由表的，所以认为没有定义，不知道哪位清楚这个参数的意义？为<br /> 什么要两个路由表？)<br /> __initfunc(void ip_fib_init(void))<br /> {<br /> proc_net_register(&amp;(struct proc_dir_entry) {<br /> PROC_NET_ROUTE, 5, “route”,<br /> S_IFREG | S_IRUGO, 1, 0, 0,<br /> 0, &amp;proc_net_inode_operations,<br /> fib_get_procinfo<br /> });<br /><br />fib_rules_init(); <br /> register_netdevice_notifier(&amp;fib_netdev_notifier);<br /> register_inetaddr_notifier(&amp;fib_inetaddr_notifier);<br /> }<br /><br />其中proc_net_register和register_netdevice_notifier函数上面已经提过 了，register_inetaddr_notifier函数的作用和register_netdevice_notifier差不多，这个函数也是调 用的notifier_chain_register函数注册一个回调函数，这个回调函数在interface加上和删除的时候被调 用，fib_rules_init函数其实也差不多，这个函数在net/ipv4/fib_rules.c里面，它其实就是调用一个 register_netdevice_notifier函数注册fib_rules_notifier回调结构体。fib代表IPv4 Forwarding Information Base，就是IPv4转发信息的意思，我有点糊涂为什么要叫这个名字而不用route什么的更明白的//sigh<br /><br />下面是分析tcp_v4_init的时候了,这个函数在net/ipv4/tcp_ipv4.c里面:<br /> __initfunc(void tcp_v4_init(struct net_proto_family *ops))<br /> {<br /> int err;<br /><br />tcp_inode.i_mode = S_IFSOCK; <br /> tcp_inode.i_sock = 1;<br /> tcp_inode.i_uid = 0;<br /> tcp_inode.i_gid = 0;<br /><br />tcp_socket-&gt;inode = &amp;tcp_inode; <br /> tcp_socket-&gt;state = SS_UNCONNECTED;<br /> tcp_socket-&gt;type=SOCK_RAW;<br /><br />if ((err=ops-&gt;create(tcp_socket, IPPROTO_TCP))&lt;0) <br /> panic(“Failed to create the TCP control socket.\n”);<br /> tcp_socket-&gt;sk-&gt;allocation=GFP_ATOMIC;<br /> tcp_socket-&gt;sk-&gt;num = 256; <br /> tcp_socket-&gt;sk-&gt;ip_ttl = MAXTTL;<br /> }<br /> tcp_inode当然就是一个inode节点了,而tcp_socket等于tcp_inode.u.socket_i,<br /> 通过一个指针他们指向同一个内存.<br /> tcp_socket是用来通信使用的,可以叫TCP的control socket或者是communicationsocket,当TCP通信没有相应的socket的时候这个socket就充当了socket的角色.比 如在一个关闭端口上收到SYN时发送RST,或者是在三次握手的时候发送SYN(还没有accept产生新的socket)<br /><br />值得注意的是ops-&gt;create函数的调用,我们前面见过对于AF_INET来说这个回调函数是net/ipv4/af_inet.c的 inet_create函数,这个函数是用来创建一个socket的时候用的,由于函数比较长,这里先略过分析,这第一次的分析只是一个大致流程的熟悉而 已. <br /><br />由于有socket创建和通信,所以这段代码是协议相关的,所以把这段代码从原来的tcp.c里面提取了出来 <br /><br />4下面是tcp_init函数,它在net/ipv4/tcp.c里面,大体上来说就是创建了几个hash表和bucket.这段代码创建了下面几个全局对象: <br /> tcp_openreq_cachep<br /> tcp_bucket_cachep<br /> tcp_timewait_cachep<br /> tcp_ehash<br /> tcp_bhash<br /><br />其中ehash代表established hash, bhash代表bind hash,它们当然分别是所有的满足TCP_ESTABLISHED &lt;= sk-&gt;state &lt; TCP_CLOSE状态的SOCK.但是我不清楚bucket在这里是什么意思.anyone knows?那几个cachep的作用也不是很清楚,特别是第二个,根本摸不着头脑.由于整个函数主要是内存分配和错误处理,这里不贴了.<br /> 再下来就是icmp_init函数了,在net/ipv4/icmp.c里面,事实上,如果把tcp_v4_init<br /> 里面的IPPROTO_TCP替换成IPPROTO_ICMP,基本都是一样的.<br /><br />剩下的proc_net_register函数前面已经讲过了,这里就不说了. <br /><br />到这里为止,Linux下面IP栈的开始的工作我们基本应该有了个了解,其中有几个关键 <br /> 的函数:<br /><br />dev_add_pack: <br /> 注册一个链路层以上的处理函数,一般是用来使用新的网络层协议的,不过如果注册<br /> 时重复也是可以的,这时候系统会设置一个copy位.如果是ETH_P_ALL则会接收所有<br /> 的数据包.加入的元素保存在ptype_all链表和ptype_base hash链表中间.<br /><br />inet_add_protocol: <br /> 注册一个建立在IP层以上的协议,例如TCP和UDP等<br /><br />proc_net_register(还有类似的proc_register): <br /> 在/proc/net目录下面创建一个子目录项来使管理者能通过文件系统得到统计信息<br /><br />现在迷惑的地方还有很多,一个是结构体sk_buff的每个成员的意义,一个是结构体sock的意义,不过这两个问题应该在以后看多了就知道了.下面我就打算一个个分析每个协议的处理了,包括状态转化/数据发送/接收<br /><br />5 一个lance得到数据以后总会这样处理:<br /> skb = dev_alloc_skb (….);<br /> skb-&gt;protocol = eth_type_trans(skb, dev);<br /> ….<br /> netif_rx (skb);<br /><br />eth_type_trans函数在net/ethernet/eth.c里面,作用当然很简单了,大家可以 <br /> 自己看;).<br /> 而netif_rx函数是在net/core/dev.c里面的,假定没有定义CONFIG_CPU_IS_SLOW<br /> (我觉得自己的CPU不慢:))和CONFIG_NET_HW_FLOWCONTROL(很少有人会意识到很<br /> 多网卡有流量控制把,不过没有交换设备的支持,想凭这个东西达到Qos也没什么<br /> 用)以后的代码是这样的:<br /> void netif_rx(struct sk_buff *skb)<br /> {<br /> skb-&gt;stamp = xtime;<br /><br />if (backlog.qlen &lt;= netdev_max_backlog) { <br /> if (backlog.qlen) {<br /> if (netdev_dropping == 0) {<br /> skb_queue_tail(&amp;backlog,skb);<br /> mark_bh(NET_BH);<br /> return;<br /> }<br /> atomic_inc(&amp;netdev_rx_dropped);<br /> kfree_skb(skb);<br /> return;<br /> }<br /> netdev_dropping = 0;<br /> skb_queue_tail(&amp;backlog,skb);<br /> mark_bh(NET_BH);<br /> return;<br /> }<br /> netdev_dropping = 1;<br /> atomic_inc(&amp;netdev_rx_dropped);<br /> kfree_skb(skb);<br /> }<br /><br />xtime是当前的时间,一个struct timeval,利用gettimeofday函数得到的就是这个东西的内容.backlog是一个sk_buff的双向链表, netdev_dropping初始化为0,如果没有定义CONFIG_NET_HW_FLOWCONTROL,这个变量一直都将是 0.skb_queue_tail就是把一个sk_buff加入到backlog双向队列中去.然后mark_bh是设置了一个全局变量相对位移 NET_BH处的bit就返回了.这个bit的设置将使得内核下次schedule的时候从 <br /> TIMER_BH向下处理时检查到NET_BH处发现有设置就会调用对应NET_BH优先级的函数net_bh来处理,这个回调函数是在 net_dev_init函数里面调用init_bh设置的,呵呵,兄弟们,如果感兴趣可以自己再init_bh看看设置一个自己的处理backlog的 函数啊.Linux在这里采取了一个古怪的策略进行控制权的转移和处理机优先级的处理.另一个函数net_bh来处理从backlog中间得到包,它是这 样的(假定没定义CONFIG_BRIDGE<br /> 这个选项):<br /> void net_bh(void)<br /> {<br /> struct packet_type *ptype;<br /> struct packet_type *pt_prev;<br /> unsigned short type;<br /> unsigned long start_time = jiffies;<br /><br />NET_PROFILE_ENTER(net_bh); <br /><br />if (qdisc_head.forw != &amp;qdisc_head) <br /> qdisc_run_queues();<br /><br />while (!skb_queue_empty(&amp;backlog)) <br /> {<br /> struct sk_buff * skb;<br /><br />if (jiffies – start_time &gt; 1) <br /> goto net_bh_break;<br /><br />skb = skb_dequeue(&amp;backlog); <br /><br />#ifdef CONFIG_NET_FASTROUTE <br /> if (skb-&gt;pkt_type == PACKET_FASTROUTE) {<br /> dev_queue_xmit(skb);<br /> continue;<br /> }<br /> #endif<br /><br />/* XXX until we figure out every place to modify.. */ <br /> skb-&gt;h.raw = skb-&gt;nh.raw = skb-&gt;data;<br /><br />if(skb-&gt;mac.raw &lt; skb-&gt;head || skb-&gt;mac.raw &gt; skb-&gt;data){ <br /> printk(KERN_CRIT “%s: wrong mac.raw ptr, proto= x\n”, <br /> skb-&gt;dev-&gt;name, skb-&gt;protocol);<br /> kfree_skb(skb);<br /> continue;<br /> }<br /><br />type = skb-&gt;protocol; <br /><br />pt_prev = NULL; <br /> for (ptype = ptype_all; ptype!=NULL; ptype=ptype-&gt;next)<br /> {<br /> if (!ptype-&gt;dev || ptype-&gt;dev == skb-&gt;dev) {<br /> if(pt_prev)<br /> {<br /> struct sk_buff *skb2=skb_clone(skb, GFP_ATOMIC);<br /> if(skb2)<br /> pt_prev-&gt;func(skb2,skb-&gt;dev, pt_prev);<br /> }<br /> pt_prev=ptype;<br /> }<br /> }<br /><br />for (ptype = ptype_base[ntohs(type)&amp;15]; ptype != NULL; <br /> ptype = ptype-&gt;next) <br /> {<br /> if (ptype-&gt;type == type &amp;&amp; (!ptype-&gt;dev ||<br /> ptype-&gt;dev==skb-&gt;dev))<br /> {<br /> if(pt_prev)<br /> {<br /> struct sk_buff *skb2;<br /> skb2=skb_clone(skb, GFP_ATOMIC);<br /> if(skb2)<br /> pt_prev-&gt;func(skb2, skb-&gt;dev, pt_prev);<br /> }<br /> pt_prev=ptype;<br /> }<br /> } /* End of protocol list loop */<br /><br />if(pt_prev) <br /> pt_prev-&gt;func(skb, skb-&gt;dev, pt_prev);<br /> else {<br /> kfree_skb(skb);<br /> }<br /> } /* End of queue loop */<br /><br />if (qdisc_head.forw != &amp;qdisc_head) <br /> qdisc_run_queues();<br /><br />netdev_dropping = 0; <br /> NET_PROFILE_LEAVE(net_bh);<br /> return;<br /><br />net_bh_break: <br /> mark_bh(NET_BH);<br /> NET_PROFILE_LEAVE(net_bh);<br /> return;<br /> }<br /><br />这个函数其实很简单,NET_PROFILE_ENTER当然是一个宏展开了,它其实就是include/net/profile.h里面的 net_profile_enter函数,而NET_PROFILE_LEAVE是profile.h文件里面的net_profile_leave函 数,有兴趣的看看把.:)帮我解疑.qdisc_head是一个Qdisc_head类型,是一个全局变量,看名字和处理顺序应该看作是一个Quick DISCovery的队列,如果不为空的话我们就要运行qdisc_run_queues函数进行清理了,不过我并不清楚这个queue的意义,这个变量 和函数都在net/sched/ <br /> sch_generic.c里面获得的.大家看了给我答疑把,xixi<br /><br />下面的东西挺简单的,我就不说了,值得注意的是: <br /> 1.大家还记得ptype_all和ptype_base吗?就是调用dev_add_pack加入的数组啊,最终也调用了pt_prev-&gt;func(….)<br /> 2.系统先处理ptype_all然后才处理的ptype_base<br /> 3.每处理一个sk_buff如果超过1jiffies(x86上为50ms)就再等待下次调用<br /> 4.sk_clone是一个快速拷贝,没有拷贝数据,只是复制头部而已<br /><br />下次看packet的func函数处理把<br /><br />6 看看在net/packet/af_packet.c里面的packet_create函数,这个就是通过packet_proto_init加入的回调 函数,假设定义了CONFIG_SOCK_PACKET,代码整理如下,这个函数是在用户创建链路层socket的时候被调用的:<br /><br />static int packet_create(struct socket *sock, int protocol)<br /> {<br /> struct sock *sk;<br /> int err;<br /><br />if (!capable(CAP_NET_RAW)) <br /> return -EPERM;<br /><br />if (sock-&gt;type != SOCK_DGRAM &amp;&amp; sock-&gt;type != SOCK_RAW <br /> &amp;&amp; sock-&gt;type != SOCK_PACKET<br /> )<br /> return -ESOCKTNOSUPPORT;<br /> //只有socket(AF_PACKET, [SOCK_DGRAM, SOCK_RAW], <br /> //或者socket(AF_INET, SOCK_PACKET ,才能调用成功<br /><br />sock-&gt;state = SS_UNCONNECTED; <br /> MOD_INC_USE_COUNT;<br /><br />err = -ENOBUFS; <br /><br />sk = sk_alloc(PF_PACKET, GFP_KERNEL, 1); <br /> if (sk == NULL)<br /> goto out;<br /><br />sk-&gt;reuse = 1; <br /> sock-&gt;ops = &amp;packet_ops;<br /> if (sock-&gt;type == SOCK_PACKET)<br /> sock-&gt;ops = &amp;packet_ops_spkt;<br /> //如果是old_style的SOCK_PACKET,就使用packet_ops_spkt<br /> //如果是AF_PACKET,就使用packet_ops作为对应的socket的<br /> //回调函数<br /><br />sock_init_data(sock,sk); <br /><br />sk-&gt;protinfo.af_packet = kmalloc(sizeof(struct packet_opt), <br /> GFP_KERNEL);<br /> //protinfo是一个union<br /><br />if (sk-&gt;protinfo.af_packet == NULL) <br /> goto out_free;<br /><br />memset(sk-&gt;protinfo.af_packet, 0, sizeof(struct packet_opt)); <br /><br />sk-&gt;zapped=0; <br /> //这个zapped属性表示一个TCP的socket收到了RST<br /><br />sk-&gt;family = PF_PACKET; <br /> sk-&gt;num = protocol;<br /><br />sk-&gt;protinfo.af_packet-&gt;prot_hook.func = packet_rcv; <br /> if (sock-&gt;type == SOCK_PACKET)<br /> sk-&gt;protinfo.af_packet-&gt;prot_hook.func = packet_rcv_spkt;<br /> sk-&gt;protinfo.af_packet-&gt;prot_hook.data = (void *)sk;<br /><br />if (protocol) { <br /> sk-&gt;protinfo.af_packet-&gt;prot_hook.type = protocol;<br /><br />dev_add_pack(&amp;sk-&gt;protinfo.af_packet-&gt;prot_hook); <br /> //注意到了没有,如果protocol非零的话也可以dev_add_pack<br /> //的,不过当然不能达到phrack55-12的目的,因为这时候你的<br /> //数据已经在用户地址空间了,内核的数据也是改不了的<br /><br />sk-&gt;protinfo.af_packet-&gt;running = 1; <br /> }<br /><br />sklist_insert_socket(&amp;packet_sklist, sk); <br /> //这个函数显然应该实现非常简单,在net/core/sock.c里面.<br /> //packet_sklist是用来给每个socket通知interface状态变化<br /> //的消息的,包括UP/DOWN/MULTICAST_LIST_CHANGE<br /> //这个回调函数的实现是我们说过的register_netdev_notifier<br /><br />return(0); <br /><br />out_free: <br /> sk_free(sk);<br /> out:<br /> MOD_DEC_USE_COUNT;<br /> return err;<br /> }<br /> 只有在创建了packet socket以后应用程序才能接收链路层的数据包.而只有你设置了一个非零的protocol以后才能dev_add_pack,你的socket才能接 收数据的.现在看来,dev_add_pack确实是实现底层数据改写的一个重要的函数.所以下面我们将注意dev_add_pack设置的回调函数 func的使用.<br /><br />7 们已经知道了,如果使用socket(AF_SOCKET, ..)产生一个PACKET SOCKET的话,dev_add_pack加入的函数是packet_rcv,下面是这个在net/packet/af_packet.c里面的函数:<br /> static int packet_rcv(struct sk_buff *skb, struct device *dev, <br /> struct packet_type *pt)<br /> {<br /> struct sock *sk;<br /> struct sockaddr_ll *sll = (struct sockaddr_ll*)skb-&gt;cb;<br /><br />sk = (struct sock *) pt-&gt;data;<br /> //我们在packet_create中令data = sk了,remember?<br /><br />if (skb-&gt;pkt_type == PACKET_LOOPBACK) {<br /> kfree_skb(skb);<br /> return 0;<br /> }<br /><br />skb-&gt;dev = dev;<br /><br />sll-&gt;sll_family = AF_PACKET;<br /> sll-&gt;sll_hatype = dev-&gt;type;<br /> sll-&gt;sll_protocol = skb-&gt;protocol;<br /> sll-&gt;sll_pkttype = skb-&gt;pkt_type;<br /> sll-&gt;sll_ifindex = dev-&gt;ifindex;<br /> sll-&gt;sll_halen = 0;<br /><br />if (dev-&gt;hard_header_parse)<br /> sll-&gt;sll_halen = dev-&gt;hard_header_parse(skb, sll-&gt;sll_addr);<br /><br />if (dev-&gt;hard_header)<br /> if (sk-&gt;type != SOCK_DGRAM)<br /> skb_push(skb, skb-&gt;data – skb-&gt;mac.raw);<br /> else if (skb-&gt;pkt_type == PACKET_OUTGOING)<br /> skb_pull(skb, skb-&gt;nh.raw – skb-&gt;data);<br /><br />if (sock_queue_rcv_skb(sk,skb)&lt;0)<br /> {<br /> kfree_skb(skb);<br /> return 0;<br /> }<br /> return(0);<br /> }<br /> 在这个函数里面有个地方我很疑惑,那就是pkt_type属性,不知道这个属性是什么地方确定的,从网卡驱动 -&gt;netif_rx-&gt;net_bh中间都没有,而且甚至在net_bh函数中间就有if(skb-&gt;pkt_type==…) 这样的语句,说明在驱动中间就设置了,但是没有找到,我faint了.这个属性以后还会大量使用,还是很重要的.<br /><br />这里还有几个函数要说明:<br /> skb_pull在include/linux/skbuff.h中间:<br /> extern __inline__ char *__skb_pull(struct sk_buff *skb, <br /> unsigned int len)<br /> {<br /> skb-&gt;len-=len;<br /> return skb-&gt;data+=len;<br /> }<br /><br />extern __inline__ unsigned char * skb_pull(struct sk_buff *skb, <br /> unsigned int len)<br /> { <br /> if (len &gt; skb-&gt;len)<br /> return NULL;<br /> return __skb_pull(skb,len);<br /> }<br /> 不过是把头部的数据空出来,相应调整数据头部data的地址和长度.<br /><br />同样skb_push在include/linux/skbuff.h中间:<br /> extern __inline__ unsigned char *__skb_push(struct sk_buff *skb, <br /> unsigned int len)<br /> {<br /> skb-&gt;data-=len;<br /> skb-&gt;len+=len;<br /> return skb-&gt;data;<br /> }<br /><br />extern __inline__ unsigned char *skb_push(struct sk_buff *skb, <br /> unsigned int len)<br /> {<br /> skb-&gt;data-=len;<br /> skb-&gt;len+=len;<br /> if(skb-&gt;datahead)<br /> {<br /> __label__ here;<br /> skb_under_panic(skb, len, &amp;&amp;here);<br /> here: ;<br /> }<br /> return skb-&gt;data;<br /> }<br /> 这个调整使数据长度加长,和skb_pull相反,不过skb_push显然更加安全一点.<br /><br />在上面的程序中间,如果设备有一个明确的link_level_header,就考虑要不要调整数据长度和地址,如果sk-&gt;type不是 SOCK_DGRAM的话,说明程序对整个数据包包括ll地址都感兴趣.这样需要加长数据段使得数据包含ll头部.不然如果数据是向外走的,则需要把数据 裁减到只包含从网络层数据包头开始的地方.所以<br /> 是从nh.raw剪掉data,这就是差值.(nh=network header)<br /><br />经过了这些处理以后,现在的skb已经是可以提交的了,这样就调用sock_queue_rcv_skb函数将这个skb加入到相应socket的接收缓冲区中去. 这个<br /> 函数以后再说把.</p> </div>    <div class="mod-tagbox clearfix">   <a class="tag" href="/tag/%E7%BD%91%E7%BB%9C/feeds">#网络</a>  </div> <div class="mod-post-info clearfix">  <div class=x-bdshare>  <div id=bdshare class="bdshare_t bds_tools get-codes-bdshare" data="{'wbuid':1727466295}"> <span class=bds_more>分享到：</span> <a class=bds_qzone></a> <a class=bds_tsina></a> <a class=bds_tqq></a> <a class=bds_renren></a> </div> <script id=bdshare_js data="type=tools&amp;uid=713670"></script> <script id=bdshell_js></script> <script>
        var bds_config = {'bdTop':240};
                    var all_img = qing.g('content').getElementsByTagName('img');
            if(all_img.length>0){
                bds_config.bdPic = all_img[0].src;
            }
                document.getElementById("bdshell_js").src = "http://bdimg.share.baidu.com/static/js/shell_v2.js?v=66280422.js?cdnversion=" + Math.ceil(new Date()/3600000);
    </script> </div> <div class="op-box mod-cs-opBox">  <a class="report-btn hide" target=_blank href="#"> 举报 </a>  <span class=pv>浏览(135)</span> <a class=comment-bnt id=commentBnt href="#" onclick="return false"> 评论<span class=comment-nub></span> </a>   <a href="#" id=shareBnt onclick="return false" class=share-bnt> 转载<span id=shareNub class=share-nub></span> </a>   </div> </div>   </div>    <div class=mod-share-detail id=shareDetail style=display:none></div>   <div class=mod-relate-blogs id=relateBlog> <h3 class=relate-title>你可能也喜欢</h3> <ul class="relate-blog-list clearfix">   <li  class=first > <a href="http://hi.baidu.com/maimijiaju/item/93f56adb2b8b3ea4260ae7e9" target=_blank class=qing-stat-nsclick data-nsclick=m_20121105_detail_relates_img> <img src="http://d.hiphotos.baidu.com/space/scrop=90/sign=c39fbf754d086e066ef67814723542c4/fcfaaf51f3deb48ff752829af11f3a292df578be.jpg" class=relate-img alt="装饰浴室&马赛克设计" title="装饰浴室&马赛克设计"> </a> <a href="http://hi.baidu.com/maimijiaju/item/93f56adb2b8b3ea4260ae7e9" target=_blank class="relate-txt qing-stat-nsclick" data-nsclick=m_20121105_detail_relates_txt>装饰浴室&马赛克设计</a>    <li > <a href="http://hi.baidu.com/dreamhouse111/item/38effc5093f30f1c95eb0545" target=_blank class=qing-stat-nsclick data-nsclick=m_20121105_detail_relates_img> <img src="http://b.hiphotos.baidu.com/space/scrop=90/sign=754e9b9af11f3a295e969291e9188501/728da9773912b31b494bf76d8718367adab4e14b.jpg" class=relate-img alt="2010-2013宜家卧室设计汇集" title="2010-2013宜家卧室设计汇集"> </a> <a href="http://hi.baidu.com/dreamhouse111/item/38effc5093f30f1c95eb0545" target=_blank class="relate-txt qing-stat-nsclick" data-nsclick=m_20121105_detail_relates_txt>2010-2013宜家卧室设计汇集</a>    <li > <a href="http://hi.baidu.com/huibenjiaju/item/508b3aec29d902a9ce2d4f45" target=_blank class=qing-stat-nsclick data-nsclick=m_20121105_detail_relates_img> <img src="http://b.hiphotos.baidu.com/space/scrop=90/sign=56ceffaab58f8c54e78d82704a1414c5/b8014a90f603738d50e83566b21bb051f919ecd0.jpg" class=relate-img alt="甜蜜幸福家居 66平米三口之家的小资情调" title="甜蜜幸福家居 66平米三口之家的小资情调"> </a> <a href="http://hi.baidu.com/huibenjiaju/item/508b3aec29d902a9ce2d4f45" target=_blank class="relate-txt qing-stat-nsclick" data-nsclick=m_20121105_detail_relates_txt>甜蜜幸福家居 66平米三口之家的小资情调</a>    <li > <a href="http://hi.baidu.com/gunxueqiu8888/item/c53b341a4660cf60e65e064d" target=_blank class=qing-stat-nsclick data-nsclick=m_20121105_detail_relates_img> <img src="http://d.hiphotos.baidu.com/space/scrop=90/sign=f1ffee24342ac65c635b212c8bcf8b21/8694a4c27d1ed21bc58c1ca1ac6eddc451da3f28.jpg" class=relate-img alt="萌翻你的儿童房 早做准备" title="萌翻你的儿童房 早做准备"> </a> <a href="http://hi.baidu.com/gunxueqiu8888/item/c53b341a4660cf60e65e064d" target=_blank class="relate-txt qing-stat-nsclick" data-nsclick=m_20121105_detail_relates_txt>萌翻你的儿童房 早做准备</a>    <li > <a href="http://hi.baidu.com/padesign/item/ab87daaba8569bf65bf191ed" target=_blank class=qing-stat-nsclick data-nsclick=m_20121105_detail_relates_img> <img src="http://a.hiphotos.baidu.com/space/scrop=90/sign=e378b67a4a36acaf5dbed1a30ce4b420/0eb30f2442a7d933e0021130ac4bd11372f001ce.jpg" class=relate-img alt="【拍案设计】设计师Angelo Tomaiuolo为品牌Tonin Casa设计的蝴蝶桌" title="【拍案设计】设计师Angelo Tomaiuolo为品牌Tonin Casa设计的蝴蝶桌"> </a> <a href="http://hi.baidu.com/padesign/item/ab87daaba8569bf65bf191ed" target=_blank class="relate-txt qing-stat-nsclick" data-nsclick=m_20121105_detail_relates_txt>【拍案设计】设计师Angelo Tomaiuolo为品牌Tonin Casa设计的蝴蝶桌</a>    <li > <a href="http://hi.baidu.com/mjzsbkotsrbntwq/item/77a315043ed3aff13699029c" target=_blank class=qing-stat-nsclick data-nsclick=m_20121105_detail_relates_img> <img src="http://c.hiphotos.baidu.com/space/scrop=90/sign=19013f514e4a20a435407b98e06fa112/6d81800a19d8bc3eeb226189838ba61ea8d3454e.jpg" class=relate-img alt="陈设讲究艺术" title="陈设讲究艺术"> </a> <a href="http://hi.baidu.com/mjzsbkotsrbntwq/item/77a315043ed3aff13699029c" target=_blank class="relate-txt qing-stat-nsclick" data-nsclick=m_20121105_detail_relates_txt>陈设讲究艺术</a>    <li > <a href="http://hi.baidu.com/407433544/item/5f2daa0f203d93123a53ee9b" target=_blank class=qing-stat-nsclick data-nsclick=m_20121105_detail_relates_img> <img src="http://a.hiphotos.baidu.com/space/scrop=90/sign=d9b5da246c81800a6abbce51c1080aca/e824b899a9014c0866eb0b0e0a7b02087af4f44c.jpg" class=relate-img alt="Linux 协议栈分析 socket——3" title="Linux 协议栈分析 socket——3"> </a> <a href="http://hi.baidu.com/407433544/item/5f2daa0f203d93123a53ee9b" target=_blank class="relate-txt qing-stat-nsclick" data-nsclick=m_20121105_detail_relates_txt>Linux 协议栈分析 socket——3</a>   </ul> </div>   <div class="mod-detail-pager clearfix">  <div class=detail-nav-pre> <a href="http://hi.baidu.com/407433544/item/be8278ce1ee3be14b67a2499" hidefocus title="上一篇"></a> </div>   <div class=detail-nav-next> <a href="http://hi.baidu.com/407433544/item/1024e616ae062dff756a8481" hidefocus title="下一篇"></a> </div>  </div>   <div id=commentDetail class="mod-comment-detail clearfix mod-cs-comment">   <div class=comment-title>评论</div> <div class=comment-content></div> </div>   </div>  </div>  </div> </div> </section>  <footer class="mod-footer mod-cs-footer"><div class="clearfix hidden-box"></div><div class=footer-box><div class=inner-box><a href=http://help.baidu.com/question?prod_en=hi target=_blank>帮助中心</a><span>&nbsp;|&nbsp;</span><a href=http://tieba.baidu.com/p/1781683739 target=_blank>空间客服</a><span>&nbsp;|&nbsp;</span><a href=http://tousu.baidu.com/hi/add target=_blank>投诉中心</a><span>&nbsp;|&nbsp;</span><a href=http://www.baidu.com/search/hi_contract.html target=_blank>空间协议</a></div><div class=copy-box>&copy;2013&nbsp;Baidu</div></div></footer>  <script src="http://hi.bdimg.com/static/qbase/js/mod/mod_foot.js?v=747a1d59.js"></script> <script>
        	qing.dom.ready(function(){
                if (qVisitorInfo.loginStatus == 'activated'){
                    qext.stat.ns('m_20121012_loga_num');
					qext.fn.setStoken();
				}
			});
        </script>        <script>qext.stat.ns('m_20120425_');</script>  <script src="http://hi.bdimg.com/static/qcomment/js/qcmt_import.js?v=ac96f988.js"></script>  <script src="http://hi.bdimg.com/static/qpublish/js/editor/shCore.js?v=bcf5a2e1.js"></script> <script>
        SyntaxHighlighter.highlight();
    </script>   <script src="http://hi.bdimg.com/static/qhome/js/detail/20001/detail.js?v=7ff54b94.js"></script>   <script>wpo.tti=new Date*1;</script><script src="http://hi.baidu.com/cm/static/js/allsite.js?v=68594928.js?v=201305161701"></script><script>document.write(unescape("%3Cscript src='http://hm.baidu.com/h.js%3F8c869b543955d43e496c2efee5b55823' type='text/javascript'%3E%3C/script%3E"));qext.stat.ns('m_20120713_qing_pv');</script>
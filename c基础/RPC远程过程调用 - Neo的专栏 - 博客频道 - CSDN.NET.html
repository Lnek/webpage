<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
     
    <html xmlns="http://www.w3.org/1999/xhtml">
    
<head>
    <title>RPC远程过程调用 - Neo的专栏
        - 博客频道 - CSDN.NET</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="description" content="RPC远程过程调用&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; 在顾客服务员模型中，进程之间的相互作用是由一个进程先向另一个进程发送一个报文请求服务，然后等待回答；服务进程接收一个请求，然后发送回答。这样一种交互作用很象通常意义的过程调用。但是在计算机网络系统中，这种调用可能在不同的机器上执行，因此称为远程过程调用（remote procedure call）。远程过程调用的基础是XDR协议。&#160;11.1" />
    <script src="http://static.blog.csdn.net/scripts/jquery.js" type="text/javascript"></script>
    <script type="text/javascript" src="http://static.blog.csdn.net/scripts/ad.js?v=1.1"></script>
        <!--new top-->
               <link rel="stylesheet" href="http://static.csdn.net/public/common/toolbar/css/index.css">        <!--new top-->

    <link rel="Stylesheet" type="text/css" href="http://static.blog.csdn.net/skin/dark1/css/style.css?v=1.1" />
    <link id="RSSLink" title="RSS" type="application/rss+xml" rel="alternate" href="/Andeewu/rss/list" />
    <link rel="shortcut icon" href="http://csdnimg.cn/public/favicon.ico" />
    <link type="text/css" rel="stylesheet" href="http://static.blog.csdn.net/scripts/SyntaxHighlighter/styles/default.css" />
 

</head>
<body>
    
   
      <!--new top-->
    <script id="toolbar-tpl-scriptId" fixed="true" prod="blog" skin="black" src="http://static.csdn.net/public/common/toolbar/js/html.js" type="text/javascript"></script>
     <!--new top-->
    <div id="container">
        <div id="header">
    <div class="header">
        <div id="blog_title">
            <h2>
                <a href="http://blog.csdn.net/neo_ustc">Neo的专栏</a></h2>
            <h3>Stay Hungry，Stay Foolish</h3>
            <div class="clear">
            </div>
        </div>
        <div class="clear">
        </div>
    </div>
</div>
<div id="navigator">
    <div class="navigator_bg">
    </div>
    <div class="navigator">
        <ul>
                <li id="btnContents"><a href="http://blog.csdn.net/neo_ustc?viewmode=contents"><span onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_mulu'])">
                    <img src="http://static.blog.csdn.net/images/ico_list.gif">目录视图</span></a></li>
                <li id="btnView"><a href="http://blog.csdn.net/neo_ustc?viewmode=list"><span onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_zhaiyao'])">
                    <img src="http://static.blog.csdn.net/images/ico_summary.gif">摘要视图</span></a></li>
                <li id="btnRss"><a href="http://blog.csdn.net/neo_ustc/rss/list"><span onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_RSS'])">
                    <img src="http://static.blog.csdn.net/images/ico_rss.gif">订阅</span></a></li>

            </ul>
    </div>
</div>
<script type="text/javascript">
    var username = "Andeewu";
    var _blogger = username;
    var blog_address = "http://blog.csdn.net/neo_ustc";
    var static_host = "http://static.blog.csdn.net";
    var currentUserName = "";
</script>

        <div id="body">
            <div id="main">
                <div class="main">
<div class="notice tracking-ad" data-mod='popu_3' > 

<a href="http://blog.csdn.net/blogdevteam/article/details/25387451"target="_blank">
<font color=blue>有奖征资源，博文分享有内涵
</font></a>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

<a href="http://blog.csdn.net/blogdevteam/article/details/29379593"target="_blank">
<font color=red>5月推荐博文汇总 
</font></a>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

<a href="http://blog.csdn.net/blogdevteam/article/details/26512525"target="_blank">
<font color=blue>大数据读书汇--获奖名单公布 
</font></a>

</div>                    <link href="http://static.blog.csdn.net/css/comment1.css" type="text/css" rel="stylesheet" />
<link href="http://static.blog.csdn.net/css/style1.css" type="text/css" rel="stylesheet" />
<script language='JavaScript' type='text/javascript' src='http://download.csdn.net/js/jquery.cookie.js'></script>
<script type="text/javascript" src="http://csdnimg.cn/rabbit/search-service/main.js"></script>
<div id="article_details" class="details">
    <div class="article_title">   
         <span class="ico ico_type_Repost"></span>


    <h1>
        <span class="link_title"><a href="/neo_ustc/article/details/8747003">
        RPC远程过程调用
        </a></span>
    </h1>
</div>

    <div class="article_manage">
        <span class="link_categories">
        分类：
            <a href="/Andeewu/article/category/1337591" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_fenlei']);">COM</a> 
        </span>
    <span class="link_postdate">2013-04-01 16:02</span>
    <span class="link_view" title="阅读次数">293人阅读</span>
    <span class="link_comments" title="评论次数"><a href="#comments" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_pinglun'])">评论</a>(0)</span>
    <span class="link_collect"><a href="javascript:void(0);" onclick="javascript:_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_shoucang']);collectArticle('RPC远程过程调用','8747003');return false;" title="收藏">收藏</a></span>
    <span class="link_report"><a href="#report"  onclick="javascript:_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_jubao']);report(8747003,2);return false;" title="举报">举报</a></span>
    
</div>

    
<div id="article_content" class="article_content">

<p>&nbsp;</p>
<p align="center"><strong>&nbsp;RPC远程过程调用</strong></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在顾客服务员模型中，进程之间的相互作用是由一个进程先向另一个进程发送一个报文请求服务，然后等待回答；服务进程接收一个请求，然后发送回答。这样一种交互作用很象通常意义的过程调用。但是在计算机网络系统中，这种调用可能在不同的机器上执行，因此称为远程过程调用（remote procedure call）。远程过程调用的基础是XDR协议。</p>
<p>&nbsp;</p>
<p><strong>11.1 XDR标准</strong></p>
<p>&nbsp;</p>
<p><strong>11.1.1 数据结构传输的问题</strong></p>
<p>&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在异构的网络系统中，在顾客进程和服务器进程之间可能需要传递一些复杂的数据结构，这些数据结构可能用于控制进程的行为或者返回进程处理的结果。在数据结构传输过程中可能存在的问题有：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1．网络字节序问题</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 不同类型的计算机系统对于数据的存储&#26684;式可能不同，例如对于一个整数int，PC机存储时低位字节在前，而高位字节在后；而Sun工作站存储时是低位字节在后，而高位字节在前。这将导致它们对相同整数的2进制序列理解不同。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2．浮点数的传递</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 浮点数的传递比整数更加困难，通常浮点数使用若干比特表示整数部分，其它比特表示小数部分。不同类型的浮点数float和double，它们使用的比特数不同，这使得在网络中传递它们有一定的困难。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对于浮点数的处理，用户可以将浮点数前后的两个部分分别看成两个整数，分别进行传递，也可以将浮点数看成字符串的形式传递。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3．指针的处理</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在数据结构传递中，指针的传递是最困难的，因为指针的含义是本机上存放某个数据的地址，这个地址在远端的主机上没有意义。所以用户必须传递的是指针的内容而不是指针本身。例如，对于一个字符串指针，用户需要将字符串的内容包含在数据内容中，同时还需要包含字符串的长度信息。</p>
<p>&nbsp;</p>
<p><strong>11.1.2 XDR标准</strong></p>
<p><strong>&nbsp;</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 数据类型的传输可以多种多样，用户可以使用自己定义的规则，满足应用程序的数据结构传递。但是如果要使网络程序能够很好地同其它网络程序互通，则需要遵循一个公共的标准。在数据传递过程中实际使用的标准是Sun microsystem设计的XDR标准。</p>
<p>&nbsp;</p>
<p><strong>11.1.2.1 XDR标准中包含的数据类型</strong></p>
<p>&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Sunmicrosystem设计的XDR标准规定了在网络中传输数据如何表示成公共的形式，它已经成为大多数顾客服务员应用中的事实上的标准。在XDR标准中定义了表11-1中的数据类型。</p>
<p align="center"><strong>表11-1 XDR标准中的是数据类型</strong></p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top">
<p align="center">数据类型</p>
</td>
<td valign="top">
<p align="center">长度（ bits）</p>
</td>
<td valign="top">
<p align="center">含义</p>
</td>
</tr>
<tr>
<td valign="top">
<p align="center">int</p>
</td>
<td valign="top">
<p align="center">32</p>
</td>
<td valign="top">
<p align="center">32比特的2进制符号整数</p>
</td>
</tr>
<tr>
<td valign="top">
<p align="center">unsigned int</p>
</td>
<td valign="top">
<p align="center">32</p>
</td>
<td valign="top">
<p align="center">32比特的2进制无符号整数</p>
</td>
</tr>
<tr>
<td valign="top">
<p align="center">bool</p>
</td>
<td valign="top">
<p align="center">32</p>
</td>
<td valign="top">
<p align="center">布尔&#20540;，用1或0表示</p>
</td>
</tr>
<tr>
<td valign="top">
<p align="center">enum</p>
</td>
<td valign="top">
<p align="center">任意</p>
</td>
<td valign="top">
<p align="center">枚举类型，&#20540;被定义成常数</p>
</td>
</tr>
<tr>
<td valign="top">
<p align="center">hyper</p>
</td>
<td valign="top">
<p align="center">64</p>
</td>
<td valign="top">
<p align="center">64比特的2进制符号整数</p>
</td>
</tr>
<tr>
<td valign="top">
<p align="center">unsigned hyper</p>
</td>
<td valign="top">
<p align="center">64</p>
</td>
<td valign="top">
<p align="center">64比特的2进制无符号整数</p>
</td>
</tr>
<tr>
<td valign="top">
<p align="center">float</p>
</td>
<td valign="top">
<p align="center">32</p>
</td>
<td valign="top">
<p align="center">单精度浮点数</p>
</td>
</tr>
<tr>
<td valign="top">
<p align="center">double</p>
</td>
<td valign="top">
<p align="center">32</p>
</td>
<td valign="top">
<p align="center">双精度浮点数</p>
</td>
</tr>
<tr>
<td valign="top">
<p align="center">opaque</p>
</td>
<td valign="top">
<p align="center">任意</p>
</td>
<td valign="top">
<p align="center">不对这样的字节序列进行转化</p>
</td>
</tr>
<tr>
<td valign="top">
<p align="center">string</p>
</td>
<td valign="top">
<p align="center">任意</p>
</td>
<td valign="top">
<p align="center">ASCII字符串</p>
</td>
</tr>
<tr>
<td valign="top">
<p align="center">fixed array</p>
</td>
<td valign="top">
<p align="center">任意</p>
</td>
<td valign="top">
<p align="center">任何其它数据类型的定长数组</p>
</td>
</tr>
<tr>
<td valign="top">
<p align="center">counted array</p>
</td>
<td valign="top">
<p align="center">任意</p>
</td>
<td valign="top">
<p align="center">数组中的类型有一个固定上界，但各个数组的上限大小不同</p>
</td>
</tr>
<tr>
<td valign="top">
<p align="center">structure</p>
</td>
<td valign="top">
<p align="center">任意</p>
</td>
<td valign="top">
<p align="center">数据的聚合，类&#20284;C语言中的结构</p>
</td>
</tr>
<tr>
<td valign="top">
<p align="center">discriminated union</p>
</td>
<td valign="top">
<p align="center">任意</p>
</td>
<td valign="top">
<p align="center">类&#20284;C语言中的union，可以在几种形式中选择一种数据类型</p>
</td>
</tr>
<tr>
<td valign="top">
<p align="center">void</p>
</td>
<td valign="top">
<p align="center">0</p>
</td>
<td valign="top">
<p align="center">如果数据项可选，它又没有给出具体数据，则使用这种类型</p>
</td>
</tr>
<tr>
<td valign="top">
<p align="center">symbolic constant</p>
</td>
<td valign="top">
<p align="center">任意</p>
</td>
<td valign="top">
<p align="center">一个符号常量及相关&#20540;</p>
</td>
</tr>
<tr>
<td valign="top">
<p align="center">optional data</p>
</td>
<td valign="top">
<p align="center">任意</p>
</td>
<td valign="top">
<p align="center">允许一个数据出现0次或1次</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; XDR标准中的数据类型和C语言中的数据类型非常相&#20284;，XDR允许有结构数组，结构中可以有多个字段，每个字段成员可以是一个数组、结构或者联合，它完全能够适应复杂数据结构的传递。</p>
<p>&nbsp;</p>
<p><strong>11.1.2.2 XDR实现的原理</strong></p>
<p>&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; XDR对各种数据类型规定了编码的方式。用户可以使用函数xdrmem_create在内存中创建一个XDR流来存放用户将要发送的数据结构。在初始化后的XDR流包含一个流的头部，函数xdrmem_create的使用方法如下：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include&lt;rpc/xdr.h&gt;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; externvoid xdrmem_create ((XDR *xdrs, const caddr_t addr, u_int size, enum xdr_opxop));</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 其中，变量xdrs是创建XDR流的指针，变量addr是内存中用于存放XDR流空间的起始地址，变量size是这个空间的长度，变量xop是说明对函数xdrmem_create调用的操作，其定义如下：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enumxdr_op&nbsp; {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; XDR_ENCODE=0，</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; XDR_DECODE=1，</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; XDR_FREE=2</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 如果变量xop取XDR_ENCODE，则创建一个用于发送的XDR流；如果变量xop取XDR_DECODE，则创建一个用于接收的XDR流；如果变量xop取XDR_FREE，则释放这个XDR流。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 随后假如用户调用相应的函数来填写一个整数0x00000004，XDR流的结果如图11-1所示。</p>
<p>&nbsp;</p>
<p>
<table cellpadding="0" cellspacing="0" align="left">
</table>
&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<br clear="ALL">
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; XDR在编码中并没有提供关于数据类型的信息。例如，当XDR对一个32比特的整数进行编码时，编码的结果仍然是32比特，所以，只有数据的接收者知道这32比特的数据类型时，数据的接收者才能正确地恢复这项数据。因此，用户必须配对地编写发送和接收函数，分别处理每个数据项。</p>
<p>&nbsp;</p>
<p><strong>11.1.2.3 XDR的转换函数库</strong></p>
<p>&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1．转换函数库</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在XDR库函数中提供了对各种数据类型进行编码和解码的函数。这些函数具体进行编码还是解码，不是由这些函数决定的，而是由函数中XDR流的性质决定。当XDR流被创建为编码流，则这些函数将对数据进行编码处理；当XDR流被创建为解码流，则这些函数对数据进行解码处理。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 表11-2列出了XDR库函数中进行类型转化的函数。用户在调用这些函数之前，必须包含头文件rpc/xdr.h。</p>
<p align="center"><strong>表11-2 XDR中类型转换函数</strong></p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top">
<p align="center">函数调用</p>
</td>
<td valign="top">
<p align="center">说明</p>
</td>
</tr>
<tr>
<td valign="top">
<p align="center">extern bool_t xdr_void((void));</p>
</td>
<td valign="top">
<p align="center">xdr_void用于处理没有数据的空选项</p>
</td>
</tr>
<tr>
<td valign="top">
<p align="center">extern bool_t xdr_short((XDR *xdrs, short *sp));</p>
</td>
<td valign="top">
<p align="center">xdr_short用于处理short类型数据。xdrs是XDR流指针，sp是指向存放short类型数据空间的指针</p>
</td>
</tr>
<tr>
<td valign="top">
<p align="center">extern bool_t xdr_u_short((XDR *xdrs, u_short *usp));</p>
</td>
<td valign="top">
<p align="center">xdr_u_short用于处理u_short类型数据。xdrs是XDR流指针，usp是指向存放u_short类型数据空间的指针</p>
</td>
</tr>
<tr>
<td valign="top">
<p align="center">extern bool_t xdr_int((XDR *xdrs, int *ip));</p>
</td>
<td valign="top">
<p align="center">xdr_int用于处理int类型数据。xdrs是XDR流指针，ip是指向存放int类型数据空间的指针</p>
</td>
</tr>
<tr>
<td valign="top">
<p align="center">extern bool_t xdr_u_int((XDR *xdrs, int *up));</p>
</td>
<td valign="top">
<p align="center">xdr_u_int用于处理u_int类型数据。xdrs是XDR流指针，up是指向存放u_int类型数据空间的指针</p>
</td>
</tr>
<tr>
<td valign="top">
<p align="center">extern bool_t xdr_long((XDR *xdrs, long *lp));</p>
</td>
<td valign="top">
<p align="center">xdr_long用于处理long类型数据。xdrs是XDR流指针，lp是指向存放long类型数据空间的指针</p>
</td>
</tr>
<tr>
<td valign="top">
<p align="center">extern bool_t xdr_u_long((XDR *xdrs,u_long *ulp));</p>
</td>
<td valign="top">
<p align="center">xdr_u_long用于处理u_long类型数据</p>
</td>
</tr>
<tr>
<td valign="top">
<p align="center">extern bool_t xdr_hyper((XDR *xdrs,u_quad_t *llp));</p>
</td>
<td valign="top">
<p align="center">xdr_hyper用于处理hyper64比特类型数据。llp是指向hyper类型的指针</p>
</td>
</tr>
<tr>
<td valign="top">
<p align="center">extern bool_t xdr_u_hyper((XDR *xdrs,u_quad_t *ullp));</p>
</td>
<td valign="top">
<p align="center">xdr_u_hyper用于处理u_hyper64比特类型数据。ullp是指向u_hyper类型的指针</p>
</td>
</tr>
<tr>
<td valign="top">
<p align="center">extern bool_t xdr_longlong_t((XDR *xdrs, quad_t *llp));</p>
</td>
<td valign="top">
<p align="center">类&#20284;函数xdr_hyper</p>
</td>
</tr>
<tr>
<td valign="top">
<p align="center">extern bool_t xdr_u_longlong_t((XDR *xdrs, u_quad_t *llp));</p>
</td>
<td valign="top">
<p align="center">类&#20284;函数xdr_u_hyper</p>
</td>
</tr>
<tr>
<td valign="top">
<p align="center">extern bool_t xdr_int8_t((XDR *xdrs, int8_t *ip));</p>
</td>
<td valign="top">
<p align="center">用于处理8比特符号整数类型数据</p>
</td>
</tr>
<tr>
<td valign="top">
<p align="center">extern bool_t xdr_uint8_t((XDR *xdrs, uint8_t *up));</p>
</td>
<td valign="top">
<p align="center">用于处理8比特无符号整数类型数据</p>
</td>
</tr>
<tr>
<td valign="top">
<p align="center">extern bool_t xdr_int16_t((XDR *xdrs, int16_t *ip));</p>
</td>
<td valign="top">
<p align="center">用于处理16比特符号整数类型数据</p>
</td>
</tr>
<tr>
<td valign="top">
<p align="center">extern bool_t xdr_uint16_t((XDR *xdrs, uint16_t *up));</p>
</td>
<td valign="top">
<p align="center">用于处理16比特无符号整数类型数据</p>
</td>
</tr>
<tr>
<td valign="top">
<p align="center">extern bool_t xdr_int32_t((XDR *xdrs, int32_t *ip));</p>
</td>
<td valign="top">
<p align="center">用于处理32比特符号整数类型数据</p>
</td>
</tr>
<tr>
<td valign="top">
<p align="center">extern bool_t xdr_uint32_t((XDR *xdrs, uint32_t *up));</p>
</td>
<td valign="top">
<p align="center">用于处理32比特无符号整数类型数据</p>
</td>
</tr>
<tr>
<td valign="top">
<p align="center">extern bool_t xdr_int64_t((XDR *xdrs, int64_t *ip));</p>
</td>
<td valign="top">
<p align="center">用于处理64比特符号整数类型数据</p>
</td>
</tr>
<tr>
<td valign="top">
<p align="center">extern bool_t xdr_uint64_t((XDR *xdrs, uint64_t *up));</p>
</td>
<td valign="top">
<p align="center">用于处理64比特无符号整数类型数据</p>
</td>
</tr>
<tr>
<td valign="top">
<p align="center">extern bool_t xdr_bool((XDR *xdrs,bool_t *bp));</p>
</td>
<td valign="top">
<p align="center">用于处理bool_t类型数据</p>
</td>
</tr>
<tr>
<td valign="top">
<p align="center">extern bool_t xdr_enum((XDR *xdrs,enum_t *ep));</p>
</td>
<td valign="top">
<p align="center">用于处理枚举类型数据</p>
</td>
</tr>
<tr>
<td valign="top">
<p align="center">extern bool_t xdr_array((XDR *xdrs,caddr_t *addrp, u_int *sizep, u_int maxsize, u_int elsize, xdrproc_t elproc));</p>
</td>
<td valign="top">
<p align="center">用于处理数组类型数据</p>
</td>
</tr>
<tr>
<td valign="top">
<p align="center">extern bool_t xdr_bytes((XDR *xdrs, char **cpp, u_int *sizep, u_int maxsize));</p>
</td>
<td valign="top">
<p align="center">用于处理字节类型数据</p>
</td>
</tr>
<tr>
<td valign="top">
<p align="center">extern bool_t xdr_opaque((XDR *xdrs, caddr_t cp, u_int cnt));</p>
</td>
<td valign="top">
<p align="center">用于处理opaque类型数据</p>
</td>
</tr>
<tr>
<td valign="top">
<p align="center">extern bool_t xdr_string((XDR *xdrs, char **cpp, u_int maxsize));</p>
</td>
<td valign="top">
<p align="center">用于处理字符串类型数据</p>
</td>
</tr>
<tr>
<td valign="top">
<p align="center">extern bool_t xdr_union((XDR *xdrs, enum *dscmp, char *unp, const struct xdr_discrim *choices, xdrproc dfault));</p>
</td>
<td valign="top">
<p align="center">用于处理联合类型数据</p>
</td>
</tr>
<tr>
<td valign="top">
<p align="center">extern bool_t xdr_char((XDR *xdrs,char *cp));</p>
</td>
<td valign="top">
<p align="center">用于处理字符类型数据</p>
</td>
</tr>
<tr>
<td valign="top">
<p align="center">extern bool_t xdr_u_char((XDR *xdrs,u_char *cp));</p>
</td>
<td valign="top">
<p align="center">用于处理u_char类型数据</p>
</td>
</tr>
<tr>
<td valign="top">
<p align="center">extern bool_t xdr_vector((XDR *xdrs,char *basep, u_int nelem, u_int elemsize, xdrproc_t xdr_elem));</p>
</td>
<td valign="top">
<p align="center">用于处理vector类型数据</p>
</td>
</tr>
<tr>
<td valign="top">
<p align="center">extern bool_t xdr_float((XDR *xdrs,float *fp));</p>
</td>
<td valign="top">
<p align="center">用于处理float类型数据</p>
</td>
</tr>
<tr>
<td valign="top">
<p align="center">extern bool_t xdr_double((XDR *xdrs,double *dp));</p>
</td>
<td valign="top">
<p align="center">用于处理double类型数据</p>
</td>
</tr>
<tr>
<td valign="top">
<p align="center">extern bool_t xdr_reference((XDR *xdrs,caddr_t *xpp, u_int size, xdrproc_t roc));</p>
</td>
<td valign="top">
<p align="center">用于处理reference类型数据</p>
</td>
</tr>
<tr>
<td valign="top">
<p align="center">extern bool_t xdr_pointer((XDR *xdrs,char **objpp, u_int obj_size, xdrproc_t xdr_obj));</p>
</td>
<td valign="top">
<p align="center">用于处理pointer类型数据</p>
</td>
</tr>
<tr>
<td valign="top">
<p align="center">extern bool_t xdr_wrapstring((XDR *xdrs,char **cpp));</p>
</td>
<td valign="top">
<p align="center">用于处理wrapstring类型数据</p>
</td>
</tr>
<tr>
<td valign="top">
<p align="center">extern u_long xdr_sizeof((xdrproc_t, void *));</p>
</td>
<td valign="top">
<p align="center">获得数据类型的长度</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 上表中的函数都需要一个已经创建好的XDR流作为操作对象，并且都返回一个bool_t类型说明操作是否成功。关于这些函数的具体使用方法可以参见函数的帮助手册。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2．XDR工作方式</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 实际上XDR库函数中提供了2种XDR流的支持，即工作在内存的XDR流和工作在I/O的XDR流。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 调用函数xdrmem_create，它可以用于在内存中创建一个XDR流，用户可以将需要传递的数据结构在这个XDR编码流中编码，而后使用系统调用将编码发送到套接口缓冲区中，当接收方收到这些数据后也在内存中创建XDR解码流，并从套接口中将数据复制到这个XDR流中，接着使用对应的函数进行解码，得到原来的数据结构。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 图11-2说明了使用内存XDR的工作过程。</p>
<p>&nbsp;</p>
<p>
<table cellpadding="0" cellspacing="0" align="left">
</table>
&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<br clear="ALL">
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 函数xdrstdio_create用于创建工作在I/O上的XDR流，函数的使用形式如下：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include&lt;rpc/xdr.h&gt;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; externvoid xdrstdio_create((XDR *xdrs, FILE *file, enum xdr_op xop));</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 该函数中，xdrs是指向创建的XDR流的指针，file是用于输入/输出的文件流，xop是操作选项，它的取&#20540;同xdrmem_create函数中的xop类&#20284;。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I/OXDR流可以将编码/解码的结果使用系统提供的标准输出函数输出到文件流中，或者通过标准输入函数库，从文件流中读取编码/解码的结果。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 图11-3说明了I/O XDR流的工作过程。</p>
<p>
<table cellpadding="0" cellspacing="0" align="left">
</table>
&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<br clear="ALL">
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 实际上，对于套接口描述字，可以使用fdopen把它转化成对应的I/O流形式，函数fdopen的使用方法如下：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include&lt;stdio.h&gt;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FILE*fdopen(int fd);</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 调用函数fdopen之后，应用程序每次调用一个XDR的转化函数，则转化函数将使用文件流指针所包含的描述符，自动完成一个带缓冲的write/read操作，将数据发送到套接口缓冲区，或者从套接口缓冲区中读取数据，这样，可以不需要进行显示的write/read系统调用，如图11-4所示。</p>
<p>
<table cellpadding="0" cellspacing="0" align="left">
</table>
&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<br clear="ALL">
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3．面向记录的XDR</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 上面的两种XDR都是以流方式工作的，由于XDR和TCP都是流的抽象，所以XDR可以同TCP很好的结合，但是UDP提供的是面向记录的数据抽象，因此为了使XDR同UDP能够很好的结合，XDR库中还提供了面向记录的XDR抽象。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 总之，XDR标准中定义了同C语言中类&#20284;的数据类型，并提供了相应的转化函数，XDR流包含内存XDR流、I/O XDR流和具有记录定义能力的XDR。XDR的转化函数所做的操作决定于XDR流本身的性质，当XDR流是编码流时，转化函数进行编码的工作；如果XDR流是解码流时，转化函数进行解码操作。XDR标准是RPC远程过程调用的基础。</p>
<p>&nbsp;</p>
<p><strong>11.2 远程过程调用（RPC）的原理</strong></p>
<p>&nbsp;</p>
<p><strong>11.2.1 分布式数据处理方法</strong></p>
<p>&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在计算机网络中，数据可以分布式地存放，数据的存放地点和数据的处理地点可能不在同一主机上。一种方法是将数据从数据的存放主机发送到对数据进行处理的主机上，而后在数据处理主机上进行数据处理。这种方法在需要传输的数据量较小时性能较好，但是如果数据量很大，这种方式将消耗大量的网络资源。并且可能由于网络的不可靠性，间接地影响应用程序的不可靠性。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 另一种方法是前台的进程仅仅做一些同顾客相关的界面的处理，还有一些诸如输入数据的有效性检测等事务，而将有效的数据输入转化成请求，并将请求发送到数据处理主机上，数据处理主机对数据进行处理后将数据的处理结果发送回来。两种方法的工作过程如图11-5所示。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<br clear="ALL">
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RPC基于后一种方法。它希望达到的目的是将网络通信的功能和应用的需求分离开。由于通信协议的复杂性，因此它需要设计报文&#26684;式，指明进程收到每个报文后应当如何处理。协议需要严&#26684;的协议认证，以确保通信协议的可靠性。</p>
<p>&nbsp;</p>
<p><strong>11.2.2 RPC系统组成及特点</strong></p>
<p>&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在顾客服务员模型中，进程之间相互作用是由一个进程先向另一个进程发送一个报文请求服务，然后等待回答；服务进程接收一个请求，经过处理后发送回答。这样一种交互作用很象通常意义的过程调用。但是在计算机网络系统中，这种调用可能在不同的机器上执行，所以叫远程过程调用（remote procedure call）。</p>
<p>在进行远程过程调用时，调用过程暂停执行，将参数经由网络送至被调用者执行此过程调用，执行结束后将结果返回给调用者，调用者恢复执行。整个过程就象发生在本地一样。远程过程调用原语是在报文传递原语基础上产生的。把可靠的阻塞原语SEND和RECEICE结合起来成为SEND-GET，用于顾客进程向服务员进程发送一个请求，之后等待服务员进程的回答。GET-REQUEST用于服务员得到一个报文，报文告诉服务员要做的工作。当服务员完成该工作时，用原语SEND-REPLY发回一个回答报文。远程过程调用可以看作是由这些原语结合起来完成的过程，具有对用户更方便的句法。</p>
<p>远程过程调用是基于进程相互作用的顾客服务员模型之上的同步通信的一种形式。顾客为了得到一个服务员（Server）的某种服务（Service）的结果（result），可以使用下面的原语：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CALL(Server:…;Service:…; var result:…; var status:…; time-out:…);</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 其中status是调用执行情况，可能是成功（OK），或未执行（not-done），或者不能执行（absent）等等；time-out是一个参数，指定允许顾客可以等待的最长时间；status、result和参量均用数&#20540;传递。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 远程过程调用与报文传递方式相比有许多优点：语义清楚、简单、容易使用；对通信来说也非常简单，有较高的效率；有通用性，象在单机上计算时，过程就象是算法两个部分之间进行通信的最重要的机构一样。</p>
<p>远程过程调用的程序由五部分组成：用户程序、用户代理程序、RPC通信软件包、服务员代理程序和服务员程序，见图11-6。</p>
<p>
<table cellpadding="0" cellspacing="0" align="left">
</table>
&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<br clear="ALL">
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 通信程序包分成两部分，分别位于顾客机和服务员机。用户进行远程过程调用时，只需进行通常的本地调用，引起用户代理过程运行，后者将目标过程的说明和参数装入一个或几个调用包内，交给通信程序发送给被调用服务员。被调用服务员上的通信程序收到调用包后交给服务员代理程序，后者把参数取出后进行通常的本地调用。服务员完成这一调用，把结果返回给服务员代理程序进行打包，再交给通信程序发送给顾客机的通信程序。这是顾客机上的通信程序正等待接收这一结果包，然后把它交给用户代理程序拆包，把结果交给用户。在此期间，顾客进程暂停运行，等待返回结果。通信程序负责重发、确认、包的路径选择和数据加密等等。如果不考虑多机和通信失效，调用就好象用户直接调用服务员中的过程一样。事实上，如果服务员和顾客程序都在一个机器上，去掉代理程序仍能正常工作。</p>
<p>RPC实际上拓宽了“调用”。用户可以使用某些定义好的信息&#26684;式来保存被调用过程需要的参数，并在信息&#26684;式中说明应当如何去找到被调用者（通常是某种标志）。然后通过网络将信息报文发送到被调用者所在的机器，调用者等待被调用者发回调用结果。</p>
<p>在被调用者的那台机器上，应当有一个分派器，这个分派器知道它所控制的所有的远程过程。当它收到报文后，通过标志可以知道调用者希望调用哪个远程过程。然后，它从报文中取出被调用者需要的参数，并将参数传递给被调用者。</p>
<p>当被调用者被调用后，它在它的环境中运行，并将运行的结果写在信息&#26684;式中，最后通过网络将信息返回。</p>
<p>&nbsp;</p>
<p><strong>11.2.3 实现RPC要解决的问题</strong></p>
<p>&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 实现RPC要解决的一个问题是如何在报文中表示不同机型的参数和结果。不同型号的机器，其浮点数和负数的表示以及字节次序可能不同；各机器语言可能用不同的句法和不同的语义表示相&#20284;的数据结构；各机器语言可能支持不同的数据结构和过程接口。使用RPC进行通信时，必须在各不同机器之间进行转换工作。其转换工作量可能很大。对于有很多型号机器的系统，常使用一种标准&#26684;式，每种机型中的表示都转换成标准&#26684;式。但如果双方都使用同一种表示，这种转换就有些浪费。如果使用另一种方法，发送者使用自己的内部&#26684;式，让接收者转换成自己的内部表示，那么每种机器必须对其它种机器的每一种进行转换，当机种很多时工作量很大。而且当新机种加入时，很多现有的软件都必须加以补充。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 再一个问题是RPC透明性带来的服务员定位问题。例如在具有多个文件服务员的系统中，如果一个用户在某个服务员上创建一个文件，则通常希望以后的操作（例如写操作）都对该服务员上的那个文件进行。但使用RPC时，该用户只在其程序上设一个过程调用：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; write(FileDestriptor,BufferAddress, ByteCount);</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RPC设备试图对用户隐去所有的关于服务员定位的细节。而在这种情况下，这些细节却是十分重要的。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 还有关于广播通信问题。很多应用场合，例如确定某个进程或某种服务的位置，需要广播通信和组通信，即向所有的或若干个目的地而不只是一个目的地发送查询报文，并等待回答。RPC本身并不提供这种机制，语义也是完全不同的。因为RPC是一种同步通信，发送者必须等待每个接收者全部接收完毕。这不仅要等待很长时间，而且发送者并不一定知道共有多少个接收者接收并处理完毕的时间。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 还有可靠性语义问题。在计算机网络系统中，RPC并不能总是得到正确的回答，因为通信双方（顾客和服务员）都可能失效，通信线路也可能失效。顾客在向服务员发出一个RPC后，如果由于服务员或信道的故障未得到响应，一定时间后重发RPC；当服务员工作正常而只是顾客未收到回答时，服务员可能重复执行RPC操作；如果顾客在发出RPC后出现故障，而服务员继续执行这一RPC，则成为“孤儿”，顾客恢复后又可能重发这一RPC。从而服务员再次执行这一RPC。</p>
<p>在实际应用场合中，RPC的重复执行有时无害，有时是不允许的。例如顾客要求服务员读取某个文件，即使服务员在故障前后执行两次也没什么关系，这叫作重复等效（idempotent）的操作。但是如果一个用户要求从某个银行帐户向另一个帐户转移一笔钱的操作，则要求准确地执行一次，不能执行多次或者不执行。工厂自动生产过程中某些开关的控制要求恰好执行一次RPC，否则会出现故障。所以，发生RPC的多次执行的系统并不总是符合实际应用的需求。因此必须区别不同情况的RPC。RPC可能执行：</p>
<p>恰好一次（Exactly-Once）：每次调用时只精确地执行一次，具有和本地过程调用相同的语义；</p>
<p>至少一次（At-Least-Once）：用户代理重复发出RPC一直到服务员至少执行了一次；</p>
<p>最多一次（At-Most-Once）：通信双方及信道无故障时恰好执行一次并返回一次结果；如果发现服务员崩溃，用户代理将放弃并返回一个错误码，不进行重发。在此情况下，顾客知道操作可能执行0次或一次，不会再多。进一步的恢复由顾客负责。</p>
<p>多次中最后一次语义（Last-of-Many-Call）。这种语义要求给一个调用的每次请求一个顺序号。顾客只接受最近一次请求的返回&#20540;。</p>
<p>等效语义（Idempotent）。这种语义可以使用有状态服务员，也可以使用无状态服务员。在有多个顾客请求远程过程调用的情况下，这种语义保证不会对结果构成不利影响。对于有状态服务员，服务员所保持的状态不会被多个顾客的请求所破坏。</p>
<p>为了使RPC具有“恰好执行一次”或“最多执行一次”的语义。可在顾客的请求报文中设置顺序号，它应与返回结果报文中的顺序号一致。所有重发的报文包含相同的顺序号。服务员拒绝执行具有相同顺序号的请求，或以前的顺序号的请求。为了解决“孤儿”问题，服务员应能检测“孤儿”的产生，并在接受新的RPC之前退回到初始状态（不执行那个RPC操作）。</p>
<p>&nbsp;</p>
<p><strong>11.3 RPC的实现</strong></p>
<p>&nbsp;</p>
<p><strong>11.3.1 本地函数调用的过程</strong></p>
<p>&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 本地的函数调用，通常是将函数的传入参数压进函数栈，然后将函数的返回地址压入函数栈中，最后在函数栈为函数的局部变量分配空间，并将程序计数器（PC）指向被调用的函数的入口地址（即调用函数在正文段中的位置），接着开始调用函数。函数调用的栈结构如图11-7所示。</p>
<p>
<table cellpadding="0" cellspacing="0" align="left">
</table>
&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<br clear="ALL">
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在函数调用结束后将函数的局部变量弹出栈，并用函数的返回地址设置PC，而后程序将控制权返回到调用者。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 如果从较高的抽象层来考虑函数调用，就可以发现调用的关键步骤：</p>
<p>1．&nbsp;将被调用函数需要的参数准备好，并通过某种方式使被调用函数可以访问到。在本地函数调用中，它通过函数栈来实现。</p>
<p>2．&nbsp;必须包含函数的返回信息，在被调用函数结束后，可以将控制权重新交给调用者。在本地函数调用中，这一点通过指明函数的返回地址来实现。</p>
<p>3．&nbsp;能够确定被调用者的位置，也就是说，调用者需要通过某种方式说明被调用者的位置。在本地函数调用中，这一点通过将PC指针指向被调用函数的入口地址来实现。</p>
<p>4．&nbsp;必须为被调用函数创建它可以运行的环境，例如函数的需要访问的数据和变量，以及函数的代码等是函数可以访问到的。在本地函数调用中，这一点是这样实现的：被调用函数的局部变量在函数栈中分配，而其它需要的数据可以共享进程中数据（如果具有权限）。</p>
<p>经过上面的抽象，可以发现只要满足这4点要求，“调用”就可以实现。而这4点要求其实与具体实现无关。本地过程调用只是上面4点原则的一个具体实现。如果实现了一种新的方式，则一种新的调用就产生了。</p>
<p>因此，“调用”的概念可以进一步拓宽，本地调用只是“调用”的一种具体实现形式。用户只要准备好被调用者需要的参数，然后找到它，为被调用者创建好运行的环境，然后运行它，最后通过已经说明了的返回方式将控制权移交，将返回参数正确传递回来，这就完成了一个“调用”。至于数据应当以什么方式存放，数据应当怎么传送给被调用者，被调用者应当如何识别等，这些都是具体的实现细节的问题。</p>
<p>&nbsp;</p>
<p><strong>11.3.2 远程过程的标识</strong></p>
<p>&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RPC的实现也贯穿前面介绍的4个调用的原则。RPC的具体实现就是对4个原则的实现。远程过程的标识实际上就是引导如何能够找到远程过程。通常将一组相关的远程调用编写在一个程序中，然后通过一个分派器来管理它们。所以，标志一个远程调用过程需要（程序号、过程号），程序号是这组远程调用过程所在程序的名称，过程号是具体的过程在程序中的索引号。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 由于程序可能会不断地升级，所以还可以在标识中加入一个过程的版本号，这样做有两点好处：</p>
<p>1．&nbsp;当远程过程的版本升级时，应用程序仅仅需要改变调用的远程过程的版本号，就可以使用新的版本来工作。应用程序的改变非常小。</p>
<p>2．&nbsp;有的应用程序可能需要使用旧版本的远程过程调用来工作，如果在过程标识中加入版本号，则多个版本的远程过程可以同时并存。这样，旧版本的应用程序不会因为远程调用过程的版本升级而失效。</p>
<p>这样，远程调用过程的完整标识如下：</p>
<p>（程序号，远程调用过程的版本号，远程过程的序号）</p>
<p>在ONC RPC的标准中指出：在某个机器上执行的每个远程程序都必须分配一个唯一的32比特整数，调用者通过这个整数来标识这个远程程序。所谓程序名，就是这里所说的32比特整数。</p>
<p>为了确保不同的组织所定义的程序号不会冲突，ONC RPC将程序号的集合分成8组，供不同的组织使用。Sun公司管理其中的第一组标识，它允许任何人申请一个标准的RPC程序号。Sun在它所管理的标志中分配了一些标准的程序号，如表11-3所示。</p>
<p>&nbsp;</p>
<p align="center"><strong>表11-3 标准的程序号</strong></p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top">
<p align="center">程序名称</p>
</td>
<td valign="top">
<p align="center">程序号</p>
</td>
<td valign="top">
<p align="center">程序用途</p>
</td>
</tr>
<tr>
<td valign="top">
<p align="center">portmap</p>
</td>
<td valign="top">
<p align="center">100000</p>
</td>
<td valign="top">
<p align="center">端口映射器</p>
</td>
</tr>
<tr>
<td valign="top">
<p align="center">nfs</p>
</td>
<td valign="top">
<p align="center">100003</p>
</td>
<td valign="top">
<p align="center">网络文件系统</p>
</td>
</tr>
<tr>
<td valign="top">
<p align="center">rusersd</p>
</td>
<td valign="top">
<p align="center">100002</p>
</td>
<td valign="top">
<p align="center">远程用户</p>
</td>
</tr>
<tr>
<td valign="top">
<p align="center">Ypserv</p>
</td>
<td valign="top">
<p align="center">100004</p>
</td>
<td valign="top">
<p align="center">NIS网络信息系统</p>
</td>
</tr>
<tr>
<td valign="top">
<p align="center">mountd</p>
</td>
<td valign="top">
<p align="center">100005</p>
</td>
<td valign="top">
<p align="center">Mount, showmount</p>
</td>
</tr>
<tr>
<td valign="top">
<p align="center">etherstatd</p>
</td>
<td valign="top">
<p align="center">100010</p>
</td>
<td valign="top">
<p align="center">以太网统计信息</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>远程过程的具体描述如下：</p>
<p>programRMESGPROG {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*nameof remote program*/</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; version RMESGVERS&nbsp; { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*versionof program*/</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int INIT(void) = 1; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*first procedure in theprogram*/</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int ADDMESG(string)=2;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*second procedure*/</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int DELMESG(string)= 3;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; string LOOKMESG(int)= 4;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } =2; /*程序的版本号*/</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } = 0x30091000; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*程序唯一的程序号*/</p>
<p>&nbsp;</p>
<p><strong>11.3.3 端口的动态映射</strong></p>
<p>&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 由于一台机器上可能同时运行多个远程程序，所以每个远程程序将使用不同的传输层端口。而调用远程程序的应用并不知道它希望调用的远程程序具体使用哪个端口。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 由于给远程程序的程序号是32比特整数，而传输层使用的端口是16比特整数，因此不能将一个远程调用唯一地映射到一个传输层端口上。即使能够做到这样的映射，那也将浪费大量的传输层端口资源。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 某个远程程序运行的端口不是直接提供的，它将由操作系统根据当时传输层端口的使用情况来动态分配。而真正使用固定端口的是端口映射器。而在远程程序提供服务之前，它将向端口映射器注册自己，使端口映射器知道它是谁，它将使用什么端口，具体工作情况如图11-8所示。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<br clear="ALL">
<p>所有应用程序希望调用远程程序时，都先向端口映射器发出请求，询问具体的远程程序使用的端口号。端口映射器维持一张表，表中保存本机运行的远程程序和该远程程序使用的端口号。当它收到请求后，将查表来获取端口信息，并返回给发出请求的应用程序。然后应用程序将向具体的远程程序发起调用请求，具体工作情况如图11-9所示。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<br clear="ALL">
<p><strong>11.3.4 RPC报文</strong></p>
<p>&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RPC使用XDR语言来定义应用的报文，这样可以为应用提供更大的灵活性。</p>
<p>1．&nbsp;RPC报文的类型</p>
<p>使用XDR定义的RPC报文类型如下：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enum msg_type {&nbsp; /* RPC 报文的类型*/</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CALL = 0;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; REPLY = 1;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };</p>
<p>RPC报文的类型只有两种：RPCCALL和 RPC REPLY；分别用于远程调用和远程调用结果的返回。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2．RPC报文的&#26684;式</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RPC报文&#26684;式使用XDR语言定义如下：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; structrpc_msg {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsignedint mesgid;&nbsp; /*使用mesgid来匹配CALL和REPLY报文*/</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unionswitch(msg_type mesgt) {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; caseCALL:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call_body&nbsp; cbody;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; caseREPLY:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rply_bodyrbody;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }body;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 上面的语句声明了一个RPC报文&#26684;式，报文中的mesgid用于将调用和调用的返回进行匹配，因为一个应用可能会调用多个远程过程，那么需要一个机制将调用报文和调用结果报文对应起来。报文根据mesgt的&#20540;来区分不同的报文体。如果mesgt的&#20540;为CALL，也就是调用RPC报文，则RPC报文使用CALL报文体；如果mesgt的&#20540;为REPLY，也就是返回RPC报文，则使用REPLY报文体。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3．CALL报文体</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 根据前面的原则，CALL报文体中的内容包含远程程序的程序号、远程过程在程序中的过程号、版本信息、调用过程需要的参数。RPC CALL报文体定义如下：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; structcall_body {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsignedint rpcvers;&nbsp;&nbsp;&nbsp; /*RPC的版本*/</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsignedint rprog;&nbsp;&nbsp;&nbsp;&nbsp; /*远程程序的程序号*/</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsignedint rprogvers;&nbsp; /*远程程序的版本号*/</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsignedint rproc;&nbsp;&nbsp;&nbsp;&nbsp; /*远程过程的过程号*/</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; opaque_authcred;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*鉴别信息*/</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; opaque_authverf;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*鉴别的确证*/</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*ARGS*/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*过程的参数*/</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }；</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RPC报文为了网络安全而增加了鉴别信息，一个RPC CALL报文的具体形式如图11-10所示。</p>
<p>
<table cellpadding="0" cellspacing="0" align="left">
</table>
&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<br clear="ALL">
<p><strong>11.3.5 RPC开发工具</strong></p>
<p>&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 由于ONC RPC协议规程非常复杂，所以虽然可以直接使用报文实现远程过程调用，但是这样做需要耗费大量的时间和精力。因此，系统提供了专门用于开发的工具。这些工具主要包括：</p>
<p>1．&nbsp;XDR库函数，用于将各种数据结构从本机的表示转化成XDR的标准表示方式，不需要程序员来实现比较复杂的转化工作。</p>
<p>2．&nbsp;RPC运行时库函数（runtime library），这些库函数将具体实现RPC报文的形成和发送以及其它细节。</p>
<p>顾客端实现：在顾客端向端口映射器发送请求，并从端口映射器中接收回答；形成CALL报文，并向真正的远程程序发送调用请求，接收来自服务器的调用结果。服务器端实现：在服务器提供服务前向端口映射器注册自己的实际端口；将一个调用分派到具体的调用程序中的一个调用过程。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 实际上它们将实现同RPC相关的大部分工作，程序员使用这些工具可以快速地进行RPC的应用开发。</p>
<p>3．&nbsp;一些程序的自动生成工具，它产生一个构件RPC分布式程序所需要的许多C文件，这些程序主要是屏蔽底层通信对应用的影响。</p>
<p>&nbsp;</p>
<p><strong>11.3.6 RPC设计的原则</strong></p>
<p><strong>&nbsp;</strong></p>
<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </strong>由于RPC调用实际上是实现前面说明的4个原则，所以在RPC设计中，也应当将这4个原则进一步具体化成设计的原则：</p>
<p>1．&nbsp;&nbsp;&nbsp;由于RPC通过网络将被调用过程需要的各种参数进行传递，因此虽然RPC可以传递十分复杂的数据结构，例如链表等，但是这将消耗大量的系统和网络资源。所以应当将RPC调用的接口尽量设计成需要传递的参数较少，且传递的数据结构较简单。例如，在传递多个参数时，可以将它们定义在一个结构中，然后传递结构，这样既有利于程序的可读性，也有利于提高程序的效率。</p>
<p>2．&nbsp;&nbsp;&nbsp;RPC并没有指定使用的传输层端口，并且TCP和UDP都可以使用。当用户使用UDP协议来构建程序时，需要注意UDP协议的不可靠性，对于远程过程的一次调用，将可能导致RPC过程被调用的次数不确定。</p>
<p>在使用UDP协议通信时，一个RPC请求报文可能丢失，可能会丢失后重传，所以当一个应用进程收到RPC的回应时，RPC可能被调用了一次或者多次。而当一个应用进程没有收到回应报文时，RPC可能被调用了0次或者多次。由于回应的报文也可能丢失，所以在使用UDP协议实现RPC时，用户应当充分考虑这些问题。</p>
<p>3．&nbsp;&nbsp;&nbsp;ONC RPC规定：在给定的时刻，一个远程程序中最多可以有一个远程过程被调用，也就是说，在一个给定的程序中，RPC将保证过程调用是互斥的，这一点对于应用端是十分重要的。</p>
<p>4．&nbsp;&nbsp;&nbsp;由于远程过程是在远程的机器上运行，所以一定要保证过程中的语句是适合它所在的运行环境。例如printf语句，由于printf语句希望输入来自于同用户相关的终端，而不是RPC过程所运行的环境；还有对本地系统I/O和文件的访问语句，也不应当出现在远程过程中。</p>
<p>总之，RPC的思想来源于本地过程调用，两者都遵守相同的调用原则，只是实现的手段不同。在构造RPC应用时，首先象编写普通的应用那样进行需求分析，这使得用户不会将注意力过早地放在复杂的通信协议上；而后将应用划分为两部分，分别放在顾客端和提供RPC服务的一端。进行划分时，需要尽量的遵循上面的原则，包括在两端传递的参数应当尽量简单，RPC端必须能满足调用所需要的环境等等。</p>
<p>用户可以使用系统提供的RPC开发工具加快开发的速度，而直接使用RPC报文的方式来进行应用开发，效率将会很低。</p>
<p>RPC同时支持TCP和UDP协议。对于使用UDP协议的RPC应用，由于使用UDP协议的RPC是不可靠的，因此必须使顾客端的程序能够满足“至多被调用了一次”的语义。</p>
<p>&nbsp;</p>
<p><strong>11.4 SUN RPC</strong></p>
<p>&nbsp;</p>
<p>第一个RPC软件包是1985年发表的，它是SUN OPEN NETWORK COMPUTING (ONC) RPC，一般称它为SUNRPC。它最初是在SUN OS上实现的，现在也在Solaris操作系统上实现了。SUN RPC支持最多一次的调用语义和等效调用语义。除此之外，它还支持广播RPC和无响应（no-response or batching）RPC。无响应RPC不需要返回&#20540;，并常用于修改记录。SUN RPC对参数数目进行了限制，它只允许两个参数，一个是输入参数，一个是输出参数。但是C语言支持结构数据类型，可以将多个参数集合到一个数据结构中作为一个参数传递给远程过程。SUNRPC在三个层次上支持认证，最高层次的认证称为安全RPC并使用DES加密技术。</p>
<p>我们以计算一个数的平方为例来说明怎样实现一个RPC应用程序。在这个例子中，顾客给出一个整数作为参数调用服务员上的过程，服务员上的过程计算该数的平方，并将结果返回给顾客。实现这个远程过程调用应用的整个过程包括如下步骤。</p>
<p>（1）编写一个RPC说明文件square.x。RPC说明文件名的后缀为.x，它说明服务员能执行哪些过程，使用哪些参数。square.x文件如下：</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top">
<p>1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct square_in {&nbsp;&nbsp;&nbsp;&nbsp; /* input parameter */</p>
<p>2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long arg1;</p>
<p>3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };</p>
<p>4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct square_out {&nbsp;&nbsp;&nbsp;&nbsp; /* output parameter */</p>
<p>5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long res1;</p>
<p>6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };</p>
<p>7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; program SQUARE_PROG {</p>
<p>8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;version SQUARE_VERS {</p>
<p>9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;square_out SQUAREPROC(square_in)=1; /* 过程号=1 */</p>
<p>10&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;}=1;&nbsp;&nbsp;&nbsp;&nbsp; /* 版本号=1 */</p>
<p>11&nbsp;&nbsp;&nbsp;&nbsp; }=0x31230000;</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>此文件包含如下内容：</p>
<p><strong>定义参数和返回&#20540;</strong>。文件的1—6行定义了两个结构，一个是参数，另一个是返回&#20540;。</p>
<p><strong>定义程序、过程和版本</strong>。7—11行用于定义程序、过程和版本，RPC程序名为SQUARE_PROG，这个程序有一个版本SQUARE_VERS，该版本中只有一个过程。这个过程名为SQUAREPROC，它的参数的类型为struct square_in，它的返回&#20540;的类型为struct square_out。过程号被赋&#20540;为1，版本号也被赋&#20540;为1。程序号为32位，这里用8位16进制数表示。</p>
<p>这个文件经过rpcgen编译程序编译后可以生成4个文件：square.h、square_clnt.c、square_xdr.c、square_svc.c。</p>
<p>（2）编写一个顾客程序，该程序调用远程过程。该例子的顾客程序源文件为client.c，如下所示：</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top">
<p>1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include “unpipc.h”&nbsp;&nbsp; /*our header*/</p>
<p>2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include “square.h”&nbsp;&nbsp; /*generated by rpcgen*/</p>
<p>3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int</p>
<p>4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; main(int argc, char **argv)</p>
<p>5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</p>
<p>6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;CLIENT *cl;</p>
<p>7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;square_in in;</p>
<p>8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;square_out *outp;</p>
<p>9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;if(argc!=3)</p>
<p>10&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err_quit(“usage: client &lt;hostname&gt; &lt;integer-value”);</p>
<p>11&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;cl=clnt_creat(argv[1],SQUARE_PROG,SQUARE_VERS, “tcp”);</p>
<p>12&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;in.arg1=atoll(argv[2]);</p>
<p>13&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;if((outp=squareproc_1(&amp;in,cl))==NULL)</p>
<p>14&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err_quit(“%s”,clnt_sperror(cl,argv[1]));</p>
<p>15&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;printf(“result:%ld\n”,outp-&gt;res1);</p>
<p>16&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;exit(0);</p>
<p>17&nbsp;&nbsp;&nbsp;&nbsp; }</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>此文件包含如下内容：</p>
<p><strong>包含有rpcgen产生的头部文件</strong>。在本例中这个头部文件为square.h，如程序中的第2行。</p>
<p><strong>说明一个顾客句柄变量。</strong>如程序中第6行的变量cl。</p>
<p><strong>获得一个顾客句柄。</strong>调用函数clnt_create，如果调用成功，该函数返回一个顾客句柄，如程序中的第11行。同标准的I/O文件句柄类&#20284;，用户不必关心顾客句柄指针所指定的具体内容是什么，它由RPC运行时系统所保持，它是某种结构类型的信息。函数clnt_create的第一个参数是运行服务员程序的机器的名字或IP地址；第二个参数是服务员程序的程序号码；第三个参数是该程序的版本号，这两个参数是RPC说明文件中所定义的（本例在square.x中定义）；第四个参数是所选择的协议，通常是TCP或UDP协议。</p>
<p><strong>调用远程过程和打印结果。</strong>这一部分由程序的12行到15行完成。第一个是一个指向输入结构的指针，第二个参数是这个顾客的句柄。返回&#20540;是一个指向结果结构的指针。输入结构的存储空间由用户程序分配，而结果结构的存储空间是有RPC运行时系统分配的。在square.x说明文件中，把要调用的过程命名为SQUAREPROC，但是在顾客程序中则调用过程squareproc_1，对应的规则是将square.x中的过程名由大写改为小写，再加上一个下划线，后跟一个版本号数字。</p>
<p>（3）编写一个服务员程序。服务员的主程序由rpcgen自动生成，只需要编写服务过程程序。如下所示是过程程序文件server.c:</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top">
<p>1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include “unpipc.h”</p>
<p>2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include “square.h”</p>
<p>3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; square_out *</p>
<p>4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; squareproc_1_svc(square_in *inp,struct svc_req *rqstp)</p>
<p>5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</p>
<p>6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;static square_out out;</p>
<p>7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;oui.res1=inp-&gt;arg1*inp-&gt;arg1;</p>
<p>8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;return(&amp;out);</p>
<p>9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>此文件包含的头部文件同顾客程序文件包含的头部文件一样，此外还包含如下内容：</p>
<p><strong>过程名及参数。</strong>服务员过程名是在版本号后再加上_svc，过程第一个参数是指向输入结构的一个指针，第二个参数也是一个指向结构的指针，这个结构由RPC运行时系统传递，它包含调用请求的相关信息。如程序中的3行和4行。</p>
<p><strong>执行和返回。</strong>取出输入参数并计算它的平方。结果存放在一个结构中，结构的地址是过程的返回&#20540;。由于是从一个函数里返回一个变量的地址，所以该变量要说明为static。如程序中的6到8行。</p>
<p>（4）第四步，编译。有如下编译任务：</p>
<p>使用rpcgen对RPC说明文件进行编译。</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top">
<p>Solaris% rpcgen –C square.x</p>
</td>
</tr>
</tbody>
</table>
<p>通过编译生成4个文件：square.h、square_clnt.c、square_xdr.c、square_svc.c。</p>
<p>用cc编译生成顾客程序client。</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top">
<p>Solaris% cc –o client client.c square_clnt.c square_xdr.c libunpipc.a -lnsl</p>
</td>
</tr>
</tbody>
</table>
<p>用cc编译生成服务员程序server。</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top">
<p>Solaris% cc –o server server.c square_svc.c square_xdr.c libunpipc.a -lnsl</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>（5）第五步，执行程序。在服务员机上执行server程序，在顾客机上执行client程序。</p>
<p>当顾客程序和服务员程序在两个不同的系统上实现的话，一些文件如本例中的square.h和square_xdr.c需要共享或拷贝到不同的机器上，同顾客和服务员程序一起在不同的机器上编译。</p>
<p>图11-11描述了上述例子的实现过程，图中阴影部分是由用户编写的。</p>
<p>
<table cellpadding="0" cellspacing="0" align="left">
</table>
&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<br clear="ALL">
<p align="center"><strong>图11-11 建立SUN RPC顾客/服务员的过程</strong></p>
<p>&nbsp;</p>
<p>想详细了解SUN RPC请参见[STEVENS，1999]，该书对SUN RPC有非常详细的介绍。</p>
<p>&nbsp;</p>
<p><strong>11.5 加密技术</strong></p>
<p>&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp; 在计算机网络系统中的保护和安全有以下三个方面：</p>
<p>1． 数据加密：这个问题已经成为世界上许多国家计算机安全工作的重点，主要研究对数据加密的算法、算法实现的效率等问题。</p>
<p>2． 计算机网络的安全保密：计算机网络的目的是资源共享，同时也是分布计算系统、网&#26684;系统的基础平台，但网络容易产生不安全和失密问题。系统可以采用多级安全控制，包括使用可信赖的计算机系统，主机将保密的数据完全隔离。一个非常方便并且行之有效的方法是采用加密技术，实现用户到用户之间的加密，确保数据在网络传输过程中（特别是通信系统中）不丢失和被窜改。</p>
<p>3． 访问控制：象多用户单机系统那样，规定什么人可以访问系统的什么数据，得到何种服务，并对用户进行身份鉴别，对他们的访问权限加以限制（授权）。保护的对象可以是数据、程序、计算机性能、存储空间、存储介质或外部设备，这种保护称为对这些对象的访问控制。由于广泛使用网络和数据库系统，机器不仅要识别用户或者其进程是否合法，而且需要双方互相鉴别身份，有时甚至需要多方的鉴别。口令文件本身也需要保密。现代网络系统常采用多种方法进行用户身份鉴别，除了口令外还可以使用磁卡、指纹、签名、确认用户机器位置等。更严&#26684;的鉴别系统不仅在用户登录时进行鉴别，而且在整个运行期间随时限制访问。一般来说，使用硬件和固件做的鉴别系统不易受到攻击，而且不易出错。</p>
<p>可以把上述三个问题归并成两个：一个是加密技术，包括对数据及通信系统的加密；另一个是访问控制。加密技术不仅用于保护通信，也用于保护鉴别报文和访问控制。</p>
<p>为了传输敏感信息，如军事或金融数据，系统必须能够保证保密性。但是，微波、卫星以及各式电缆上传输的信息都很容易被截取。实际上，任何系统都不可能完全防止未经授权的用户对传输介质进行非法访问。</p>
<p>在实际系统中，比较实际的保护信息的方法是对信息加以改变，使得只有经过授权的用户才能够理解它，未经授权的用户即使得到它，也不能理解它。这种保护信息的方法称为对信息的加密和解密。加密意味着发送者将信息从最初的&#26684;式改变为另一种&#26684;式，将最终不可阅读的消息通过网络发送出去。解密是加密的相反过程，它将消息变换回原来的&#26684;式。图11-12显示了加密和解密的基本过程。</p>
<p>
<table cellpadding="0" cellspacing="0" align="left">
</table>
<br clear="ALL">
</p>
<p align="center"><strong>图11-12加密和解密的过程</strong></p>
<p>&nbsp;</p>
<p>加密和解密的方法分为两种类型：传统方法和公开密钥方法。</p>
<p><strong>&nbsp;</strong></p>
<p><strong>11.5.1传统加密方法</strong></p>
<p><strong>&nbsp;</strong></p>
<p><strong>11.5.1.1单密钥系统加密模型</strong></p>
<p>&nbsp;</p>
<p>传统的单密钥加密系统的加密模型如图11-13所示。A处待加密的明文x，它被一个以密钥k为参数的加密函数E变换成密文y=E(k,x)，通过网络传送到B处，在B处，密文y被一个以密钥k为参数的解密函数D变换成明文x=D(k,y)。</p>
<p align="center">
<table cellpadding="0" cellspacing="0" align="left">
</table>
<br clear="ALL">
<strong></strong></p>
<p align="center"><strong>图11-13单密钥系统加密模型</strong></p>
<p align="center"><strong>&nbsp;</strong></p>
<p>加密函数必须与解密函数配对使用，以便恢复原文。非法用户想要弄懂密文，必须知道密钥和解密函数，只知道其中一个是无法将密文转换为明文的。对于接收者B来说，由于它确信只有发送者A才知道如何将消息按它们之间约定的方法加密，非法用户冒充A发送来的消息经过解密变换后得到的是毫无意义的信息。因此，凡经解密后有明确意义的消息肯定是由A发来的。B在收到A发来的消息后，也用保密方式给A发送一个应答，表示收到。这样，A和B之间就实现了保密通信。</p>
<p>通常密钥是由简单的字符串组成，它选择很多可能加密方式中的一种。只要有必要，可以经常改变密钥。加密和解密函数指出一种加密和解密的方法。为了使保密有效，&#20284;乎应该尽可能把所有的加密和解密算法的全部细节保密，但是，使用一段时间之后，难免会泄密。为了安全起见，加密和解密算法应该经常更换，可是，能够经得起攻击的过硬算法并不是很容易寻找和设计的，经常更换加密和解密算法是不现实的，因此才使用密钥。加密和解密算法可以长时间使用，但是密钥应该经常更换。</p>
<p>传统的加密方法有两种：替换法和位置变换法。</p>
<p>&nbsp;</p>
<p><strong>11.5.1.2替换法</strong></p>
<p>&nbsp;</p>
<p>替换法在很久以前就开始使用了。在开始的时候，加密是通过使用被称为单字母替换的办法来实现的：在这种加密方法中，每个字符都被另一个字符所代替。这种加密方法称为恺撒密码，因为它最初被恺撒使用。</p>
<p>更安全的字符替换方法是多字母替换。这里，我们仍然使用一个字符替换另一个字符，但是在这种方法中，同样的原文字符是用不同的密文字符替换的；替换不仅取决于原文的字符，也取决于字符在文中的位置。例如，消息GOOD MORNING中的三个O可以被三个不同的密码字符所代替。</p>
<p>&nbsp;</p>
<p><strong>11.5.1.3位置交换法</strong></p>
<p>&nbsp;</p>
<p>在这种方法中，字符将保持它们在原文中的&#26684;式，但是它们的位置将被改变来创建密文。这种类型的加密用下面的方法非常有效地加以实现，将文本组织成一个二维表&#26684;，然后根据一个密钥将列重新组织，这个密钥指出了用哪一列替换哪一列。</p>
<p>例如下列明文：pleasegive me the books, when you come up next.</p>
<p>使用一个不重复出现字母的短语MEGABUCK作为密钥，将明文各自母对准此密钥各字母排列，形成8列，同时给每列一个编号，编号按对应的密钥字母在字母表中出现的先后顺序给出。</p>
<table border="1" cellspacing="0" cellpadding="0" width="314">
<tbody>
<tr>
<td valign="top">
<p align="center">M</p>
</td>
<td valign="top">
<p align="center">E</p>
</td>
<td valign="top">
<p align="center">G</p>
</td>
<td valign="top">
<p align="center">A</p>
</td>
<td valign="top">
<p align="center">B</p>
</td>
<td valign="top">
<p align="center">U</p>
</td>
<td valign="top">
<p align="center">C</p>
</td>
<td valign="top">
<p align="center">K</p>
</td>
</tr>
<tr>
<td valign="top">
<p align="center">7</p>
</td>
<td valign="top">
<p align="center">4</p>
</td>
<td valign="top">
<p align="center">5</p>
</td>
<td valign="top">
<p align="center">1</p>
</td>
<td valign="top">
<p align="center">2</p>
</td>
<td valign="top">
<p align="center">8</p>
</td>
<td valign="top">
<p align="center">3</p>
</td>
<td valign="top">
<p align="center">6</p>
</td>
</tr>
<tr>
<td valign="top">
<p align="center">p</p>
</td>
<td valign="top">
<p align="center">l</p>
</td>
<td valign="top">
<p align="center">e</p>
</td>
<td valign="top">
<p align="center">a</p>
</td>
<td valign="top">
<p align="center">s</p>
</td>
<td valign="top">
<p align="center">e</p>
</td>
<td valign="top">
<p align="center">&nbsp;</p>
</td>
<td valign="top">
<p align="center">g</p>
</td>
</tr>
<tr>
<td valign="top">
<p align="center">i</p>
</td>
<td valign="top">
<p align="center">v</p>
</td>
<td valign="top">
<p align="center">e</p>
</td>
<td valign="top">
<p align="center">&nbsp;</p>
</td>
<td valign="top">
<p align="center">m</p>
</td>
<td valign="top">
<p align="center">e</p>
</td>
<td valign="top">
<p align="center">&nbsp;</p>
</td>
<td valign="top">
<p align="center">t</p>
</td>
</tr>
<tr>
<td valign="top">
<p align="center">h</p>
</td>
<td valign="top">
<p align="center">e</p>
</td>
<td valign="top">
<p align="center">&nbsp;</p>
</td>
<td valign="top">
<p align="center">b</p>
</td>
<td valign="top">
<p align="center">o</p>
</td>
<td valign="top">
<p align="center">o</p>
</td>
<td valign="top">
<p align="center">k</p>
</td>
<td valign="top">
<p align="center">s</p>
</td>
</tr>
<tr>
<td valign="top">
<p align="center">,</p>
</td>
<td valign="top">
<p align="center">&nbsp;</p>
</td>
<td valign="top">
<p align="center">w</p>
</td>
<td valign="top">
<p align="center">h</p>
</td>
<td valign="top">
<p align="center">e</p>
</td>
<td valign="top">
<p align="center">n</p>
</td>
<td valign="top">
<p align="center">&nbsp;</p>
</td>
<td valign="top">
<p align="center">y</p>
</td>
</tr>
<tr>
<td valign="top">
<p align="center">o</p>
</td>
<td valign="top">
<p align="center">u</p>
</td>
<td valign="top">
<p align="center">&nbsp;</p>
</td>
<td valign="top">
<p align="center">c</p>
</td>
<td valign="top">
<p align="center">o</p>
</td>
<td valign="top">
<p align="center">m</p>
</td>
<td valign="top">
<p align="center">e</p>
</td>
<td valign="top">
<p align="center">&nbsp;</p>
</td>
</tr>
<tr>
<td valign="top">
<p align="center">u</p>
</td>
<td valign="top">
<p align="center">p</p>
</td>
<td valign="top">
<p align="center">&nbsp;</p>
</td>
<td valign="top">
<p align="center">n</p>
</td>
<td valign="top">
<p align="center">e</p>
</td>
<td valign="top">
<p align="center">x</p>
</td>
<td valign="top">
<p align="center">t</p>
</td>
<td valign="top">
<p align="center">.</p>
</td>
</tr>
</tbody>
</table>
<p>然后从小号列到大列，每列从上到下，把明文字母排列即得密文：</p>
<p>a bhcnsmoeoe&nbsp; k etlveupee w&nbsp; gtsy .pih,oueeonmx</p>
<p><strong>&nbsp;</strong></p>
<p><strong>11.5.1.4DES加密</strong></p>
<p>&nbsp;</p>
<p>上面提到的方法都是很少使用的。现在的传统加密方法都是基于比特而不是字符的。在比特级别的技术中，数据首先是划分为比特块，然后通过替换、位置变换、交换、异或、循环移位等方法进行改变。</p>
<p>比特级别加密的一个例子是数据加密标准(DES)。DES是由IBM公司制定的，被美国政府接受成为非军事和非保密的加密标准。算法使用64比特的原文和56比特的密钥，原文经过19个不同而复杂的过程来产生一个64比特的密文。</p>
<p>
<table cellpadding="0" cellspacing="0">
</table>
<br clear="ALL">
图11-14显示了DES的流程图。第一个和最后两个步骤相对简单，而步骤2到步骤17非常复杂，每一个步骤都由位置替换、替换、交换、异或和循环移位组合的多个子步骤组成。它的复杂性表现在两个方面：第一，尽管步骤2到步骤17是相同的，但是所使用的密钥是不同的，虽然它们是从同一个密钥继承来的。第二，前一个步骤的输出是后一个步骤的输入。</p>
<p>&nbsp;</p>
<p align="center"><strong>图11-14&nbsp; DES加密过程</strong></p>
<p><strong>&nbsp;</strong></p>
<p><strong>11.5.1.5密钥的分配</strong></p>
<p>&nbsp;</p>
<p>如何把解密密钥告诉接收者又不让他人知道，特别是在地理上分散的网络环境中，由人工传送密钥是很不方便的，例如，银行系统可能有成百上千个分支机构，并且可能经常更换密钥，由人工传送密钥很困难。这就提出了如何通过系统本身传送密钥的问题，问题在于这种传送必须是保密的。</p>
<p>现在我们就讨论这个问题。设两个用户要进行对话，对话之前要商定一个对话密钥，由于它们之间没有一个对话密钥，密钥的传送是不能用明文的形式传送的，所以需要一个双方都信任的第三者帮助他们完成密钥的分配，将这个第三者叫做网络安全中心(NSC)。现在假定用户A和用户B均已经和NSC建立了保密的通信信道，使用的密钥分别为k<sub>a</sub>和k<sub>b</sub>，A用k<sub>a</sub>和NSC进行保密通信，B用k<sub>b</sub>和NSC进行保密通信。A和B要进行保密通信，必须向NSC申请一个对话密钥K<sub>s</sub>，假设A是对话的发起者，那么A先向NSC申请一个对话密钥K<sub>s</sub>，NSC将K<sub>s</sub>以密文的形式E(k<sub>a</sub>,k<sub>s</sub>)和E(k<sub>b</sub>,k<sub>s</sub>)分别传送给A和B。密码可能含有其它数据，例如，消息的序号与时间。A和B解密得到k<sub>s</sub>，对话结束后消除它，NSC也不保留k<sub>s</sub>的副本。</p>
<p>NSC向A和B传送密钥K<sub>s</sub>的方法有两种，如图11-15(a)和图11-15(b)所示。</p>
<p>图11-15(a)的方法存在一个问题：如果A是对话的发起者，A要向B发送一个消息M，那么接收者B应该先从NSC那里获得密钥E(k<sub>b</sub>,k<sub>s</sub>)，然后从A那里获得消息E(k<sub>s</sub>,M)，这样B才能解密获得M。但是B有可能先得到加密的消息，后得到密钥，从而不能对消息解密。图11-15(b)的方法则比较方便：NSC先把E(k<sub>a</sub>,k<sub>s</sub>)和E(k<sub>b</sub>,k<sub>s</sub>)传送给A，再由A把E(k<sub>b</sub>,k<sub>s</sub>)传送给B，A和B都得到密钥k<sub>s</sub>后，A再向B发送消息。</p>
<p>&nbsp;</p>
<p align="center">
<table cellpadding="0" cellspacing="0">
</table>
<br clear="ALL">
<strong>图11-15 密钥的分配</strong></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><strong>11.5.2公开密钥加密方法</strong></p>
<p>&nbsp;</p>
<p><strong>11.5.2.1公开密钥系统加密模型</strong></p>
<p>&nbsp;</p>
<p>在传统的加密方法中，密钥的分配需要NSC，并且它已经跟通信双方A和B分别建立了保密通信的条件下才可实现。那么分属于不同的组织机构的两个用户，它们之间没有一个NSC，这样的用户怎样进行保密通信呢？</p>
<p>在传统的加密系统中只使用一个密钥，它既是加密密钥，同时也是解密密钥，因此密钥必须保密。所以传统的加密系统又称为对称加密系统或单密钥加密系统。如果使用不保密的加密密钥，则不必用保密信道来传送加密密钥。这样的加密系统称为非对称加密系统或公开密钥加密系统。这种加密思想是Diffie和Hellman在1976年提出的，这一思想使人们对加密系统有了新的认识。主要思想是，加密算法E和解密算法D无法保持秘密，不如干脆公开，但是使用两个密钥：加密密钥K<sub>e</sub>和解密密钥K<sub>d</sub>。加密密钥是不保密的，谁都可以使用，所以叫做公开密钥；解密密钥是保密的，只有接收密文的一方才知道，所以叫做专用密钥或保密密钥。选择某种类型的算法E和算法D，使得局外人即使知道了加密密钥K<sub>e</sub>，也推算不出来解密密钥K<sub>d</sub>。图11-16描述了公开密钥系统的加密模型。</p>
<p>在图11-16中，A有两个密钥：加密密钥K<sub>eA</sub>，这个密钥是公开的，B如果要向A发送保密报文，可用此密钥对报文加密；A还有一个解密密钥K<sub>dA</sub>，此密钥是保密的，除A之外，其它任何人都不知道，A用此密钥解密B发送来的保密报文。如图11-16(b)所示。</p>
<p>同样，B也有两个密钥：加密密钥K<sub>eB</sub>，这个密钥是公开的，A如果要向B发送保密报文，可用此密钥对报文加密；B还有一个解密密钥K<sub>dB</sub>，此密钥是保密的，除B之外，其它任何人都不知道，B用此密钥解密A发送来的保密报文。如图11-16(a)所示。</p>
<p>采用这种方法，所有网络用户登录时应该公布其加密密钥和加密函数，让所有人知道。这种方法使得密钥的分配工作大大简化。其缺点是加密和解密算法都很复杂，相当耗费时间和主存空间。算法的选择很困难，从1976年到现在，实用的算法很少。</p>
<p align="center">
<table cellpadding="0" cellspacing="0">
</table>
<br clear="ALL">
<strong>图11-16 公开密钥加密模型</strong></p>
<p align="center"><strong>&nbsp;</strong></p>
<p>&nbsp;</p>
<p><strong>11.5.2.2RSA加密</strong></p>
<p>&nbsp;</p>
<p>RSA加密技术是一种公开密钥加密技术，它的名字来自于最初的三个发明者(Rivest,Shamir, Adleman)。下面我们简要的介绍如何使用这种方法。</p>
<p>首先计算出一些参数：</p>
<p>1． 选择两个，p和q。</p>
<p>2． 计算n=p×q和z=(p-1) ×(q-1)。</p>
<p>3． 选择一个与z互质的数d。</p>
<p>4． 找出e，使得e×d=1 mod z。</p>
<p>确定公开密钥和保密密钥：公开密钥由(e,n)构成，保密密钥由(d,n)构成。</p>
<p>加密时可以把明文看成一个比特串，把明文划分成大小为k比特的块，每块可以看作是一个正整数m，其中0≤m&lt;n，所以块的大小k应该满足：2<sup>k</sup>&lt;n。</p>
<p>加密的过程非常简单：设X是要加密的明文信息，计算Y=X<sup>e</sup>(mod n)，则Y就是加密后得到的密文。</p>
<p>解密的过程也非常简单：设Y是要解密的密文信息，计算X=Y<sup>d</sup>(mod n)，则X就是解密后得到的明文。</p>
<p>算法的安全性：此算法的安全性建立在难于对大数进行分解的基础上。如果破译者能够对公开的n作因子分解，那么就能够找出p和q，并从中得到z。如果知道了z和e，就能够用欧几里德算法很容易地求出d。可是，对于一个很大的数n，对它做因子分解是极其困难的问题，也就是说，很难从n求出p和q。</p>
<p>根据Rivest及其同事们的研究，如果使用最好的算法，在指令时间为1us的计算机上对200位的数分解因子需要40亿年的时间，对500位的数分解因子需要10<sup>25</sup>年。</p>
<p>我们用表10-3的例子来说明如何对明文“SUZANNE”进行加密。在此例子中我们只考虑英文大写字母的加密，我们可以对英文字母A~Z按顺序编码为1~26。在该例子中，我们选择p=3，q=11，得到n=33，z=(p-1)×(q-1)=2×10=20。由于7和20互为质数，故可以设d=7。对于所选的d=7，解方程7e=1(mod 20)，可以得到e=3。</p>
<p>在我们的例子中，由于所选的p和q太小，破译当然很容易，我们的例子只是用来说明此算法的原理。同时，也由于所选的p和q太小，所以每个明文块所对应的数&#20540;要小于33(p×q=33)，所以每个明文块只能包含一个字符。</p>
<p>&nbsp;</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td width="252" colspan="4" valign="top">
<p align="center">加密</p>
</td>
<td width="238" colspan="3" valign="top">
<p align="center">解密</p>
</td>
</tr>
<tr>
<td width="91" colspan="2" valign="top">
<p align="center">明文(X)</p>
</td>
<td rowspan="2" valign="top">
<p align="center">X<sup>3</sup></p>
</td>
<td valign="top">
<p align="center">密文(Y)</p>
</td>
<td rowspan="2" valign="top">
<p align="center">Y<sup>7</sup></p>
</td>
<td rowspan="2" valign="top">
<p align="center">Y<sup>7</sup>(mod 33)</p>
</td>
<td rowspan="2" valign="top">
<p align="center">符号</p>
</td>
</tr>
<tr>
<td valign="top">
<p align="center">符号</p>
</td>
<td valign="top">
<p align="center">数&#20540;</p>
</td>
<td valign="top">
<p align="center">X<sup>3</sup>(mod 33)</p>
</td>
</tr>
<tr>
<td valign="top">
<p align="center">S</p>
</td>
<td valign="top">
<p align="center">19</p>
</td>
<td valign="top">
<p align="center">6859</p>
</td>
<td valign="top">
<p align="center">28</p>
</td>
<td valign="top">
<p align="center">13492928512</p>
</td>
<td valign="top">
<p align="center">19</p>
</td>
<td valign="top">
<p align="center">S</p>
</td>
</tr>
<tr>
<td valign="top">
<p align="center">U</p>
</td>
<td valign="top">
<p align="center">21</p>
</td>
<td valign="top">
<p align="center">9261</p>
</td>
<td valign="top">
<p align="center">21</p>
</td>
<td valign="top">
<p align="center">1801088541</p>
</td>
<td valign="top">
<p align="center">21</p>
</td>
<td valign="top">
<p align="center">U</p>
</td>
</tr>
<tr>
<td valign="top">
<p align="center">Z</p>
</td>
<td valign="top">
<p align="center">26</p>
</td>
<td valign="top">
<p align="center">17576</p>
</td>
<td valign="top">
<p align="center">20</p>
</td>
<td valign="top">
<p align="center">1280000000</p>
</td>
<td valign="top">
<p align="center">26</p>
</td>
<td valign="top">
<p align="center">Z</p>
</td>
</tr>
<tr>
<td valign="top">
<p align="center">A</p>
</td>
<td valign="top">
<p align="center">1</p>
</td>
<td valign="top">
<p align="center">1</p>
</td>
<td valign="top">
<p align="center">1</p>
</td>
<td valign="top">
<p align="center">1</p>
</td>
<td valign="top">
<p align="center">1</p>
</td>
<td valign="top">
<p align="center">A</p>
</td>
</tr>
<tr>
<td valign="top">
<p align="center">N</p>
</td>
<td valign="top">
<p align="center">14</p>
</td>
<td valign="top">
<p align="center">2744</p>
</td>
<td valign="top">
<p align="center">5</p>
</td>
<td valign="top">
<p align="center">78125</p>
</td>
<td valign="top">
<p align="center">14</p>
</td>
<td valign="top">
<p align="center">N</p>
</td>
</tr>
<tr>
<td valign="top">
<p align="center">N</p>
</td>
<td valign="top">
<p align="center">14</p>
</td>
<td valign="top">
<p align="center">2744</p>
</td>
<td valign="top">
<p align="center">5</p>
</td>
<td valign="top">
<p align="center">78125</p>
</td>
<td valign="top">
<p align="center">14</p>
</td>
<td valign="top">
<p align="center">N</p>
</td>
</tr>
<tr>
<td valign="top">
<p align="center">E</p>
</td>
<td valign="top">
<p align="center">5</p>
</td>
<td valign="top">
<p align="center">125</p>
</td>
<td valign="top">
<p align="center">26</p>
</td>
<td valign="top">
<p align="center">8031810176</p>
</td>
<td valign="top">
<p align="center">5</p>
</td>
<td valign="top">
<p align="center">E</p>
</td>
</tr>
</tbody>
</table>
<p align="center">&nbsp;</p>
<p>&nbsp;</p>
<p><strong>11.5.2.3认证</strong></p>
<p>&nbsp;</p>
<p>认证意味着确认发送者的身份。换句话说，一种认证技术需要确认一条消息是来自一个确认的发送者而不是一个冒充者。认证常通过数字签名的方式来实现。</p>
<p>在日常生活中很多场合需要签名原本文件。例如，为了从你的银行账户中提取大笔现金，你首先到银行填写一张取款单，银行需要你签署这张单子，同时保留签署的单子作为纪录。假如你日后说你从来没有提取过这样金额的现金，银行就可以拿出你的签名，证明你确实提取过。在网络交易中，虽然你不能签署单子，但是，你可以在发送数据的同时创建一个等价的数字签名。</p>
<p>实现数字签名，要解决两个问题：第一，接收者能验证所要求的发送者的身份；第二，发送者在发送已经签名的报文后不能否认。</p>
<p>加密技术不仅能够用于保密，而且还能够用于鉴别身份，即能够实现数字签名。</p>
<p>&nbsp;</p>
<p><strong>11.5.2.4公开密钥加密技术实现数字签名</strong></p>
<p><strong>&nbsp;</strong></p>
<p>使用公开密钥加密技术实现数字签名要求加密函数E和解密函数D满足下列条件：</p>
<p align="center">E(D(P))=P， 当然同时还有D(E(P))=P</p>
<p>也就是E和D可以互换。</p>
<p>现在，假定A向B发送一个签名报文P。A的公开密钥为K<sub>eA</sub>，保密密钥为K<sub>dA</sub>。B的公开密钥为K<sub>eB</sub>，保密密钥为K<sub>dB</sub>。</p>
<p>
<table cellpadding="0" cellspacing="0">
</table>
<br clear="ALL">
图11-17显示了使用公开密钥加密技术实现数字签名的过程。图中D<sub>A</sub>(P)=D(K<sub>dA</sub>,P)， E<sub>B</sub>(P)=E(K<sub>eB</sub>,P)。A先对报文P进行签名，形成P的签名形式D<sub>A</sub>(P)；然后对报文的签名形式进行加密，形成签名报文的加密形式E<sub>B</sub>(D<sub>A</sub>(P))；B收到这个加过密的签名报文后，使用自己的保密密钥解密，得到报文的签名形式D<sub>A</sub>(P)=D<sub>B</sub>(E<sub>B</sub>(D<sub>A</sub>(P)))；最后B对签名的报文进行验证并获得报文的明文形式P=E<sub>A</sub>(D<sub>A</sub>(P))，同时保留P的签名形式D<sub>A</sub>(P)。B知道这个签名报文确实是从A那儿发送来的，因为只能用A的公开密钥K<sub>eA</sub>才能解密成功。同时，A不能否认，因为B保留有P的签名形式D<sub>A</sub>(P)。</p>
<p align="center"><strong>图11-17使用公开密钥实现数字签名</strong></p>
<p>&nbsp;</p>
<p><strong>11.5.2.5单密钥加密技术实现数字签名</strong></p>
<p>&nbsp;</p>
<p>使用单密钥系统也可以实现数字签名，参见图11-18。</p>
<p align="center">
<table cellpadding="0" cellspacing="0">
</table>
<br clear="ALL">
<strong>图11-18 使用单密钥加密技术实现数字签名</strong></p>
<p>&nbsp;</p>
<p>为获得保密性，NSC有一个对任何人都保密的密钥X。由两个用户A和B，A和NSC之间用密钥K<sub>A</sub>进行保密通信，B和NSC之间用密钥K<sub>B</sub>进行保密通信。当A要发送一个报文P给B时，如果按照一下过程进行，B可以认定报文P是A向它发送的:</p>
<p>1． A向NSC发送加密报文，简记成K<sub>A</sub>(P)=E(K<sub>A</sub>,P)。</p>
<p>2． NSC解密K<sub>A</sub>(P)得到P，然后在报文P上加上发送者的名字A和日期D，产生一个新报文，用X加密这个新报文，得到的形式记为X(A&#43;D&#43;P)，然后送回给A。这里注意，NSC可以证明P确实是从A发送来的，因为只有A和NSC知道K<sub>A</sub>。A把X(A&#43;D&#43;P)送给B。</p>
<p>3． B保留一个X(A&#43;D&#43;P)的副本，然后把X(A&#43;D&#43;P)送给NSC，NSC将它换成K<sub>B</sub>(A&#43;D&#43;P)再送回给B。</p>
<p>4． B把NSC送来的K<sub>B</sub>(A&#43;D&#43;P)解密，得到A、D、P。</p>
<p>如果A否认曾向B发送P，则因B处有X(A&#43;D&#43;P)，这可由NSC解密得到A、D、P，而B不知道X，因此不会伪造。</p>
<p>&nbsp;</p>
<p><strong>11.5.2.6使用报文摘要的数字签名</strong></p>
<p>&nbsp;</p>
<p>由于加密整个报文很慢，下面的数字签名方案不要求加密整个报文。这种方案是基于单向散列(hash)函数的思想，该函数从一段很长的明文中计算出固定长度的比特串。这个散列函数通常被称为报文摘要(message digest)，它具有三个重要的属性：</p>
<p>1． 给出报文P就很容易计算出其报文摘要MD(P)。</p>
<p>2． 只给出MD(P)，几乎无法推导出P。</p>
<p>3． 无法生成这样的两条报文，它们具有同样的报文摘要。</p>
<p>要满足第三个条件，散列至少长128比特，或者更长。</p>
<p>从一段明文中计算出一段报文摘要要比用公开密钥算法加密整个明文要快得多。因此，报文摘要可以用来加速数字签名算法。</p>
<p>例如，A向B发送签名的报文P，A首先计算P的报文摘要MD(P)，A用自己的保密密钥对MD(P)进行加密以达到签名的目的，而不用对整个报文加密，所以签名的速度大大提高了。最后，A将报文摘要的签名形式D<sub>A</sub>(MD(P))连同明文P一起发送给B。B用A的公开密钥解密D<sub>A</sub>(MD(P))，从而得到MD(P)，如果非法用户改变了明文P，B计算MD(P)时就会发现这一点。由于解密的数据长度大大地缩短，所以认证的速度也大大提高了。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>

</div>



<!-- Baidu Button BEGIN -->
<div id="bdshare" class="bdshare_t bds_tools get-codes-bdshare" style="float: right;">
<a class="bds_qzone"></a>
<a class="bds_tsina"></a>
<a class="bds_tqq"></a>
<a class="bds_renren"></a>
<a class="bds_t163"></a>
<span class="bds_more">更多</span>
<a class="shareCount"></a>
</div>
<!-- Baidu Button END -->


<!--192.168.100.34-->
<ul class="article_next_prev">
            <li class="prev_article"><span  onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_shangyipian']);location.href='/neo_ustc/article/details/8743592';">上一篇</span><a href="/neo_ustc/article/details/8743592" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_shangyipian'])">COM笔记-接口</a></li>
            <li class="next_article"><span onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_xiayipian']);location.href='/neo_ustc/article/details/8754443';">下一篇</span><a href="/neo_ustc/article/details/8754443" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_xiayipian'])">二进制文件和文本文件的区别</a></li>
</ul>

<!-- Baidu Button BEGIN -->
<script type="text/javascript" id="bdshare_js" data="type=tools&amp;uid=1536434" ></script>
<script type="text/javascript" id="bdshell_js"></script>
<script type="text/javascript">
    document.getElementById("bdshell_js").src = "http://bdimg.share.baidu.com/static/js/shell_v2.js?cdnversion=" + Math.ceil(new Date()/3600000)
</script>
<!-- Baidu Button END -->

</div>
      <dl class="blog-associat-tag">
        <dt>主题推荐</dt>
        <dd>
                <a href="http://www.csdn.net/tag/sun公司" target="_blank" class="blog-tage-red" >sun公司</a> 
                <a href="http://www.csdn.net/tag/局部变量" target="_blank" class="blog-tage-red" >局部变量</a> 
                <a href="http://www.csdn.net/tag/开发工具" target="_blank" class="blog-tage-red" >开发工具</a> 
                <a href="http://www.csdn.net/tag/操作系统" target="_blank" class="blog-tage-red" >操作系统</a> 
                <a href="http://www.csdn.net/tag/网络安全" target="_blank" class="blog-tage-red" >网络安全</a> 
        </dd>
    </dl> 


<dl class="blog-ass-articl tracking-ad"  data-mod="popu_36" id="res-relatived"> 
     <dt><span>猜你在找</span></dt>    
</dl>

<script type="text/javascript">
    var searchtitletags = 'RPC远程过程调用' + ',' + 'sun公司,局部变量,开发工具,操作系统,网络安全';
    searchService({
        index: 'blog',
        query: searchtitletags,
        from: 10,
        size: 10,
        appendTo: '#res-relatived',
        url: 'recommend',
        his: 2,
        client: "blog_cf_enhance",
        tmpl: '<dd style="background:url(http://static.blog.csdn.net/skin/default/images/blog-dot-red3.gif) no-repeat 0 10px;"><a href="#{ url }" title="#{ title }" strategy="#{ strategy }">#{ title }</a></dd>'
    });

 </script>   

    <div id="ad_cen">
        <script type="text/javascript">            BAIDU_CLB_SLOT_ID = "117306";</script>
        <script type="text/javascript" src="http://cbjs.baidu.com/js/o.js"></script>
    </div>
    <script type="text/javascript">
        //new Ad(4, 'ad_cen');
    </script>
<div id="comment_title" class="panel_head">
    查看评论<a name="comments"></a></div>
<div id="comment_list">
</div>
<div id="comment_bar">
</div>
<div id="comment_form">
</div>
<div class="announce">
    * 以上用户言论只代表其个人观点，不代表CSDN网站的观点或立场<a name="reply"></a><a name="quote"></a></div>
<script type="text/javascript">
    var fileName = '8747003';
    var commentscount = 0;
    var islock = false
</script>
<script type="text/javascript" src="http://static.blog.csdn.net/scripts/comment.js"></script>
    <div id="ad_bot">
    </div>
    <script type="text/javascript">
    new Ad(5, 'ad_bot');
    </script>
<div id="report_dialog">
</div>

<div id="d-top"  style="bottom:60px;">
      

       <a id="quick-reply" class="btn btn-top q-reply" title="快速回复" style="display:none;">
            <img src="http://static.blog.csdn.net/images/blog-icon-reply.png" alt="快速回复">
        </a>    

    <a id="d-top-a" class="btn btn-top backtop"  style="display: none;" title="返回顶部" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_huidaodingbu'])" style="">         
         <img src="http://static.blog.csdn.net/images/top.png" alt="TOP">
    </a>
</div>
<script type="text/javascript">
    $(function ()
    {
        if($("#comment_content").length>0)
        {
            $("#quick-reply").show();

            $("#quick-reply").click(function(){
                setEditorFocus();
            });
        }       
     
        var d_top = $('#d-top-a');
        document.onscroll = function ()
        {
            var scrTop = (document.body.scrollTop || document.documentElement.scrollTop);
            if (scrTop > 500)
            {
                d_top.show();
            } else
            {
                d_top.hide();
            }
        }
        $('#d-top-a').click(function ()
        {
            scrollTo(0, 0);
            this.blur();
            return false;
        });
    });
  
</script>
<style type="text/css">
    .tag_list
    {
        background: none repeat scroll 0 0 #FFFFFF;
        border: 1px solid #D7CBC1;
        color: #000000;
        font-size: 12px;
        line-height: 20px;
        list-style: none outside none;
        margin: 10px 2% 0 1%;
        padding: 1px;
    }
    .tag_list h5
    {
        background: none repeat scroll 0 0 #E0DBD3;
        color: #47381C;
        font-size: 12px;
        height: 24px;
        line-height: 24px;
        padding: 0 5px;
        margin: 0;
    }
    .tag_list h5 a
    {
        color: #47381C;
    }
    .classify
    {
        margin: 10px 0;
        padding: 4px 12px 8px;
    }
    .classify a
    {
        margin-right: 20px;
        white-space: nowrap;
    }
</style>
<div class="tag_list">
    <h5>
        <a href="http://www.csdn.net/tag/" target="_blank">核心技术类目</a></h5>
    <div class="classify">
<a title="全部主题" href="http://www.csdn.net/tag" target="_blank" onclick="LogClickCount(this,336);">全部主题</a>
<a title="Java" href="http://www.csdn.net/tag/Java" target="_blank" onclick="LogClickCount(this,336);">Java</a>
<a title="VPN" href="http://www.csdn.net/tag/vpn" target="_blank" onclick="LogClickCount(this,336);">VPN</a>
<a title="Android" href="http://www.csdn.net/tag/android" target="_blank" onclick="LogClickCount(this,336);">Android</a>
<a title="iOS" href="http://www.csdn.net/tag/ios" target="_blank" onclick="LogClickCount(this,336);">iOS</a>
<a title="ERP" href="http://www.csdn.net/tag/erp" target="_blank" onclick="LogClickCount(this,336);">ERP</a>
<a title="IE10" href="http://www.csdn.net/tag/ie10" target="_blank" onclick="LogClickCount(this,336);">IE10</a>
<a title="Eclipse" href="http://www.csdn.net/tag/eclipse" target="_blank" onclick="LogClickCount(this,336);">Eclipse</a>
<a title="CRM" href="http://www.csdn.net/tag/crm" target="_blank" onclick="LogClickCount(this,336);">CRM</a>
<a title="JavaScript" href="http://www.csdn.net/tag/javascript" target="_blank" onclick="LogClickCount(this,336);">JavaScript</a>
<a title="Ubuntu" href="http://www.csdn.net/tag/ubuntu" target="_blank" onclick="LogClickCount(this,336);">Ubuntu</a>
<a title="NFC" href="http://www.csdn.net/tag/nfc" target="_blank" onclick="LogClickCount(this,336);">NFC</a>
<a title="WAP" href="http://www.csdn.net/tag/wap" target="_blank" onclick="LogClickCount(this,336);">WAP</a>
<a title="jQuery" href="http://www.csdn.net/tag/jquery" target="_blank" onclick="LogClickCount(this,336);">jQuery</a>
<a title="数据库" href="http://www.csdn.net/tag/数据库" target="_blank" onclick="LogClickCount(this,336);">数据库</a>
<a title="BI" href="http://www.csdn.net/tag/bi" target="_blank" onclick="LogClickCount(this,336);">BI</a>
<a title="HTML5" href="http://www.csdn.net/tag/html5" target="_blank" onclick="LogClickCount(this,336);">HTML5</a>
<a title="Spring" href="http://www.csdn.net/tag/spring" target="_blank" onclick="LogClickCount(this,336);">Spring</a>
<a title="Apache" href="http://www.csdn.net/tag/apache" target="_blank" onclick="LogClickCount(this,336);">Apache</a>
<a title="Hadoop" href="http://www.csdn.net/tag/hadoop" target="_blank" onclick="LogClickCount(this,336);">Hadoop</a>
<a title=".NET" href="http://www.csdn.net/tag/.net" target="_blank" onclick="LogClickCount(this,336);">.NET</a>
<a title="API" href="http://www.csdn.net/tag/api" target="_blank" onclick="LogClickCount(this,336);">API</a>
<a title="HTML" href="http://www.csdn.net/tag/html" target="_blank" onclick="LogClickCount(this,336);">HTML</a>
<a title="SDK" href="http://www.csdn.net/tag/sdk" target="_blank" onclick="LogClickCount(this,336);">SDK</a>
<a title="IIS" href="http://www.csdn.net/tag/iis" target="_blank" onclick="LogClickCount(this,336);">IIS</a>
<a title="Fedora" href="http://www.csdn.net/tag/fedora" target="_blank" onclick="LogClickCount(this,336);">Fedora</a>
<a title="XML" href="http://www.csdn.net/tag/xml" target="_blank" onclick="LogClickCount(this,336);">XML</a>
<a title="LBS" href="http://www.csdn.net/tag/lbs" target="_blank" onclick="LogClickCount(this,336);">LBS</a>
<a title="Unity" href="http://www.csdn.net/tag/unity" target="_blank" onclick="LogClickCount(this,336);">Unity</a>
<a title="Splashtop" href="http://www.csdn.net/tag/splashtop" target="_blank" onclick="LogClickCount(this,336);">Splashtop</a>
<a title="UML" href="http://www.csdn.net/tag/uml" target="_blank" onclick="LogClickCount(this,336);">UML</a>
<a title="components" href="http://www.csdn.net/tag/components" target="_blank" onclick="LogClickCount(this,336);">components</a>
<a title="Windows Mobile" href="http://www.csdn.net/tag/windowsmobile" target="_blank" onclick="LogClickCount(this,336);">Windows Mobile</a>
<a title="Rails" href="http://www.csdn.net/tag/rails" target="_blank" onclick="LogClickCount(this,336);">Rails</a>
<a title="QEMU" href="http://www.csdn.net/tag/qemu" target="_blank" onclick="LogClickCount(this,336);">QEMU</a>
<a title="KDE" href="http://www.csdn.net/tag/kde" target="_blank" onclick="LogClickCount(this,336);">KDE</a>
<a title="Cassandra" href="http://www.csdn.net/tag/cassandra" target="_blank" onclick="LogClickCount(this,336);">Cassandra</a>
<a title="CloudStack" href="http://www.csdn.net/tag/cloudstack" target="_blank" onclick="LogClickCount(this,336);">CloudStack</a>
<a title="FTC" href="http://www.csdn.net/tag/ftc" target="_blank" onclick="LogClickCount(this,336);">FTC</a>
<a title="coremail" href="http://www.csdn.net/tag/coremail" target="_blank" onclick="LogClickCount(this,336);">coremail</a>
<a title="OPhone " href="http://www.csdn.net/tag/ophone " target="_blank" onclick="LogClickCount(this,336);">OPhone </a>
<a title="CouchBase" href="http://www.csdn.net/tag/couchbase" target="_blank" onclick="LogClickCount(this,336);">CouchBase</a>
<a title="云计算" href="http://www.csdn.net/tag/云计算" target="_blank" onclick="LogClickCount(this,336);">云计算</a>
<a title="iOS6" href="http://www.csdn.net/tag/iOS6" target="_blank" onclick="LogClickCount(this,336);">iOS6</a>
<a title="Rackspace " href="http://www.csdn.net/tag/rackspace " target="_blank" onclick="LogClickCount(this,336);">Rackspace </a>
<a title="Web App" href="http://www.csdn.net/tag/webapp" target="_blank" onclick="LogClickCount(this,336);">Web App</a>
<a title="SpringSide" href="http://www.csdn.net/tag/springside" target="_blank" onclick="LogClickCount(this,336);">SpringSide</a>
<a title="Maemo" href="http://www.csdn.net/tag/maemo" target="_blank" onclick="LogClickCount(this,336);">Maemo</a>
<a title="Compuware" href="http://www.csdn.net/tag/compuware" target="_blank" onclick="LogClickCount(this,336);">Compuware</a>
<a title="大数据" href="http://www.csdn.net/tag/大数据" target="_blank" onclick="LogClickCount(this,336);">大数据</a>
<a title="aptech" href="http://www.csdn.net/tag/aptech" target="_blank" onclick="LogClickCount(this,336);">aptech</a>
<a title="Perl" href="http://www.csdn.net/tag/perl" target="_blank" onclick="LogClickCount(this,336);">Perl</a>
<a title="Tornado" href="http://www.csdn.net/tag/tornado" target="_blank" onclick="LogClickCount(this,336);">Tornado</a>
<a title="Ruby" href="http://www.csdn.net/tag/ruby" target="_blank" onclick="LogClickCount(this,336);">Ruby</a>
<a title="Hibernate" href="http://www.csdn.net/hibernate" target="_blank" onclick="LogClickCount(this,336);">Hibernate</a>
<a title="ThinkPHP" href="http://www.csdn.net/tag/thinkphp" target="_blank" onclick="LogClickCount(this,336);">ThinkPHP</a>
<a title="Spark" href="http://www.csdn.net/tag/spark" target="_blank" onclick="LogClickCount(this,336);">Spark</a>
<a title="HBase" href="http://www.csdn.net/tag/hbase" target="_blank" onclick="LogClickCount(this,336);">HBase</a>
<a title="Pure" href="http://www.csdn.net/tag/pure" target="_blank" onclick="LogClickCount(this,336);">Pure</a>
<a title="Solr" href="http://www.csdn.net/tag/solr" target="_blank" onclick="LogClickCount(this,336);">Solr</a>
<a title="Angular" href="http://www.csdn.net/tag/angular" target="_blank" onclick="LogClickCount(this,336);">Angular</a>
<a title="Cloud Foundry" href="http://www.csdn.net/tag/cloudfoundry" target="_blank" onclick="LogClickCount(this,336);">Cloud Foundry</a>
<a title="Redis" href="http://www.csdn.net/tag/redis" target="_blank" onclick="LogClickCount(this,336);">Redis</a>
<a title="Scala" href="http://www.csdn.net/tag/scala" target="_blank" onclick="LogClickCount(this,336);">Scala</a>
<a title="Django" href="http://www.csdn.net/tag/django" target="_blank" onclick="LogClickCount(this,336);">Django</a>
<a title="Bootstrap" href="http://www.csdn.net/tag/bootstrap" target="_blank" onclick="LogClickCount(this,336);">Bootstrap</a>
    </div>
</div>

                    <div class="clear">
                    </div>
                </div>
            </div>
            <div id="side">
    <div class="side">
<div id="panel_Profile" class="panel">
<ul class="panel_head"><span>个人资料</span></ul>
<ul class="panel_body profile">
<div id="blog_userface">
    <a href="http://my.csdn.net/Andeewu" target="_blank">
    <img src="http://avatar.csdn.net/5/5/A/1_andeewu.jpg" title="访问我的空间" style="max-width:90%"/>
    </a>
    <br />
    <span><a href="http://my.csdn.net/Andeewu" class="user_name" target="_blank">Andeewu</a></span>
</div>
<div class="interact">
<a href="javascript:void(0);" class="attent" id="span_add_follow" title="[加关注]" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_guanzhu'])"></a>
<a href="javascript:void(0);" class="letter" onclick="loginto(1)" title="[发私信]" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_sixin'])"></a>
</div>
<div id="blog_medal">
</div>
<ul id="blog_rank">
    <li>访问：<span>106606次</span></li>
    <li>积分：<span>2399分</span></li>
    <li>排名：<span>第4530名</span></li>
</ul>
<ul id="blog_statistics">
    <li>原创：<span>57篇</span></li>
    <li>转载：<span>415篇</span></li>
    <li>译文：<span>34篇</span></li>
    <li>评论：<span>11条</span></li>
</ul>
</ul>
</div>


<div class="panel" id="panel_Search">
    <ul class="panel_head"><span>文章搜索</span></ul>
    <ul class="panel_body">
        <form id="frmSearch" action="http://so.csdn.net/search" class="form_search" target="_blank">
        <span><input id="inputSearch" type="text" class="blogsearch" title="请输入关键字" /></span>
        <input id="btnSubmit" type="submit" value="搜索" title="search in blog" />
        <input type="hidden" name="q" id="inputQ" />
        <input type="hidden" name="t" value="blog" />
        <a id="btnSearchBlog" target="_blank"></a>
        </form>
    </ul>
</div><div id="panel_Category" class="panel">
<ul class="panel_head"><span>文章分类</span></ul>
<ul class="panel_body">
             <li>
                <a href="http://blog.csdn.net/neo_ustc/article/category/1205896" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">C/C++</a><span>(96)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/neo_ustc/article/category/1206016" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">Operator</a><span>(34)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/neo_ustc/article/category/1216796" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">求职笔试题</a><span>(3)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/neo_ustc/article/category/1218747" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">数据结构</a><span>(5)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/neo_ustc/article/category/1227111" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">操作系统</a><span>(6)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/neo_ustc/article/category/1228503" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">java与模式(OOD)</a><span>(5)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/neo_ustc/article/category/1231739" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">MFC</a><span>(18)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/neo_ustc/article/category/1273352" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">数据库</a><span>(10)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/neo_ustc/article/category/1282311" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">C#</a><span>(42)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/neo_ustc/article/category/1337591" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">COM</a><span>(38)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/neo_ustc/article/category/1398764" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">小品文</a><span>(2)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/neo_ustc/article/category/1400458" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">多线程</a><span>(7)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/neo_ustc/article/category/1400905" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">随笔</a><span>(23)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/neo_ustc/article/category/1409994" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">操作系统/Windows</a><span>(8)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/neo_ustc/article/category/1414117" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">STL</a><span>(5)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/neo_ustc/article/category/1435059" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">编程思想</a><span>(6)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/neo_ustc/article/category/1442209" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">简单的程序诠释C++ STL算法</a><span>(4)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/neo_ustc/article/category/1442249" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">COM学习笔记</a><span>(4)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/neo_ustc/article/category/1443967" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">UML</a><span>(11)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/neo_ustc/article/category/1457411" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">高质量的C++</a><span>(4)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/neo_ustc/article/category/1460039" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">C/C++内存布局</a><span>(24)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/neo_ustc/article/category/1460049" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">字符串</a><span>(2)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/neo_ustc/article/category/1477395" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">数据库</a><span>(0)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/neo_ustc/article/category/1495129" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">白话MSDN</a><span>(2)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/neo_ustc/article/category/1500997" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">设计模式</a><span>(25)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/neo_ustc/article/category/1560241" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">网络通信/流媒体</a><span>(4)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/neo_ustc/article/category/1616313" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">经典收藏</a><span>(13)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/neo_ustc/article/category/1722225" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">调试</a><span>(2)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/neo_ustc/article/category/1735913" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">SVN</a><span>(3)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/neo_ustc/article/category/1744469" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">Silverlight</a><span>(3)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/neo_ustc/article/category/1771303" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">架构 模型</a><span>(24)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/neo_ustc/article/category/1774685" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">MVC</a><span>(1)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/neo_ustc/article/category/1785879" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">深入浅出图解C#堆与栈 C# Heap(ing) VS St</a><span>(5)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/neo_ustc/article/category/1790509" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">QT学习笔记</a><span>(3)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/neo_ustc/article/category/1792615" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">Qt Model/View</a><span>(7)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/neo_ustc/article/category/1797731" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">计算机图形学</a><span>(11)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/neo_ustc/article/category/1806491" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">测试</a><span>(12)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/neo_ustc/article/category/1883269" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">项目管理</a><span>(0)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/neo_ustc/article/category/2000013" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">经典源码理解</a><span>(1)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/neo_ustc/article/category/2036405" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">单元测试</a><span>(13)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/neo_ustc/article/category/2133917" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">Linux系统编程</a><span>(1)</span>
            </li>
</ul>
</div><div id="panel_Archive" class="panel">
<ul class="panel_head"><span>文章存档</span></ul>
<ul class="panel_body">
<div id="archive_list">
<!--归档统计-->
<li><a href="http://blog.csdn.net/neo_ustc/article/month/2014/05">2014年05月</a><span>(2)</span></li><li><a href="http://blog.csdn.net/neo_ustc/article/month/2014/04">2014年04月</a><span>(1)</span></li><li><a href="http://blog.csdn.net/neo_ustc/article/month/2014/03">2014年03月</a><span>(16)</span></li><li><a href="http://blog.csdn.net/neo_ustc/article/month/2014/02">2014年02月</a><span>(2)</span></li><li><a href="http://blog.csdn.net/neo_ustc/article/month/2014/01">2014年01月</a><span>(21)</span></li><li><a href="http://blog.csdn.net/neo_ustc/article/month/2013/12">2013年12月</a><span>(77)</span></li><li><a href="http://blog.csdn.net/neo_ustc/article/month/2013/11">2013年11月</a><span>(56)</span></li><li><a href="http://blog.csdn.net/neo_ustc/article/month/2013/10">2013年10月</a><span>(14)</span></li><li><a href="http://blog.csdn.net/neo_ustc/article/month/2013/09">2013年09月</a><span>(17)</span></li><li><a href="http://blog.csdn.net/neo_ustc/article/month/2013/08">2013年08月</a><span>(26)</span></li><li><a href="http://blog.csdn.net/neo_ustc/article/month/2013/07">2013年07月</a><span>(32)</span></li><li><a href="http://blog.csdn.net/neo_ustc/article/month/2013/06">2013年06月</a><span>(38)</span></li><li><a href="http://blog.csdn.net/neo_ustc/article/month/2013/05">2013年05月</a><span>(23)</span></li><li><a href="http://blog.csdn.net/neo_ustc/article/month/2013/04">2013年04月</a><span>(47)</span></li><li><a href="http://blog.csdn.net/neo_ustc/article/month/2013/03">2013年03月</a><span>(38)</span></li><li><a href="http://blog.csdn.net/neo_ustc/article/month/2013/02">2013年02月</a><span>(4)</span></li><li><a href="http://blog.csdn.net/neo_ustc/article/month/2013/01">2013年01月</a><span>(3)</span></li><li><a href="http://blog.csdn.net/neo_ustc/article/month/2012/12">2012年12月</a><span>(1)</span></li><li><a href="http://blog.csdn.net/neo_ustc/article/month/2012/11">2012年11月</a><span>(5)</span></li><li><a href="http://blog.csdn.net/neo_ustc/article/month/2012/10">2012年10月</a><span>(6)</span></li><li><a href="http://blog.csdn.net/neo_ustc/article/month/2012/09">2012年09月</a><span>(12)</span></li><li><a href="http://blog.csdn.net/neo_ustc/article/month/2012/08">2012年08月</a><span>(25)</span></li><li><a href="http://blog.csdn.net/neo_ustc/article/month/2012/07">2012年07月</a><span>(18)</span></li><li><a href="http://blog.csdn.net/neo_ustc/article/month/2012/06">2012年06月</a><span>(4)</span></li><li><a href="http://blog.csdn.net/neo_ustc/article/month/2012/03">2012年03月</a><span>(11)</span></li><li><a href="http://blog.csdn.net/neo_ustc/article/month/2012/02">2012年02月</a><span>(7)</span></li>
</div>
</ul>
</div>
<div id="hotarticls" class="panel">
<ul class="panel_head">
    <span>       
阅读排行    </span>
</ul>

<ul class="panel_body itemlist">
<li>
<a href="/neo_ustc/article/details/7839356" title="全局变量和局部变量在内存里的区别">全局变量和局部变量在内存里的区别</a><span>(25046)</span>
</li>
<li>
<a href="/neo_ustc/article/details/7826407" title="函数的引用返回">函数的引用返回</a><span>(2927)</span>
</li>
<li>
<a href="/neo_ustc/article/details/7855336" title="c语言文件读写方式">c语言文件读写方式</a><span>(2302)</span>
</li>
<li>
<a href="/neo_ustc/article/details/7976993" title="OpenGL入门学习">OpenGL入门学习</a><span>(2230)</span>
</li>
<li>
<a href="/neo_ustc/article/details/7934907" title="MVC设计模式">MVC设计模式</a><span>(2109)</span>
</li>
<li>
<a href="/neo_ustc/article/details/7768284" title="从Trie树（字典树）谈到后缀树">从Trie树（字典树）谈到后缀树</a><span>(1751)</span>
</li>
<li>
<a href="/neo_ustc/article/details/7910304" title="网络资料总结的常用计算机公司笔试题目">网络资料总结的常用计算机公司笔试题目</a><span>(1187)</span>
</li>
<li>
<a href="/neo_ustc/article/details/7883636" title="C/C++笔试系列－－从一道IBM的笔试题看编码规范">C/C++笔试系列－－从一道IBM的笔试题看编码规范</a><span>(1000)</span>
</li>
<li>
<a href="/neo_ustc/article/details/7333064" title="面试题    设有n个人围坐一圈并按顺时针方向从1到n编号,从第s个人开始进行1到m的报数, 报数到第m个人, 此人出圈, 再从他的下一个人重新开始1到m的报数,如此进行下去直到所有的人都出圈为止。现">面试题    设有n个人围坐一圈并按顺时针方向从1到n编号,从第s个人开始进行1到m的报数, 报数到第m个人, 此人出圈, 再从他的下一个人重新开始1到m的报数,如此进行下去直到所有的人都出圈为止。现</a><span>(875)</span>
</li>
<li>
<a href="/neo_ustc/article/details/8286715" title="VS error">VS error</a><span>(839)</span>
</li>
</ul>
</div>
<div id="hotarticls2" class="panel">
<ul class="panel_head"><span>评论排行</span></ul>
<ul class="panel_body itemlist">
<li>
<a href="/neo_ustc/article/details/7855336" title="c语言文件读写方式">c语言文件读写方式</a><span>(2)</span>
</li>
<li>
<a href="/neo_ustc/article/details/11867875" title="PropertyGrid控件下拉列表">PropertyGrid控件下拉列表</a><span>(2)</span>
</li>
<li>
<a href="/neo_ustc/article/details/7826407" title="函数的引用返回">函数的引用返回</a><span>(1)</span>
</li>
<li>
<a href="/neo_ustc/article/details/7883636" title="C/C++笔试系列－－从一道IBM的笔试题看编码规范">C/C++笔试系列－－从一道IBM的笔试题看编码规范</a><span>(1)</span>
</li>
<li>
<a href="/neo_ustc/article/details/7825580" title="MFC之对话框（二）">MFC之对话框（二）</a><span>(1)</span>
</li>
<li>
<a href="/neo_ustc/article/details/17232767" title="Debug总结">Debug总结</a><span>(1)</span>
</li>
<li>
<a href="/neo_ustc/article/details/18105273" title="MVC架构模式">MVC架构模式</a><span>(1)</span>
</li>
<li>
<a href="/neo_ustc/article/details/7976993" title="OpenGL入门学习">OpenGL入门学习</a><span>(1)</span>
</li>
<li>
<a href="/neo_ustc/article/details/8855840" title="关于类成员变量为引用与指针的思考">关于类成员变量为引用与指针的思考</a><span>(1)</span>
</li>
<li>
<a href="/neo_ustc/article/details/14646085" title="SVN版本冲突解决详解">SVN版本冲突解决详解</a><span>(0)</span>
</li>
</ul>
</div>
<div id="homepageArticles" class="panel tracking-ad" data-mod="popu_4">
<ul class="panel_head"><span>推荐文章</span></ul>
<ul class="panel_body" id="ad_commend"></ul>
</div>
<script type="text/javascript">
 new Ad(12, 'ad_commend');
</script><div id="newcomments" class="panel">
<ul class="panel_head"><span>最新评论</span></ul>
<ul class="panel_body itemlist">
    <li>
   
         <a href="/neo_ustc/article/details/7826407#comments">函数的引用返回</a>
    <p style="margin:0px;"><a href="/qingfengxiu1985" class="user_name">qingfengxiu1985</a>:
没有图片或者图片看不到，不形象
    </p>
    </li>
    <li>
   
         <a href="/neo_ustc/article/details/18105273#comments">MVC架构模式</a>
    <p style="margin:0px;"><a href="/u012045597" class="user_name">u012045597</a>:
写得很细 , 赞一个
    </p>
    </li>
    <li>
   
         <a href="/neo_ustc/article/details/17232767#comments">Debug总结</a>
    <p style="margin:0px;"><a href="/u013061929" class="user_name">u013061929</a>:
问题5的ShiShiShuJu是一个指针变量么？如果是指针的话，不能用&amp;ShiShiShuJu去引用...
    </p>
    </li>
    <li>
   
         <a href="/neo_ustc/article/details/11867875#comments">PropertyGrid控件下拉列表</a>
    <p style="margin:0px;"><a href="/Andeewu" class="user_name">Andeewu</a>:
@yds_009:如：         public class FactoryNameListAt...
    </p>
    </li>
    <li>
   
         <a href="/neo_ustc/article/details/11867875#comments">PropertyGrid控件下拉列表</a>
    <p style="margin:0px;"><a href="/yds_009" class="user_name">yds_009</a>:
如果列表框中的是事先不知道的，要动态加载的，应该怎样写？
    </p>
    </li>
    <li>
   
         <a href="/neo_ustc/article/details/7883636#comments">C/C++笔试系列－－从一道IBM的笔试题看编码规范</a>
    <p style="margin:0px;"><a href="/u011602981" class="user_name">u011602981</a>:
谢谢楼主
    </p>
    </li>
    <li>
   
         <a href="/neo_ustc/article/details/8855840#comments">关于类成员变量为引用与指针的思考</a>
    <p style="margin:0px;"><a href="/David_xtd" class="user_name">David_xtd</a>:
楼主的结论有失偏颇，“而成员变量用指针时，如果你不重写拷贝构造函数与赋值运算符时，将出现内存泄露，因...
    </p>
    </li>
    <li>
   
         <a href="/neo_ustc/article/details/7855336#comments">c语言文件读写方式</a>
    <p style="margin:0px;"><a href="/ml0719787" class="user_name">ml0719787</a>:
thank you
    </p>
    </li>
    <li>
   
         <a href="/neo_ustc/article/details/7855336#comments">c语言文件读写方式</a>
    <p style="margin:0px;"><a href="/sun5smile" class="user_name">sun5smile</a>:
受用了，tks。
    </p>
    </li>
    <li>
   
         <a href="/neo_ustc/article/details/7825580#comments">MFC之对话框（二）</a>
    <p style="margin:0px;"><a href="/longwindshine" class="user_name">longwindshine</a>:
我是菜鸟啊，看不太懂，俺喜欢看图文并茂的
    </p>
    </li>
</ul>
</div>
    </div>
    <div class="clear">
    </div>
</div>

            <div class="clear">
            </div>
        </div>
        

<script type="text/javascript" src="http://static.blog.csdn.net/scripts/newblog.min.js"></script>
<script type="text/javascript" src="http://medal.blog.csdn.net/showblogmedal.ashx?blogid=1260987"></script>
<script type="text/javascript">
    document.write('<script type="text/javascript" src="http://csdnimg.cn/pubfooter/js/publib_footer.js?' + Math.floor(new Date() / 120000).toString(36) + '="></' + 'script>');
</script>
    <script type="text/javascript" src="http://passport.csdn.net/content/loginbox/login.js"></script>
<script type="text/javascript">document.write("<img src=http://counter.csdn.net/pv.aspx?id=24 border=0 width=0 height=0>");</script>
<script type="text/javascript" src="http://www.csdn.net/ui/scripts/Csdn/counter.js"></script>
<script type="text/javascript" src="http://ad.csdn.net/scripts/ad-blog.js"></script>
<script type="text/javascript" src="http://zz.csdn.net/js/count.js"></script>
<script type="text/javascript">
    $(function () {
        function __get_code_toolbar(snippet_id) {
            return $("<a href='https://code.csdn.net/snippets/"
                    + snippet_id
                    + "' target='_blank' title='在CODE上查看代码片' style='text-indent:0;'><img src='https://code.csdn.net/assets/CODE_ico.png' width=12 height=12 alt='在CODE上查看代码片' style='position:relative;top:1px;left:2px;'/></a>"
                    + "<a href='https://code.csdn.net/snippets/"
                    + snippet_id
                    + "/fork' target='_blank' title='派生到我的代码片'  style='text-indent:0;'><img src='https://code.csdn.net/assets/ico_fork.svg' width=12 height=12 alt='派生到我的代码片' style='position:relative;top:2px;left:2px;'/></a>");
        }
        
        $("[code_snippet_id]").each(function () {
            __s_id = $(this).attr("code_snippet_id");
            if (__s_id != null && __s_id != "" && __s_id != 0 && parseInt(__s_id) > 70020) {
                __code_tool = __get_code_toolbar(__s_id);
                $(this).prev().find(".tools").append(__code_tool);
            }
        });
    });
</script>

    </div>
      <!--new top-->
    
    <script id="csdn-toolbar-id" btnId="header_notice_num" wrapId="note1" count="5" subCount="5" type="text/javascript" src="http://static.csdn.net/public/common/toolbar/js/toolbar.js"></script>     <!--new top-->
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
     
    <html xmlns="http://www.w3.org/1999/xhtml">
    
<head>
    <title>LINUX网络编程的读书笔记 - ang639
        - 博客频道 - CSDN.NET</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="description" content="LINUX网络编程的读书笔记第一章文件系统和进程系统1．1文件系统的总体结构&#160;&#160;&#160;&#160;&#160;&#160; 从文件系统的实现角度来看，按层次可以分成应用程序、系统调用、文件子系统、高速缓冲、设备驱动和具体的存储设备等几个层次，如下图：&#160;&#160;&#160;&#160;&#160;&#160; 应用程序 系统调用接口 文件子系统 硬件存储设备 设备驱动程序 高速缓存 字符设备" />
    <script src="http://static.blog.csdn.net/scripts/jquery.js" type="text/javascript"></script>
    <script type="text/javascript" src="http://static.blog.csdn.net/scripts/ad.js?v=1.1"></script>
        <!--new top-->
               <link rel="stylesheet" href="http://static.csdn.net/public/common/toolbar/css/index.css">        <!--new top-->

    <link rel="Stylesheet" type="text/css" href="http://static.blog.csdn.net/skin/default/css/style.css?v=1.1" />
    <link id="RSSLink" title="RSS" type="application/rss+xml" rel="alternate" href="/anghlq/rss/list" />
    <link rel="shortcut icon" href="http://csdnimg.cn/public/favicon.ico" />
    <link type="text/css" rel="stylesheet" href="http://static.blog.csdn.net/scripts/SyntaxHighlighter/styles/default.css" />
 

</head>
<body>
    
   
      <!--new top-->
    <script id="toolbar-tpl-scriptId" fixed="true" prod="blog" skin="black" src="http://static.csdn.net/public/common/toolbar/js/html.js" type="text/javascript"></script>
     <!--new top-->
    <div id="container">
        <div id="header">
    <div class="header">
        <div id="blog_title">
            <h2>
                <a href="http://blog.csdn.net/anghlq">ang639</a></h2>
            <h3>宠辱不惊</h3>
            <div class="clear">
            </div>
        </div>
        <div class="clear">
        </div>
    </div>
</div>
<div id="navigator">
    <div class="navigator_bg">
    </div>
    <div class="navigator">
        <ul>
                <li id="btnContents"><a href="http://blog.csdn.net/anghlq?viewmode=contents"><span onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_mulu'])">
                    <img src="http://static.blog.csdn.net/images/ico_list.gif">目录视图</span></a></li>
                <li id="btnView"><a href="http://blog.csdn.net/anghlq?viewmode=list"><span onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_zhaiyao'])">
                    <img src="http://static.blog.csdn.net/images/ico_summary.gif">摘要视图</span></a></li>
                <li id="btnRss"><a href="http://blog.csdn.net/anghlq/rss/list"><span onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_RSS'])">
                    <img src="http://static.blog.csdn.net/images/ico_rss.gif">订阅</span></a></li>

            </ul>
    </div>
</div>
<script type="text/javascript">
    var username = "anghlq";
    var _blogger = username;
    var blog_address = "http://blog.csdn.net/anghlq";
    var static_host = "http://static.blog.csdn.net";
    var currentUserName = "";
</script>

        <div id="body">
            <div id="main">
                <div class="main">
<div class="notice tracking-ad" data-mod='popu_3' > 

<a href="http://blog.csdn.net/blogdevteam/article/details/25387451"target="_blank">
<font color=blue>有奖征资源，博文分享有内涵
</font></a>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

<a href="http://blog.csdn.net/blogdevteam/article/details/25400391"target="_blank">
<font color=red>4月推荐博文汇总 
</font></a>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

<a href="http://blog.csdn.net/csdnproduct/article/details/27504397"target="_blank">
<font color=blue>CSDN博客支持Windows Live Writer离线写博客啦
</font></a>

</div>                    <link href="http://static.blog.csdn.net/css/comment1.css" type="text/css" rel="stylesheet" />
<link href="http://static.blog.csdn.net/css/style1.css" type="text/css" rel="stylesheet" />
<script language='JavaScript' type='text/javascript' src='http://download.csdn.net/js/jquery.cookie.js'></script>
<script type="text/javascript" src="http://csdnimg.cn/rabbit/search-service/main.js"></script>
<div id="article_details" class="details">
    <div class="article_title">   
         <span class="ico ico_type_Repost"></span>


    <h1>
        <span class="link_title"><a href="/anghlq/article/details/5635674">
        LINUX网络编程的读书笔记
        </a></span>
    </h1>
</div>

    <div class="article_manage">
        <span class="link_categories">
        分类：
            <a href="/anghlq/article/category/239360" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_fenlei']);">程序设计</a> 
            <a href="/anghlq/article/category/252069" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_fenlei']);">C/C++</a> 
        </span>
    <span class="link_postdate">2010-05-31 09:36</span>
    <span class="link_view" title="阅读次数">979人阅读</span>
    <span class="link_comments" title="评论次数"><a href="#comments" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_pinglun'])">评论</a>(0)</span>
    <span class="link_collect"><a href="javascript:void(0);" onclick="javascript:_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_shoucang']);collectArticle('LINUX网络编程的读书笔记','5635674');return false;" title="收藏">收藏</a></span>
    <span class="link_report"><a href="#report"  onclick="javascript:_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_jubao']);report(5635674,2);return false;" title="举报">举报</a></span>
    
</div>
<div class="tag2box"><a href='http://www.csdn.net/tag/%e7%bd%91%e7%bb%9c' target=_blank onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_tag']);">网络</a><a href='http://www.csdn.net/tag/linux' target=_blank onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_tag']);">linux</a><a href='http://www.csdn.net/tag/%e7%bc%96%e7%a8%8b' target=_blank onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_tag']);">编程</a><a href='http://www.csdn.net/tag/%e8%af%bb%e4%b9%a6' target=_blank onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_tag']);">读书</a><a href='http://www.csdn.net/tag/struct' target=_blank onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_tag']);">struct</a><a href='http://www.csdn.net/tag/%e6%9c%8d%e5%8a%a1%e5%99%a8' target=_blank onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_tag']);">服务器</a></div>

    
<div id="article_content" class="article_content">

<table bgcolor="#ffffff" border="0" cellpadding="0" cellspacing="0" align="center" style="border-collapse:collapse; word-wrap:break-word; width:760px">
<tbody>
<tr>
<td align="center" height="30"><span style="color:#02368d; font-size:14pt"><strong>LINUX网络编程的读书笔记</strong></span></td>
</tr>
<tr>
<td align="center" height="9"><img src="http://blog.chinaunix.net/templates/default/images/right_line.gif" alt="" border="0" height="9" width="502"></td>
</tr>
<tr>
<td align="center">
<table border="0" cellpadding="0" cellspacing="0" style="border-collapse:collapse; word-wrap:break-word; width:740px">
<tbody>
<tr>
<td width="740">
<div id="art" style="margin:15px">
<div>第一章文件系统和进程系统<br>
1．1文件系统的总体结构<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 从文件系统的实现角度来看，按层次可以分成应用程序、系统调用、文件子系统、高速缓冲、设备驱动和具体的存储设备等几个层次，如下图：<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 应用程序 <br>
系统调用接口 <br>
文件子系统 <br>
硬件存储设备 <br>
设备驱动程序 <br>
高速缓存 <br>
字符设备 <br>
块设备 </div>
<div><br>
在UNIX系统中，程序不管核心按照什么样的&#26684;式来组织文件，只是把文件看作一个无&#26684;式的字节流来看待。对文件的存取语法是由系统定义的，数据的语义是由程序加上去的。<br>
应用进程通过系统调用来访问文件系统，分配给应用程序一个标准的通用接口, 便于屏蔽不同文件系统的差异。文件系统不能直接访问硬件设备，通过调用设备驱动进程来操作具体设备。对高速设备的访问，通常通过高速缓冲机制来提高设备和内存的数据交换。设备驱动进程用来屏蔽不同物理设备的操作差异。<br>
&nbsp;<br>
文件系统的总体结构是：引导块、超级块、索引节点表，数据区。<br>
·引导块在文件系统的最前面，它和操作系统引导有关。有且只有一个引导块有效。<br>
·超级块也叫管理块，存放文件系统的管理信息，如文件系统大小、空闲块大小、空闲块链表节点头等信息。<br>
·索引节点表，每个文件都对应着一个索引节点，里面反正用户的存取权限、信息等。通过路径访问文件，内核把文件路径经过转换映射到索引节点表中对应节点去。<br>
·数据区。文件系统实际存放数据的磁盘空间。<br>
·空闲数据块表。超级块中空间很小，所以把空闲数据块的信息写在数据区中。<br>
&nbsp;<br>
VFS(Virtual Filesystem Switch)<br>
LINUX通过虚拟文件系统转换来实现多文件系统的支持。LINUX把对文件操作的系统调用转为对不通过文件系统操作的子程序调用，这些子程序都针对具体文件系统而编写。虚拟文件系统不是真正的文件系统，而是一种映射机制来屏蔽下层的差异为上层提供方便。<br>
&nbsp;<br>
&nbsp;<br>
1．2 文件结构和目录结构<br>
LINUX中的每个文件都对应虚拟文件系统的一个索引节点，里面存放有直接或多级指针能够记录文件的数据，这样设计是为了存取大文件。<br>
&nbsp;<br>
目录也能抽象成文件，也通过索引节点表来描述，并且把目录表中的目录项存放在数据区中。目录表的基本构成单位是目录项，有“文件名－索引节点号”构成。文件节点索引表中并不包含文件名这个信息，文件名被填写在目录文件中。<br>
&nbsp;<br>
·硬连接和符号（软）连接的区别：<br>
硬连接能实现的功能符号连接都能实现。硬连接只能用在文件(非目录)和同一个文件系统，但是符号连接适用在目录，也适用在不同的文件系统间。但是符号连接比硬连接更消耗内核资源，因为符号连接的转换规则是在内核中实现的，而硬连接则直接指向索引节点。<br>
硬连接是文件名和索引节点的对应关系；符号连接是指向文件的路径<br>
&nbsp;<br>
·文件系统相关编程：<br>
从系统的实现角度来看，文件内在表示是唯一确定的索引节点。如果从编程角度来看，文件可以通过文件描述符和文件指针来表示。UNIX I/O库中有open,write,read,close,ioctl等系统调用来操作文件描述符。<br>
在C库函数中，有fopen, fprintf, fread, fwrite, fclose等文件操作函数对文件指针进行处理，它们是对系统调用的再次封装。<br>
&nbsp;<br>
从系统角度来说：文件句柄就是文件的一种标志，是文件描述符表中的索引号。进程的标志输入、输出和错误输出的文件描述符分别是0，1，2在unistd.h中将它们定义为STDIN_FILENO, STDOUT_FILENO和STDERR_FILENO。<br>
从C函数库角度来说：文件句柄是一个指向文件结构的指针。。进程的标志输入、输出和错误输出在stdio.h中被定义为stdin, stdout, stderr。可以使用系统调用fileno()将一个文件指针转为文件描述符。<br>
&nbsp;<br>
&nbsp;<br>
1.3 进程系统<br>
·程序并行执行中的问题：<br>
静态程序的概念不能很好描述并行环境下的规律，因此引入的进程的概念。单道程序设计中，环境是封闭的，资源总被独占；而在并行环境中由于封闭性和资源的独占性被破坏，这将导致很多问题。<br>
&nbsp;<br>
·进程和程序的区别：<br>
程序是指令和数据的集合，是一个静态文本，存放在一个普通的文件中，该文件在索引节点表中的文件标志为“可执行”。<br>
进程是程序在一个包括指令段、系统和用户数据的环境中，为了完成预定的任务而运行一次的过程。进程被撤销后就不再存在，而程序的文本依然留在系统中。<br>
&nbsp;<br>
·进程的物理表示：<br>
为了描述动态变化的进程，我们把进程静态的分为3个部分：程序部分、数据部分、进程控制块——统一称为进程映像。<br>
&nbsp;<br>
进程的程序部分可以被多个程序所共享，共享代码段应该被编写成纯代码puer code，即该程序段的功能不随着调用的程序不同而存在差异。<br>
程序段被执行的数据区和工作单元，当执行的不是共享代码段时，数据的一部分就被放入数据空间。<br>
每个进程都有一个进程控制块PCB，用来跟踪并记录动态变化的进程执行和调动信息的数据结构，集中体现了进程的特征、状态和其他进程间的关系等。<br>
&nbsp;<br>
·进程的虚空间：<br>
操作系统的虚空间可以分成“进程虚空间”和“系统虚空间”。<br>
&nbsp;<br>
可执行程序的指令和数据对应着进程虚空间的地址，由操作系统把进程虚空间地址映射到物理内存上。这种映射是通过硬件寄存器和系统页表共同实现的。<br>
&nbsp;<br>
·用户态和核心态：<br>
用户态和核心态实际上是CPU工作的两种不同模式。所有内核对外提供的功能都是按系统调用的形式。进程进行一次系统调用，CPU将在用户态与核心态间切换一次，系统调用工作在核心栈，而普通用户调用将使用用户栈。<br>
&nbsp;<br>
·进程上下文：<br>
进程在生命期的所有状态都可以通过进程上下文来描述。通常包括三个内容：<br>
&nbsp;1 用户级上下文：包括代码段、数据段、用户段和共享内存段。<br>
&nbsp;2 寄存器上下文：进程运行时各寄存器的内容<br>
&nbsp;3 系统级上下文：进程控制块、进程使用的页表和核心栈<br>
&nbsp;<br>
·进程转换<br>
stop<br>
&nbsp; <br>
continue<br>
&nbsp; <br>
wakeup<br>
&nbsp; <br>
continue<br>
&nbsp; <br>
stop<br>
&nbsp; <br>
wakeup<br>
&nbsp; <br>
stop<br>
&nbsp; <br>
switch<br>
&nbsp; <br>
switch<br>
&nbsp; <br>
fork<br>
&nbsp; <br>
fork<br>
&nbsp; <br>
系统调用或中断<br>
&nbsp; <br>
系统调用或中断返回<br>
&nbsp; <br>
wait<br>
&nbsp; <br>
sleep<br>
&nbsp; <br>
exit<br>
&nbsp; <br>
用户态运行 <br>
核心态运行 <br>
就绪 <br>
暂停 <br>
睡眠 <br>
初始空间 <br>
僵尸状态 <br>
暂停&#43;睡眠 </div>
<div><br>
&nbsp;<br>
·进程调度：<br>
核心将在几种情况下调用调度管理器：当前进程被放入等待队列或者系统调用结束时，以及从核心态返回到用户态时。<br>
(1)&nbsp;&nbsp;&nbsp; LINUX支持两类不同进程：普通与实时进程，不同之处体现在优先级和调度策略上。<br>
(2)&nbsp;&nbsp;&nbsp; 如果一个实时进程处于可执行状态，它总在任何普通进程前执行。<br>
(3)&nbsp;&nbsp;&nbsp; 实时进程采用两种调用策略：时间片轮转和先进先出。<br>
(4)&nbsp;&nbsp;&nbsp; 普通进程采用Round Robin策略。<br>
(5)&nbsp;&nbsp;&nbsp; priority进程优先级、rt_priority实时进程优先级、counter进程运行运行时间<br>
&nbsp;<br>
·对fork的理解：<br>
fork之后父子进程的tast_struc除了进程号，其他的数据都一样。利用虚空间技术，共享代码段（引用计数加1），复制数据段。fork快完成的某阶段子进程被建立并保存上下文进入就绪队列等待调度，fork完毕之后父进程上下文被保存，返回子进程的进程标识符。注意：子进程的fork调用返回是0，父进程fork调用返回是子进程的进程号。然后父子进程从fork的调用点开始分别继续运行。<br>
父进程退出前需要使用wait()或waipid()等待子进程执行完毕和清除僵尸进程释放资源。<br>
&nbsp;<br>
第二章 进程间通信和同步<br>
前言：在linux/unix中支持多种进程间通信(IPC)的方式，主要包括：信号、信号量、消息队列和共享内存，管道（包括无名管道和FIFO）也是进程间通信的方式。<br>
&nbsp;<br>
·2,2信号的捕获和处理：<br>
#inlucde &lt;signal.h&gt; //参见POSIX.1中定义<br>
相关函数：<br>
sigaction(int signo, const struct sigaction *act, struct sigaction *oact); //设置信号处理器<br>
struct sigaction{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void (*sa_handler)();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sigset_t sa_mask;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int sa_flags;<br>
};<br>
(1) 信号处理器函数指针 (2)进程屏蔽的信号集合 （3）信号处理器的标志(查阅手册)<br>
&nbsp;<br>
int sigemptyset(sigset-t *set);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //信号集合清空<br>
int sigfillset(sigset_t *set);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //设置包含所有信号的全集<br>
int sigaddset(sigset_t *set, int signo);&nbsp;&nbsp;&nbsp; //把一个信号加入信号集合<br>
int sigdelset(sigset_t *set, int signo);&nbsp;&nbsp;&nbsp;&nbsp; //把一个信号从集合里删除<br>
int sigismember(const sigset_t *set, int signo);&nbsp;&nbsp;&nbsp; //判断信号是否包含在给定集合中<br>
int sigprocmask(int how, const sigset_t *set, sigset_t *oset);&nbsp;&nbsp;&nbsp;&nbsp; //设置进程中断屏蔽码<br>
how = [SIG_BLOCK, SIG_UNBLOCK, SIG_SETMASK], *oset对设置前屏蔽码做备份<br>
&nbsp;<br>
使用信号处理器基本方法：<br>
1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 编写信号处理函数handler_sigproc();<br>
//信号处理函数执行完毕的最后，记得要清堵塞的信号<br>
//sigaddset(&amp;blockmask, SIGINT);&nbsp;&nbsp;&nbsp;&nbsp; //信号处理器缺省堵塞的信号<br>
//sigaddset(&amp;blockmask, SIGTERM); //信号处理器处理的信号<br>
//sigprocmask(SIG_BLOCK, &amp;blockmask, NULL); //清堵塞信号<br>
2.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 设置信号处理器struct action act; <br>
act.sa_handler = handler_sigproc;<br>
sigemptyset(act.sa_mask);<br>
sigaddset(&amp;act.sa_mask, SIGTERM); //信号处理器执行期间堵塞相应的信号<br>
sigaction(SIGTERM, &amp;act, NULL);//将(kill产生)终止信号加入act信号处理器<br>
&nbsp;<br>
快系统调用、慢系统调用都可能被信号打断，POSIX.1把被中断的系统调用返回-1，errno设置为EINTER，只要不是“原子操作”都可能被打断，注意对这类问题的容错处理：<br>
ret = read(fd, buf, 255); <br>
if (ret == -1 &amp;&amp; errno == EINTER) //如果 (系统调用是由中断引起的执行失败) 则……<br>
&nbsp;<br>
·2.3 信号量<br>
有名信号量是全局，只要知道它的名字就可以使用它；<br>
无名信号量是局部，只能通过继承才能使用它；<br>
&nbsp;<br>
相关函数：<br>
头文件：&lt;sys/types.h&gt;, &lt;sys/ipc.h&gt;, &lt;sys/sem.h&gt;<br>
int semget(key_t key, int nsems, int semflg);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //创建或取得一个信号量组<br>
int semctl(int sem_id, int semnum, int cmd);&nbsp;&nbsp;&nbsp;&nbsp; //信号量控制函数（取&#20540;/删除/设置等）<br>
int semop(int semid, struct sembuf *sops, int nsops); //信号量操作函数<br>
(1)&nbsp;&nbsp;&nbsp; 信号量组ID （2）进行怎样操作（3）操作次数<br>
struct sembuf{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short sem_num;&nbsp;&nbsp;&nbsp;&nbsp; //对信号量组第sem_num个进行操作<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short sem_op;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //对信号量sem_value执行 -1是P操作，&#43;1是V操作<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short sem_flg;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //通常取0，如果使用SEM_UNDO退出进程后，信号量&#20540;变为0<br>
};<br>
使用信号量基本流程：<br>
1. sem_id = semget(SEM_KEY,0,0); //SEM_KEY自定义，要确保唯一性<br>
2. if (sem_id != -1) //如果信号量组不存在<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sem_id = semget(SEM_KEY, SEM_NUM, IPC_CREAT|IPC_EXCL|0666)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...//创建资源为SEM_NUM个的一个信号量组，权限为0666（可读写）<br>
else 初始化信号量组的信号量资源个数<br>
3实现P和V操作函数：<br>
void P(int sem_num, int sem_id)//对信号量组sem_id的第sem_num个信号量操作<br>
{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct sembuf sem[1]; <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sem[0].sem_num=sem_num; sem[0].sem_op = -1; sem[0].sem_flg = 0;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (semop(sem_id, sem, 1) == -1) //... 执行一次P操作，V操作类&#20284;<br>
}<br>
4 semctl(sem_id, sem_index, IPC_RMID); //手动删除信号量组<br>
//注意“信号量组”和“信号量&#20540;”的区别！<br>
&nbsp;<br>
·2.4 消息队列<br>
#include &lt;sys/msg.h&gt;<br>
int msgget(key_t key, int msgflg)); //创建或取得消息队列的ID，和信号量组类&#20284;<br>
int msgctl(int msqid, int cmd, struct msqid_ds *buf);<br>
int msgsnd(int msqid, void *msgp, size_t msgsz, int msgflg));<br>
int msgrcv(int msqid, void *msgp, size_t msgsz, long int msgtyp, int msgflg)); //接收消息<br>
//msgtyp=0:返回第一个消息 &gt;0:返回第一个&#20540;=msgtyp的消息 &lt;0:返回第一个&#20540;&lt;=-msgtyp<br>
&nbsp;<br>
&nbsp;<br>
消息队列使用基本原理：<br>
子进程child发送首次登记的标志FLAG(msgtyp&gt;0)和child进程号到服务器进程server注册，在server段使用msgrcv(Q_MSG_KEY, &amp;recv_buf, sizeof(Message)-sizeof(long), FLAG, 0)接收，Message正文不包括消息头的标志。然后server端发送server进程号，接收消息标志为子进程号的Message到子进程表示接收到先前消息。<br>
&nbsp;<br>
―――――――――――――――――――――――――――――――――――――――<br>
Message send_msg;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //首次登记并提交本进程的ID<br>
send_msg.m_type = FLAG;<br>
send_msg.process_id = getpid();<br>
send_len = sizeof(long)&#43;sizeof(int);<br>
ret = msgsnd(msq_key, &amp;send_msg, send_len, 0);<br>
Message recv_msg, reply_msg;<br>
//接收标志为FLAG的消息<br>
ret = msgrcv(msq_key, &amp;recv_msg, sizeof(Message)-sizeof(long), getpid(),FLAG,0);<br>
reply_msg.m_type = recv_msg.process_id;&nbsp;&nbsp; //向子进程发送反馈消息<br>
reply_msg.process_id = getpid()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //告诉子进程服务端server进程号，准备建立交互<br>
&nbsp;<br>
&nbsp;<br>
消息队列通过消息标志（即进程号）进行通信，如果客户/服务端进程有任何一方退出，则可能会出现消息丢失。即把退出一方的进程号作为标志的消息不会被任何进程接收，因为其他的进程号和消息标志不匹配。<br>
&nbsp;<br>
建立连接开始数据通信 <br>
回复反馈信息 <br>
发送注册信息 <br>
Server <br>
Client <br>
消息队列通信 </div>
<div><br>
·2.5 共享内存<br>
共享内存就是多个进程共享一端物理内存空间，通过把一段物理内存地址映射不同的虚空间来实现，而消息队列是把数据从应用缓冲区到核心缓冲区往返复制。因此共享内存的通信使用效率比消息队列高，但存在复杂的同步互斥关系。<br>
&nbsp;<br>
函数：<br>
int shmget((key_t key, int size, int shmflg));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //创建或取得一块共享内存<br>
int shmctl((int shmid, int cmd, struct shmid_ds *buf));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //共享内存操作<br>
void *shmat((int shmid, const void *shmaddr, int shmflg));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //获取共享内存的指针<br>
int shmdt((const void *shmaddr));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //将共享内存块从进程中分离/删除<br>
&nbsp;<br>
&nbsp;<br>
·小结：<br>
消息队列可以进行多路复用，进程间同步不需要复杂的同步互斥。数据以流的方式传递，<br>
各消息都是独立且可以区分的。信息的具体语义需要收发两端的进程自己去定义和解释。消<br>
息队列的缺点是需要进行两次数据复制，从用户空间到核心，在从核心到用户空间。<br>
共享内存不需要多次拷贝，在数据量大的进程间同步中，用共享内存方式可以提高效率，<br>
但是会需要复杂的进程间同步互斥控制。<br>
&nbsp;<br>
&nbsp;<br>
第三章 TCP/IP协议<br>
·3.1 OSI参考模型、协议和服务<br>
物理层实现在通信信道的0、1比特传输；<br>
数据链路层加强了比特传输功能，将01比特组织成数据帧实现可靠传输；<br>
网络层主要实现路由选择，确定端到端的传输路径；<br>
传输层实现点对点的无差错数据传输；<br>
会话层主要实现用户会话关系和同步的管理；<br>
表示层消除信息的语法和语义的差别；<br>
应用层面向不同需求，实现不同功能。<br>
&nbsp;<br>
·3.2 TCP和UDP的比较<br>
TCP实现了面向连接的、端对端的可靠流传输。TCP为其可靠性做的最重要的工作有：确认和超时重发、以及流量控制等。适合在传输数据可靠性较高的应用。<br>
UDP建立在IP协议上，利用IP包提供一种无连接的高效服务。但它不考虑数据包的正确和可靠性，需要应用程序自己来处理。适合在实时、数据量较小或网络通信可靠时的应用。<br>
&nbsp;<br>
·3.3 传输层端口<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 传输层和网络层最重要的区别是提供了“进程到进程的”通信能力，而网络层只能将IP包寻找到主机。实现进程间通信，除了主机地址还需要进程标志。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCP, UDP提出了协议端口的概念，此端口是软件端口不同于硬件端口。TCP/IP实现中对端口操作被设计成如同一般文件的操作。TCP和UDP的端口是完全独立的，即使在同一个进程里使用如9999/TCP和9999/UDP的端口号，它们是不会起冲突的。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 端口分配有两种：1 全局分配，即集中控制方式，由权威机构根据需要统一分配；2 本地分配，进程需要传输服务时向系统动态申请，操作系统根据当前系统端口使用情况返回本地唯一的端口号。由于端口的唯一性，也可以来标示一个进程。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCP/IP把端口分为两部分：1 少量的保留端口 2 自由端口，由进程进行通信前申请。<br>
&nbsp;<br>
·3.4 域名系统和名字服务器<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 域名解析就是实现IP地址和主机名字间一一对应关系。正向解析是从域名映射到IP地址，反向解析是从IP地址得到域名。在TCP/IP中，名字和地址间转换是由一组相互独立和协作的服务器软件来完成，即名字服务器。<br>
&nbsp;<br>
·3.5 TCP协议<br>
1. TCP的确认机制<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCP传输数据是以字节流方式，流中的数据是一个字节构成的序列，序列结构由应用程序解释，TCP的基本传输单元是TCP数据段。当接收端收到数据后，如果数据正确TCP将发送确认信息给发送端，确认&#20540;是下一个字节的序列ACK。表明发送端的ACK之前的序列都已被正确接收。<br>
&nbsp;<br>
2. TCP的超时重传机制<br>
TCP在发送一个数据包后，数据信息还保留在缓冲区中，直到接收端发送确认信息后才删除它们。如果一段时间后没有收到接收端确认，那么发送端将重发该数据包然后等待再次确认。如果超时重发到达一定次数，那么发送方认为对端不可到达，断开TCP连接。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCP采用一种自适应的确定定时时长算法。定义RTT(round trip time)为发出数据包到数据包确认之间的时间长度。TCP检查每一连接的性能，根据变化重新计算RTT&#20540;：<br>
Timeout = β× RTT<br>
RTT = α×old_RTT &#43; (1－α) × new_RTT_Sample<br>
其中α决定RTT对时延变化反映的速度，如果α接近1,则时间变化不影响RTT&#20540;，如果接近0那么RTT将随时延快速变化。<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCP数据段数据结构，略；<br>
&nbsp;<br>
3. TCP的滑动窗口协议<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCP通过滑动窗口协议实现拥挤控制，即发送方最多只能发送控制窗口大小的数据，当有接收方发送来的数据确认，发送才继续进行。控制窗口的大小由两个因素决定：一个是发送方自身的拥塞窗口控制；而是控制窗口大小是发送和接收两方中的最小&#20540;。<br>
&nbsp;<br>
4. TCP的“慢启动”策略<br>
当TCP发现丢失数据则认为网络拥挤，拥塞窗口大小就减半。当TCP认为拥塞结束，就使用“慢启动”策略：每收到一个数据包拥塞窗口加1，直到窗口数达到上次发生拥塞时窗口一半时候，这是只有发送出去的所有数据包都得到回应，拥挤窗口才加1。<br>
&nbsp;<br>
5. 小结<br>
TCP通过确认和超时重传机制保证数据包的可靠性；利用滑动窗口协议和“慢启动”策略进行流量控制。UDP协议没有上述功能，所以实时性好，但可靠性差。<br>
&nbsp;<br>
·3.6 TCP的状态转移过程<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 一个TCP连接在它的生命周期中，将经历一系列状态：LISTEN, SYN-SENT, SYN-RECEIVED, ESTABLISHED, FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK, TIME-WAIT, CLOSED。<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCP连接建立过程，由A端的TCP发送请求，对端B的TCP回应：<br>
(1)&nbsp;&nbsp;&nbsp; A --&gt; B SYN my sequence number is X&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;SEQ=X&gt;&lt;CTL=SYN&gt;<br>
(2)&nbsp;&nbsp;&nbsp; A &lt;-- B ACK your sequence number is X&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
(3)&nbsp;&nbsp;&nbsp; A --&gt; B SYN my sequence number is Y&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;SEQ=Y&gt;&lt;ACK=X&gt;&lt;CTL=SYN,ACK&gt;<br>
(4)&nbsp;&nbsp;&nbsp; A &lt;-- B ACK your sequence number is Y&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;SEQ=X&#43;1&gt;&lt;ACK=Y&#43;1&gt;&lt;CTL=SYN,ACK&gt;<br>
A和B发送自己的同步SYN信息给对方后，在SYN中包括本端初始的数据序列号，并且需要接收对方对自身发从的SYN的ACK确认。这个过程称为“三次握手”，共发送了3个数据包传递了4个信息。<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCP连接关闭前设置了TIME-WAIT状态，TCP将在等待2MSL(Maximum Segment Lifetime)时间后进入CLOSED状态。其中MSL是数据段在网络中最大生存时间。对端TCP在发送FIN数据端进行关闭确认时候，由于IP协议不可靠传输，可能主动方发送的确认数据包还未到达对端，对端就开始进行超时重发，如果这时主动端关闭TCP连接，那么TCP协议会认为发生网络连接错误，将发送RST旧连接数据段。因此主动端关闭TCP前等待2MSL时间，将确保发送和接收端的数据包在网络中消失。由A端主动发起连接断开状态图：<br>
TCP A&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCP B<br>
&nbsp;&nbsp; ESTABLISHED&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ESTABLISHED<br>
&nbsp;&nbsp;&nbsp;&nbsp; (主动关闭)<br>
&nbsp;&nbsp; FIN-WAIT-1 --&gt;&lt;SEQ=X&gt;&lt;ACK=Y&gt;&lt;CTL=FIN,ACK&gt;&nbsp; --&gt;CLOSE-WAIT<br>
&nbsp;&nbsp; FIN-WAIT-2 &lt;--&lt;SEQ=Y&gt;&lt;ACK=X&#43;1&gt;&lt;CTL= ACK&gt;&nbsp;&nbsp; &lt;--CLOSE-WAIT<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (被动关闭)<br>
&nbsp;&nbsp; TIME-WAIT &lt;--&lt;SEQ=Y&gt;&lt;ACK=X&#43;1&gt;&lt;CTL=FIN,ACK&gt;&lt;--LAST-ACK <br>
&nbsp;&nbsp; TIME-WAIT --&gt;&lt;SEQ=X&#43;1&gt;&lt;ACK=Y&#43;1&gt;&lt;CTL=FIN,ACK&gt;--&gt; CLOSED<br>
&nbsp;&nbsp;&nbsp;&nbsp; (等待2MSL)<br>
&nbsp;&nbsp; CLOSED<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IP数据包&#26684;式，略<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ICMP协议产生的控制报文放在IP数据包里，通过IP数据包发送到制定地点。<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ACK q&#43;1 <br>
FIN q <br>
ACK p <br>
FIN p <br>
……………… <br>
DATA, 带回确认 <br>
DATA, 带回确认 <br>
DATA <br>
ACK=b&#43;1 <br>
SYN=b, ACK=a&#43;1,<br>
MSS=1460 <br>
SYN=a, MSS=1460 <br>
一个正常的TCP通信过程 <br>
connect主动请求发送后状态：SYN-SEND <br>
Client <br>
Server <br>
LISTEN正在倾听accept<br>
发送后状态SYN-RVCD <br>
ESTABLISH<br>
connect返回 <br>
ESTABLISH<br>
accept返回 <br>
write数据 <br>
read数据，<br>
处理数据，<br>
write写回结果 <br>
read数据 <br>
close主动要求关闭连接:<br>
FIN-WAIT-1 <br>
被动关闭<br>
CLOSE-WAIT <br>
FIN-WAIT-2 <br>
(等待2MSL)<br>
CLOSED <br>
TIME-WAIT <br>
close<br>
LAST-ACK <br>
CLOSED <br>
TCP最初需要进行MSS(Maxium Segment Size)协商，否则数据包可能被分段后再重组 </div>
<div><br>
&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
第四章 基本套接字编程<br>
·4.1 基本套接字函数族<br>
头文件：&lt;sys/types.h&gt;, &lt;sys/socket.h&gt;<br>
主要函数：<br>
int socket(int domain, int type, int protocol);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //创建socket描述符<br>
[domain=AF_UNIX,AF_INET,AF_ISO; type=SOCK_STREAM,SOCK_DGRAM,SOCK_RAW;]<br>
&nbsp;<br>
int connect(int sockfd, struct sockaddr* servaddr, int addrlen); //向服务器发送连接请求<br>
int bind(int sockfd, struct sockaddr* myaddr, int addrlen);&nbsp;&nbsp;&nbsp;&nbsp; //向系统登记一个固定端口<br>
int listen(int sockfd, int backlog);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //被动倾听套接字的指定端口<br>
int accept(int sockfd, struct sockaddr* addr, int addrlen); //从完全连接队列接收一个连接套接<br>
[如果完全连接队列为空队列则堵塞，或直接返回-1，accept成功返回一个（继承倾听套接字属性的）连接套接字描述符]<br>
int close(int sockfd);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //关闭套接字描述符<br>
int shutdown(int sockfd, int howto);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //关闭套接字描述符读写信道<br>
[howto = SHUT_RD, SHUT_WR, SHUT_RDWR]<br>
&nbsp;<br>
网络字序转换函数族：<br>
头文件：&lt;netinet/in.h&gt;<br>
unsigned long int htonl(unsigned long int hostlong);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //host to network long 字序转换<br>
unsigned long int htons(unsigned long int hostlong);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //host to network short 字序转换<br>
unsigned long int ntohl(unsigned long int hostlong);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //network to host long 字序转换<br>
unsigned long int ntohs(unsigned long int hostlong);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //network to host short 字序转换<br>
&nbsp;<br>
IP地址转换函数族<br>
头文件：&lt;sys/socket.h&gt;, &lt;netinet/in.h&gt;, &lt;arpa/inet.h&gt;<br>
主要函数：<br>
int inet_aton(const char *cp, struct in_addr *inp);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //将字符串表示IP地址转struct in_addr表示<br>
unsigned long int inet_addr(const char *cp);&nbsp;&nbsp;&nbsp; //将字符串表示IP地址转32 bits表示<br>
char *inet_ntoa(struct in_addr in);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //将struct in_addr表示IP地址转字符串表示<br>
&nbsp;<br>
服务器应答 <br>
客户发送数据 <br>
客户请求建立连接 <br>
socket() <br>
套接字编程基本流程 <br>
bind() <br>
listen() <br>
accept() <br>
堵塞等待请求 <br>
read() <br>
write() <br>
close() <br>
socket() <br>
connect() <br>
write() <br>
read() <br>
close() <br>
Client <br>
Server <br>
NOTE:<br>
通常客户端不需要bind端口，系统动态分配 </div>
<div><br>
示例代码：<br>
listen_fd = socket(AF_INET, SOCK_STREAM, 0); //创建Internet协议簇，流类型套接字<br>
if (listen_fd == -1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; error_proc();<br>
bzero(&amp;serv_addr, sizeof(serv_addr)); //初始化服务器地址结构<br>
serv_addr.sin_family = AF_INET;&nbsp;&nbsp; //使用Internet协议簇<br>
serv_addr.sin_port = htons(端口号); //设置端口号，并转换为网络字序<br>
/*如果是客户端执行<br>
&nbsp;*ret = inet_aton(“127.0.0.1”, &amp;serv_addr.sin_addr); //为socketaddr地址结构设置IP地址<br>
&nbsp;*然后bind();指定端口，接着connect(); 服务器端请求建立连接，开始“三次握手”协议<br>
&nbsp;*如果是服务器端则执行 */<br>
serv_addr.sinaddr.s_addr = htonl(INADDR_ANY); //允许任何网络设备接口连接并处理<br>
ret = bind(listen_fd, (struct sockaddr*)&amp;serv_addr,sizeof(serv_addr)); //套接字绑定指定端口<br>
if (ret &lt; 0) error_proc();<br>
listen(listen_fd, 倾听队列长度);&nbsp;&nbsp;&nbsp; //转为倾听套接字，设置倾听队列长度<br>
//从完全连接队列中接受一个新连接，返回连接套接字描述符<br>
conn_fd = accept(listen_fd, (struct sockaddr*)&amp;serv_addr, sizeof(serv_addr)); <br>
&nbsp;<br>
·并发服务器模式<br>
&nbsp;/*<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 服务器端套接字初始化，<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1服务器端的父进程用倾听套接字X，倾听来自客户端的请求连接，<br>
2当accept一个连接套接字Y时候fork子进程专门处理客户端的数据处理，<br>
3子进程关闭倾听套接字X不使用，处理客户端请求，完毕后关闭Y，退出，<br>
4而父进程关闭连接套接字描述符Y不使用，继续倾听新的客户端连接(转过程2)。<br>
&nbsp;&nbsp; */<br>
do{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*过程2; 3; 4; 的实现参考代码*/<br>
//从完全倾听队列中接收一个连接套接字描述符<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; conn_fd = accept(listen_fd, (struct sockaddr*)&amp;cli_addr, sizeof(cli_addr));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (conn_fd &lt; 0) <br>
error_proc();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //错误处理<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch ( ret = fork() ){<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case -1: <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; error_proc();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //错误处理<br>
&nbsp;&nbsp;&nbsp; case 0:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; close(listen_fd);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //关闭倾听套接字描述符<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; serv_for(conn_fd);&nbsp;&nbsp;&nbsp; //为客户端提供服务<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(0);<br>
default:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; close(conn_fd);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //关闭连接套接字描述符<br>
}<br>
} while (continue);<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
第五章 无堵塞套接字和单进程轮询服务器<br>
·5.1 无堵塞套接字<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 堵塞套接字在等待输入/输出时会进入睡眠，不能继续其他的操作。在并发服务器模式下这一缺点并不明显，但在一些复杂应用中可能需要在单进程中为多个连接服务，这时堵塞套接字会大大降低效率。另外，进程可能一直被堵塞。比如服务器端崩溃，而客户端并不知道，此时客户端进程将一直堵塞。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 无堵塞套接字会对读、写、建立连接、接收连接过程产生影响。总的来说就是不等待所有资源到齐，而立即操作并返回，这点在和处理无堵塞套接字上有一些区别。如果本已堵塞而由于使用无堵塞套接字，那么errno将返回EWOULDBLOCK，通过下面语句可以判断：<br>
ret = accept(...);<br>
if (ret &lt; 0 &amp; errno != EWOULDBLOCK) //如果错误返回并且错误原因不是无堵塞<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 无堵塞套接字的两种实现：<br>
int (flags = fcntl(sock_fd, F_GETFL, 0) &lt; 0) error_proc();<br>
flags |= O_NONBLOCK;<br>
if (fcntl(sock_fd, F_SETFL, flags) &lt; 0) error_proc(); //这种方法是POSIX标准定义方式<br>
&nbsp;<br>
int b_on = 1; //在ioctl函数中使用FIONBIO命令<br>
ioctl(sock_fd, FIONBIO,&amp;b_on);<br>
&nbsp;<br>
·5.2 单进程轮询服务器模式<br>
make_null(serv_slot, maxlen); //serv_slot[]是连接套接字描述符数组，本进程为其提供服务<br>
listen(listen_fd, MAXSIZE);&nbsp;&nbsp; //建立倾听套接字<br>
do{<br>
//从完全倾听队列中接收一个连接套接字描述符<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; conn_fd = accept(listen_fd, (struct sockaddr*)&amp;cli_addr, sizeof(cli_addr));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (conn_fd &lt; 0 &amp;&amp; errno != EWOULDBLOCK) <br>
error_proc();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //错误处理<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else&nbsp; if (conn_fd &gt;= 0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //接收到新的连接套接字描述符<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; create_new_connect(conn_fd, serv_slot, &amp;maxlen);&nbsp;&nbsp; //建立新连接<br>
for (i = 0; i &lt; maxlen; &#43;&#43;i)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //从0到maxlen都是有效连接，进程轮流为其服务<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; serve_for(serv_slot[i]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //本进程为第i个连接服务<br>
} while (continue);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 使用单进程轮询服务器模式仍然无法避免客户端的某些意外（比如非正常断线）或恶意行为造成失效，而且如果客户数量增加，服务器端的相应时延也会加大。因此我们仍然使用并发服务器模式来提供并行的服务，因为一个服务器子进程失效不会影响到其他进程的工作。<br>
&nbsp;<br>
&nbsp;<br>
第六章 带外数据与多路复用、信号驱动的输入/输出模型<br>
·6.1 多路复用的输入/输出模型<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 多路复用的概念：进程不是主动询问套接字情况，而是希望对监视的套接字向系统登记，而后采用被动的态度等待。当监视的套接字上发生了事件，进程去检查发生的状况然后做相应的处理。在这种工作方式下，进程是在已经知道在套接字上发生了事件才去检测，在没有发生事件的时候进入睡眠状态。<br>
&nbsp;<br>
头文件：&lt;sys/time.h&gt; &lt;unistd.h&gt;&nbsp; [&lt;signal.h&gt;(pselect使用)]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
主要函数：<br>
int select (int maxfd, fd_set *rdset, fd_set *wrset, fdset *exset, struct timeval *timeout);<br>
[maxfd是需要监视的最大文件描述符&#20540;＋1，即系统监视从0到maxfd-1的文件描述符;<br>
rdset, wrset, exset是对应需要检测的可读、可写和异常文件描述符集合；<br>
timeout内没有发生事件，函数返回0]<br>
&nbsp;<br>
int pselect(int maxfd, fd_set *rdset, fd_set *wrset, fdset *exset, struct timespec *timeout,const sigset_t sigmask); //POSIX中对select函数的增强，参数sigmask是执行后对堵塞信号恢复<br>
&nbsp;<br>
文件描述符集合：<br>
FD_ZERO(fd_set *fdset);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //清空初始化<br>
FD_SET(int fd, fd_set *fdset);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //增加<br>
FD_CLR(int fd, fd_set *fdset);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //删除<br>
FD_ISSET(int fd, fd_set *fdset);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //判断包含<br>
&nbsp;<br>
·套接字的读、写和异常就绪条件<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 读就绪：倾听套接字完全连接队列建立新连接；连接套接字的读缓冲区超过读下限、读管道关闭和套接字异常。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 写就绪：连接套接字的写缓冲区空闲小于某下限、写管道被关闭和套接字异常。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 异常就绪：套接字上到达外带数据。异常就绪连带触发读、写就绪。<br>
上面列出部分常用就绪条件，具体参考帮助手册。<br>
&nbsp;<br>
基本用法：<br>
FD_ZERO(&amp;r_set);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //初始化<br>
FD_SET(listen_fd, &amp;r_set);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //加入可读文件描述符集合<br>
ret = select(listen_fd&#43;1, &amp;r_set, NULL, NULL, NULL); //对倾听套接字进行就绪判断<br>
&nbsp;<br>
&nbsp;<br>
·6.2 信号驱动的输入/输出模型<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 信号驱动通常用于接收紧急数据。进程先向系统登记，然后系统检测到数据到达后会向接收者发生SIGIO信号，然后接收者在信号处理器中接收数据。这种方式通常用在接收紧急的控制数据场合。<br>
&nbsp;<br>
数据接收者设置：<br>
#include &lt;fcntl.h&gt;<br>
int fcntl(int fd, int cmd,...);&nbsp;&nbsp; <br>
//使用命令F_SETOWN，第三个参数如果是正整数表示进程号，负整数表示进程组接收<br>
&nbsp;<br>
&nbsp;<br>
·6.3 系统I/O模型的总结<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 本书讲述了“堵塞方式、非堵塞方式、多路复用和信号驱动”四种I/O模型。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 堵塞方式：<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 广泛使用在并发服务器上，当套接字不满足操作条件立即堵塞等待资源。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2 非堵塞方式：<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 广泛使用在单进程轮询服务器上，浪费较大CPU资源使用场合较少。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3 多路复用方式：<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 广泛使用在单进程进行多客户端服务上，比非堵塞方式在轮询中节约CPU时间。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4 信号驱动方式：<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 广泛使用在接收紧急数据场合。<br>
&nbsp;<br>
·6.4 带外数据的接收和发送<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 带外数据就是指在正常数据流信道之外传输的数据，通常用在对远端进程的同步和控制。它和信号驱动方式几乎相同，但是发送的是SIGURG信号，不是SIGIO。<br>
&nbsp;<br>
头文件：&lt;sys/types.h&gt;, &lt;sys/socket.h&gt;<br>
主要函数：<br>
int send(int sockfd, void *buf, int len, int flags); //使用MSG_OOB控制选项发送带外数据<br>
int recv(int sockfd, void *buf, int len, int flags); //使用MSG_OOB控制选项接收带外数据<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 带外数据一次只允许发送一个字节，如send(sock_fd, “bc”, 2, MSG_OOB)，TCP只认为最后一个是带外数据，之前都是普通数据。在特殊情况下，带外数据包优先被接收方接受。<br>
接收方在缺省情况下(使用ioctl函数可以改变)使用一个字节的外带数据缓冲区接收外带数据，并且外带数据段和普通套接字数据段字符集不同，可以区分外带数据和普通数据。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<br>
如果接收方收到多个带外数据段，TCP会和先前一次收到的数据段中数据做比较，如果其&#20540;相同则认为它们是同个带外数据段。由于发送方可能发送多个外带数据段，接收外带数据是必须做容错处理。<br>
接收方同一时刻只允许有一个字节的外带数据，先到者如果没有被及时处理，那么任何后来的外带数据段都将覆盖它。带外数据被覆盖后成为普通数据。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 收到外带数据将触发异常就绪。直到读指针大于带外数据标示（紧急）指针后解除异常。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 服务器端接收外带数据可以使用：<br>
1 多路复用方式，要点：<br>
检测异常就绪和读就绪套接字先后顺序不同，结果也不同。<br>
2 异步信号驱动方式，要点：<br>
设计SIGURG信号处理器，处理前后注意屏蔽/堵塞信号。<br>
3 检测带外数据标记方式，要点：<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //套接字设置成SO_OOBINLINE，即外带数据看成普通数据存放，on=1<br>
&nbsp;setsockopt(conn_fd,SOL_SOCKET,SO_OOBINLINE,&amp;on,sizeof(on));<br>
&nbsp;ioctrl(conn_fd, SIOCATMARK,&amp;n_data); //检测读指针是否和带外数据标示指针重合<br>
&nbsp;if (n_data == 1) //带外数据到达<br>
&nbsp;<br>
注意：被覆盖的带外数据将保留继续保留在读缓冲区里，而后当成普通数据读入。如果使用过的带外数据没有及时得从缓冲区里删除，该带外数据可能会被当场普通数据读入，如sleep()系统调用可能导致这类需要紧急处理的过程产生诡异的行为！<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
第七章 UDP数据报<br>
·7.1 UDP数据报<br>
UDP源端口、UDP目的端口标示进程；UDP数据报长度；校验和，可选。<br>
UDP非面向连接，不可靠传输，具有较小传输时延。<br>
&nbsp;<br>
·7.2 UDP传输过程<br>
SERVER: socket() --&gt; bind() --&gt; recvfrom() --&gt; sendto()--&gt;close()<br>
CLIENT : socket() --&gt; sendto() --&gt; recvfrom() --&gt; close() <br>
服务器端和TCP协议相比少了listen()和accept()两个过程，而客户端不需要建立连接<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 头文件：&lt;socket.h&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 发送和接收函数：<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int sendto(int sockfd, const void *msg, int len, unsigned int flags, const struct sockaddr *to, int tolen);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //参数to是指定接收方地址<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int recvfrom(int sockfd, const void *buf, int len, unsigned int flags, const struct sockaddr *from, socklen_t *addrlen);&nbsp;&nbsp; //参数from是保存发送方的地址<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int send(int sockfd, void *buf, int flags);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //使用connect绑定后，发送到缺省地址<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int recv(int sockfd, void *buf, int flags);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //使用connect绑定后，从缺省地址接收<br>
&nbsp;&nbsp;&nbsp; //socket(AF_INET, SOCK_DGRAM, 0) 创建一个UDP套接字<br>
&nbsp;<br>
·7.3 UDP服务器和TCP服务器的比较<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 使用UDP协议的服务器通常是非面向连接的，因此不用listen和accept的。UDP服务器只需要在其端口上等待客户机发来的数据报即可。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCP服务器需要和客户端进行连接然后，独占一个连接套接字为其服务；而UDP服务器实际并不和客户机进行连接，UDP服务器仅是接收报文，处理并返回结果。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UDP协议并不关心数据报的可靠性和次序，而希望应用程序保证这些。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCP服务器中，服务器可以调用getsockpeer函数获取客户机地址信息和端口号，使用getsockname获取套接字对应的IP地址和端口号。<br>
UDP服务器中，可以在recvfrom函数中获取数据报的源地址，使用getsockname获取数据报的端口。如果该UDP服务器有多个IP地址，则无法判断是哪个IP地址获取该数据报。因为UDP协议非面向连接，没有记录接收方的IP地址，此时如果需要明确知道是哪个IP地址收到该数据报，在服务器端需要为每个建立多个UDP套接字绑定在不同网络接口上，通过getsockname获取对应的IP号。<br>
&nbsp;<br>
·7.4 UDP的“连接”<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UDP是非面向连接，但是也可以调用connect函数对套接字进行绑定到缺省IP地址上。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UDP服务器调用conncet后，并不启用“三次握手”，仅仅记住目的地址和端口。在使用send函数时候会自动按照缺省情况来填写数据报头；同时也可以用sendto函数发送指定位置。<br>
但在接收时候，如果套接字已绑定一个地址和端口，那么UDP服务器只接收该套接字上源地址和端口相同的数据报。如果一个数据报源地址和端口和该套接字设置不同，则丢弃它。而没有绑定地址和端口的UDP套接字可以接收任意来源的数据报。<br>
可以多次调用connect函数修改UDP套接字的绑定地址和端口设置。如果调用connect(AF_UNSPEC, NULL, 0)可以取消对套接字的绑定。<br>
&nbsp;<br>
·7.4 UDP应用程序性能改进<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 解决报文的无序问题：<br>
对UDP报文设计一个数据序列号，接收到报文先进行排序后再转交给数据处理程序。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2 解决报文的流量控制问题：<br>
&nbsp;如果客户端接收能力远高于服务器端发送速率，则会让网络传输性能大大下降；<br>
如果客户端接收能力远低于服务器端发送速率，则会让UDP报文大量丢失，消耗服务器端资源。因此需要匹配双方的发送和接收速率，有利用提高整体性能。我们需要在应用程序中建立一种端对端的流量控制反馈机制，由客户端给服务器端发送接收能力的反馈，让服务器端动态调整发送速率。<br>
应用缓冲区 <br>
核心缓冲区 <br>
应用程序处理套接字缓冲的速率 <br>
应用程序读取套接字缓冲的速率 <br>
应用程序发送缓冲区 <br>
应用程序接收缓冲区 <br>
单个系统发送缓冲区 <br>
UDP套接字接收缓冲区 <br>
服务器端发送速率 <br>
根据客户端程序接收缓冲的占用情况给服务器端提供反馈 <br>
服务器端 <br>
客户端 </div>
<div><br>
&nbsp;<br>
&nbsp;<br>
第八章 域名系统和通用套接字选项<br>
·8.1 域名系统<br>
#include &lt;netdb.h&gt;<br>
struct hostent *gethostbyname(const char *hostname); //指定域名地址来获取IP地址<br>
struct hostent *gethostbyaddr(const char *addr, size_t len, int family); //指定IP地址获取域名<br>
struct hostent{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *h_name;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //主机名<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char **h_alias;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //主机别名列表<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int h_addrtype;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //主机地址类型<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int h_length;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //主机地址长度<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char **h_addr_list;//主机IP地址列表<br>
};<br>
&nbsp;<br>
int gethostname(char *name, size_t len); //返回本机域名地址 &lt;unistd.h&gt;<br>
int uname(struct utsname *name); //同上，#Include &lt;sys/utsname.h&gt;<br>
struct servent *getservbyname(const char *servname, const char *protoname);//服务名获取端口<br>
struct servent *getservbyport(int port, const char *protoname); //由端口名获取服务信息<br>
&nbsp;<br>
·8.2 套接字选项<br>
#include &lt;sys/socket.h&gt;<br>
int getsockopt(int sockfd, int level, int optname, void *potval, socklen_t *optlen);<br>
int setsockopt(int sockfd, int level, int optname, cosnt void *potval, socklen_t *optlen);<br>
[通用套接字选项，参考手册，略。]<br>
&nbsp;<br>
&nbsp;<br>
第九章高级套接字函数编程<br>
·9.1 发送和接收函数的高级用法<br>
头文件：&lt;sys/types.h&gt;, &lt;sys/socket.h&gt;<br>
int send(int sockfd, void *buf, int len, int flags); <br>
[flags=MSG_OOB, MSG_DONTWAIT, MSG_DONTROUTE] <br>
int recv(int sockfd, void *buf, int len, int flags);&nbsp;&nbsp; <br>
[flags=MSG_OOB, MSG_PEEK, MSG_WAITALL, MSG_DONTROUTE]<br>
&nbsp;<br>
&nbsp;<br>
头文件：&lt;sys/uio.h&gt;<br>
int readv(int fd, struct iovec *iov, int iovlen);&nbsp;&nbsp; //将套接字缓冲区数据读到多个应用缓冲区中<br>
int writev(int fd, struct iovec *iov, int iovlen); //将多个应用缓冲区写到套接字缓冲区数据中<br>
struct iovec{<br>
&nbsp;void *iov_base; .//指向应用缓冲区结构体的数组<br>
&nbsp;size_t iov_len;&nbsp;&nbsp; //缓冲区的个数<br>
};<br>
&nbsp;<br>
头文件：&lt;sys/types.h&gt;, &lt;sys/socket.h&gt;<br>
int recvmsg(int sockfd, struct msghdr *msg, int flag);&nbsp;&nbsp; //常用在UNIX域套接字中对<br>
int sendmsg(int sockfd, struct msghdr *msg, int flag); //进程间发送/接收文件描述符使用<br>
struct msghdr{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void *msg_name;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //发送端的地址信息<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int msg_namelen;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct iovec *msg_iov; //缓冲区结构体指针<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int msg_iovlen;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //缓冲区个数<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void *msg_control;&nbsp;&nbsp;&nbsp; //控制信息<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int msg_controllen;&nbsp;&nbsp;&nbsp; //控制信息长度<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int msg_flags;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
};<br>
使用这两个函数发送附加消息时候通常需要定义以下结构体：<br>
union{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct cmsghdr cm;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char control[CMSG_SPACE(sizeof(附加段长度))];<br>
};<br>
操作宏，头文件: &lt;sys/socket.h&gt;, &lt;sys/param.h&gt;<br>
struct cmsghdr *CMSG_FIRSTHDR(struct msghdr *msghdrptr);//指向第一个cmsghdr结构指针<br>
struct cmsghdr *CMSG_NEXTHDR(struct msghdr *msghdrptr, struct cmsghdr *cmsgptr);<br>
unsigned char *CMSG_DATA(struct cmsghdr *cmsghdr); //返回指向cmsghdr结构第一个字节<br>
unsigned CMSG_LEN(unsigned int lenght); //获取cmsghdr中存放数据字节数<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
第十章守护进程和超级服务器inetd<br>
·10.1 守护进程的原理<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 只要系统没有关机或者崩溃，守护进程将在系统中不间断运行。关键是如何把守护进程的运行环境和其他进程的运行环境隔离。步骤：<br>
1 第一次fork和setsid函数调用建立新会话组<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这个操作的主要目的是为了让一个进程和控制终端脱离，这样来自终端的信号就不会影响到守护进程。setsid()函数的功能是让创建一个新的会话过程，并让调用setsid()的进程成为该会话过程的领头进程。但是setsid()的调用条件是这个进程不是一个进程组的主进程。因此我们先fork()一个子进程并终止该进程组主进程的运行，在子进程中调用setsid()让子进程成为不带控制终端的新会话过程的领头进程。于是这个进程就和原控制终端脱离，并成为新会话组的领导进程。<br>
&nbsp;<br>
2 第二次fork和setpgrp函数调用建立新进程组<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 调用setsid()之后，虽然在新的会话组中的领导进程不带控制终端。但是如果这个进程打开了一个终端，那么整个会话组将又重新的控制终端。因此我们需要fork()一个新的子进程继续运行，并终止该会话组领头进程的运行。此时这个新进程不是会话组领导进程，所以即使打开一个终端也不会成为整个会话组的控制终端。<br>
但由于父进程是会话组的领头进程，如果让父进程退出而子进程继续运行，那么将发送SIGHUP（中断和挂起信号）给这个会话组中所有进程。因此我们要先忽略信号SIGHUP，然后再fork，接着退出父进程而子进程继续运行。<br>
但是这个新进程仍然和已退出父进程同在一个进程组中，仍然会受到同个进程组中的信号影响。所以我们要使用setpgrp()让这个进程成为新的进程组的领导者。<br>
&nbsp;<br>
3 关闭所有文件描述符<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fork()时候子进程将继承父进程的文件描述符。我们需要在守护进程中关闭先前打开的文件描述符，以免对其他进程造成影响。使用sysconf(_SC_OPEN_MAX)函数获取系统中每个进程可以打开文件的最大数目，然后使用close()关闭它们。<br>
&nbsp;<br>
4 消除umask的影响<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 每个进程都有一个umask同它关联。umask指定进程创建文件的保护掩码，是系统提供的一种安全机制，限制进程创建文件的权限。比如进程创建一个文件的权限为0777，进程umask为0277，那么实际文件权限为0777-0277=0500。此时如果其他进程去读写守护进程创建的文件可能会受到文件掩码的影响。使用umask(0)系统调用清除旧的文件掩码。<br>
&nbsp;<br>
5 改变守护进程的当前目录<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 每个进程都有一个当前目录，当进程产生错误时可以将错误信息记录在当前目录的core文件中供以后分析错误使用。如果不把守护进程修改到一个安全的目录，那么守护进程的当前目录是不确定的，并可能影响到其他系统的管理工作。我们可以使用chdir(“/”);将守护进程当前目录修改到根目录下。<br>
&nbsp;<br>
6 对标准I/O描述符重定向<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 由于守护进程不连接任何控制终端，并且所有文件描述符都关闭。那么如果意外调用printf, perror等输出将导致出错。我们把标准I/O重定向到无伤害设备(harmless device)描述符上，那么对标准I/O的操作都将忽略避免人为意外使用出错。<br>
&nbsp;<br>
7 使用syslog记录守护进程的错误<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; syslogd本身就是一个守护进程，使用UDP 514端口。应用程序可以发送UDP报文记录错误信息。void syslog(int priority, const char *message, ...); //#incluse &lt;syslog.h&gt;<br>
&nbsp;<br>
8 文件锁和控制守护进程副本互斥运行<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 为了避免运行多个相同的守护进程产生的干扰，因此使用锁文件的方式记录守护进程的工作情况。linux系统的锁采用咨询锁，只是系统将告知文件锁定情况而不阻止进程对文件的操作。我们可以使用int flock(int fd, int operation); //#include &lt;sys/file.h&gt;<br>
[operation = LOCK_SH共享锁, LOCK_EX互斥锁，LOCK_UN解锁，LOCK_NB进程获取锁失败不堵塞，缺省为进程堵塞] <br>
&nbsp;<br>
&nbsp;<br>
示例代码：<br>
int init_daemon(const char *pathname, int facility);<br>
{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct sigaction act;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int max_fd, i, ret;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int lock_fd;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char buf[10];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //打开一个文件锁<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lock_fd = open(LOCKFILE, O_RDWR | O_CREAT, 0640);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (lock_fd &lt; 0) <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; error_proc();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //加锁<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret = flock(lock_fd, LOCK_EX LOCK_NB);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (ret &lt; 0) <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; error_proc();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //第一次fork<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret = fork();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (ret &lt; 0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; error_proc();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (ret != 0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(0);&nbsp;&nbsp;&nbsp; //关闭进程组的主进程，子进程继续运行&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret = setsid(); //这个子进程成为新会话组的领导进程<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (ret &lt; 0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; error_proc();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //忽略SIG_IGN<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; act.sa_handler = SIG_IGN;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sigemptyset(&amp;act.sa_mask);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; act.sa_flag = 0;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sigaction(SIGHUP, &amp;act, NULL);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //第二次fork<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret = fork();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (ret &lt; 0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; error_proc();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(0); //关闭进程组的主进程，子进程继续运行<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chdir(“/”);&nbsp;&nbsp;&nbsp; //改变守护进程的当前目录<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; umask(0);&nbsp;&nbsp;&nbsp; //清除旧的文件掩码<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; setpgrp();&nbsp;&nbsp;&nbsp; //让这个进程成为新进程组的领导进程<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprintf(buf, “%6d/n”, getpid()); //获取守护进程的ID号，保存进buf数组中<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; write(lock_fd, buf, strlen(buf)); //把守护进程ID号保存进锁文件中<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; max_fd = sysconf(_SC_OPEN_MAX);&nbsp;&nbsp; //获取进程最大打开的描述符<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (i = 0; i &lt; max_fd; &#43;&#43;i)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; close(i);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //逐个关闭<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; open(“dev/null”, O_RDWR);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //打开无伤害设备<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dup(1);&nbsp;&nbsp;&nbsp; //<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dup(2);&nbsp;&nbsp;&nbsp;&nbsp; //标准I/O描述符重定向<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; openlog(pathname, LOG_PID,facility); //打开syslogd记录文件<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;&nbsp;&nbsp; //守护进程标准创建过程结束<br>
}<br>
&nbsp;<pre name="code" class="cpp">if (srv-&gt;srvconf.pid_file-&gt;used) {
		if (-1 == (pid_fd = open(srv-&gt;srvconf.pid_file-&gt;ptr, O_WRONLY | O_CREAT | O_EXCL | O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH))) {
			struct stat st;
			if (errno != EEXIST) {
				log_error_write(srv, __FILE__, __LINE__, &quot;sbs&quot;,
					&quot;opening pid-file failed:&quot;, srv-&gt;srvconf.pid_file, strerror(errno));
				return -1;
			}

			if (0 != stat(srv-&gt;srvconf.pid_file-&gt;ptr, &amp;st)) {
				log_error_write(srv, __FILE__, __LINE__, &quot;sbs&quot;,
						&quot;stating existing pid-file failed:&quot;, srv-&gt;srvconf.pid_file, strerror(errno));
			}

			if (!S_ISREG(st.st_mode)) {
				log_error_write(srv, __FILE__, __LINE__, &quot;sb&quot;,
						&quot;pid-file exists and isn't regular file:&quot;, srv-&gt;srvconf.pid_file);
				return -1;
			}

			if (-1 == (pid_fd = open(srv-&gt;srvconf.pid_file-&gt;ptr, O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH))) {
				log_error_write(srv, __FILE__, __LINE__, &quot;sbs&quot;,
						&quot;opening pid-file failed:&quot;, srv-&gt;srvconf.pid_file, strerror(errno));
				return -1;
			}
		}
	}
</pre><br>
<br>
·10.2 超级服务器inetd的工作原理<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 由于服务器套接字初始化方式非常类&#20284;，所以可以设计一个专门的服务器负责初始化工作，并且它将根据接入端口不同调用相应的服务程序进行工作，这些服务程序在未被接入前都处于睡眠等待状态。采用超级服务器的方式可以让服务器程序采用统一方式管理。<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 超级服务器将采用select的方式并发检测在文件/etc/inetd.conf中说明的TCP/UDP端口，一旦发现有客户接入就创建一个子进程。超级服务器inetd是服务接入者，它在创建字进程时候调用exec()载入具体的服务程序。在子进程中关闭倾听套接字，父进程中关闭连接套接字，于是父进程继续检测，子进程开始为客户端进行服务。对于wait服务程序，超级服务器inet载入它时候将其在检测集合中删除，等待该服务结束后才能接入下次服务。服务程序完毕后将发送SIGCHLD信号，超级服务器将其继续加入检测集合。当系统管理员修改超级服务器配置文件后将发送SIGHUP信号，超级服务器将重新初始化。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
&nbsp;<br>
&nbsp;<br>
第十一章 数据结构的传输和XDR标准<br>
·11.1 数据结构的传送<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 网络数据结构传递可能存在以下问题：网络字序问题、浮点数传输、指针处理<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 自定义手工处理方式：<br>
将待发送数据结构转换以后放入应用的发送缓冲区；<br>
将应用的接收缓冲区中数据结构转换以后再进行数据处理。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 代码示例：<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void send_int32_2buf(char *buf, unit32_t n)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; n = htonl(n);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bcopy((char *)&amp;n, buf, sizeof(unit32_t));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void send_string_2buf(char *buf, char*str);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bcopy(str, buf, strlen(str));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void send2_buf(char *buf, struct u_data *ptr)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; send_int32_2buf(buf, ptr-&gt;aInt);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; buf &#43;= sizeof(unit32_t);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; send_string_2buf(buf, ptr-&gt;str);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; buf &#43;= strlen(ptr-&gt;str); // * sizeof(char)<br>
}<br>
void recv_int32_from(char *buf, unit32_t *n)<br>
{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bcopy(buf, (void*)n, sizeof(unit32_t));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *n = ntohl(*n);<br>
}<br>
void recv_from_buf(char *buf, struct u_data *ptr)<br>
{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; recv_int32_from_buf(buf, &amp;(ptr-&gt;aInt));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; buf &#43;= sizeof(uint32_t);<br>
}<br>
&nbsp;<br>
·XDR标准和实现原理<br>
XDR数据结构传输标准是SUN公司设计的，已经成为大多数客户机/服务器应用中的事实上的标准。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
XDR对各种数据类型规定了编码方式。初始化函数是<br>
#include &lt;rpc/xdr.h&gt;<br>
extern void xdrmem_create((XDR *xdrs, const caddr_t addr, u_int size, enum xdr_op xop)); //xdrs是创建后XDR流指针,addr是存放XDR流发送缓冲区<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; XDR的流转换方式和上面自定义方式类&#20284;，但是对各种数据类型的处理做了统一规定。应用程序设计配对的接收和发送，分别处理每个数据项。<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; XDR有内存流和I/O流两种。可以使用内存流，进行套接字缓冲区间的数据结构传输；使用I/O流将编解码的结果输出到文件流中。<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; XDR和TCP都是流的抽象，所以两者可以很好结合。另外XDR提供了面向记录的XDR抽象，应用在UDP传输。<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; XDR转化函数所做操作决定于XDR流本身性质。如果XDR是编码流时，转化函数就做数据编码，如果是解码流时，转换函数就做数据解码。<br>
&nbsp;<br>
第十二章 RPC远程过程调用原理和实现<br>
·RPC的原理<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 使用XDR协议可以让数据结构无差别的在网络传输，使用RPC(remote procedure call)远程过程调用可以使函数在不同主机上运行。RPC所要达到目的是将网络通信功能和应用的需求分开。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RPC的中心是优先考虑应用的分析，在模块功能划分完毕后将其分离出来。这些模块在不同主机上运行，RPC保证模块分离前后的语义不变。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
函数调用的4个原则：<br>
1 把函数所需参数准备好，通过某种方式可以让调用函数访问到。<br>
2 必须包含函数的返回信息<br>
3 能够确定调用函数的位置<br>
4 为调用函数创建可以运行的环境<br>
&nbsp;<br>
其中“本地调用”这是上述四个原则的一种实现，1 通过堆栈段 2 函数返回地址 3 PC指针指向函数入口地址 4 局部变量在函数栈分配，其他数据共享进程数据段<br>
&nbsp;<br>
RPC远程调用模拟本地调用：<br>
我们可以使用定义好的信息&#26684;式保存调用过程参数，在信息&#26684;式中说明如何去找被调用者（通常是某种标志）。然后通过网络将信息报文发送到被调用所在机器上，然后调用者等待被调用方发回的调用结果。【条件1和3】<br>
被调用主机上应有一个分派器控制所有远程调用过程。收到报文后通过其中的标志知道需要调用哪个，取出被调用者需要的参数然后传入。【条件2】<br>
被调用过程在它所在环境中运行，并将运行结果写在信息&#26684;式中，最后网络将调用结果返回。【条件4】<br>
准备函数传入参数 <br>
说明函数如何返回 <br>
确定被调用函数位置 <br>
创建被调用函数环境 <br>
被调用函数运行 <br>
准备运行结果 <br>
切换回调用者的环境 <br>
返回被调用者的结果 </div>
<div><br>
·RPC的实现<br>
远程过程标示：（程序号，远程调用过程版本号，远程过程序号）<br>
&nbsp;<br>
端口的动态映射：每一个远程调用过程都对应占用一个有操作系统动态分配的传输层端口。调用方需要调用一个远程调用过程，它会向端口映射器发送一个请求，然后端口映射器通过查表返回相应远程调用过程的端口号。然后它向远程调用过程发起调用请求。<br>
&nbsp;<br>
RPC的报文：RPC使用XDR语言定义应用的报文。<br>
RPC开发工具：由于ONC RPC协议规程非常复杂，因此系统提供了专门用于开发RPC的工具。注意包括：XDR库函数，RPC运行时间库函数，一些程序的自动生成工具，产生一个构件RPC分布式程序需要的C程序文件，这些程序主要是屏蔽底层通信对应用的影响。<br>
&nbsp;<br>
客户端主要实现：<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 向端口映射器发送请求，并从端口映射器接收回应；形成CALL报文，向真正的远程调用过程发送调用请求，接收来自服务器的调用结果。<br>
服务器段主要实现：<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在提供服务之前向端口映射器注册自己实际端口；将一个调用分派到具体调用程序中的一个调用过程。<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
第十三章 UNIX域套接字和并发服务器的预创建技术<br>
·UNIX域套接字<br>
linux操作系统提供了一种UNIX域协议的进程间通信方式，它不能应用在网络中，能使用在本机两进程间的通信中。它能方便的向两个非亲属关系的进程间传递文件描述符，效果类&#20284;于在父子进程间传递一样。UNIX域套接字在和本地进程进行交互时候效率更高，因为它不需要处理网络异常可能。<br>
&nbsp;<br>
地址结构：<br>
struct sockaddr_un{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short int sun_family;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char sun_path[104];<br>
};<br>
使用示例：<br>
listen_fd = socket(AF_UNIX,SOCK_STREAM,0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //UNIX域套接字<br>
serv_addr.sun_family = AF_UNIX;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //UNIX域协议簇<br>
strcpy(serv_addr.sun_path, “/tmp/myfile”);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //创建绑定文件<br>
unbind(serv_addr.sun_path);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //先解除指定文件的绑定<br>
ret = bind(listen_fd,(struct sockaddr*)&amp;serv_addr,<br>
strlen(serv_addr.sun_path)&#43;sizeof(serv_add.sun_family);&nbsp;&nbsp; //绑定指定文件路径<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; listen(listen_fd, 倾听队列长度);<br>
&nbsp;<br>
·使用sendmsg和recvmsg传递和接收文件描述符<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 主要使用UNIX域套接字，sendmsg和recvmsg两个函数实现。在发送附加数据之前需要自己定义一个联合体。这样附加数据将在内存中置于struct cmsghdr结构之后，同cmsghdr相关宏定义才能正常工作。<br>
示例代码：<br>
void unix_send_fd(int unix_fd, int conn_fd)<br>
{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct msghdr msg;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct iovec iov[1];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char c;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int ret;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; union{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct cmsghdr cm;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char control[CMSG_SPACE(sizeof(int))];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }control_un; //定义联合体，将附加数据置于struct cmsghdr结构之后<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct cmsghdr *cmptr;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //报文套接字使用字段，对于流类型套接字，地址域填为空。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; msg.msg_name = NULL;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; msg.msg_namelen = 0;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //填写普通数据的缓冲区<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iov[0].iov_base = &amp;c;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iov[0].iov_len = 1;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //执行普通数据缓冲区<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; msg.msg_iov = iov;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; msg.msg_iovlen = 1;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //设置附加数据的指针<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; msg.msg_control = control_un.control;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; msg.msg_controllen = sizeof(control_un.control);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //获取结构struct cmsghdr的指针<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmptr = CMSG_FIRSTHDR(&amp;msg);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //获取该结构的长度<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmptr-&gt;cmsg_len = CMSG_LEN(sizeof(int));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //填写控制数据的层次<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmptr-&gt;cmsg_level = SOL_SOCKET;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //填写控制数据的类型<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmptr-&gt;cmsg_type = SCM_RIGHTS;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //填写控制数据的内容<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *(int*)CMSG_DATA(cmptr)=conn_fd;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret = sendmsg(unix_fd, &amp;msg,0);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (ret &lt; 0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; error_proc();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //接收就是上面逆向的过程，先预设接收缓冲，然后cmptr= CMSG_FIRSTHDR(&amp;msg); <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //最后return *(int*)CMSG_DATA(cmptr);<br>
}<br>
&nbsp;<br>
·并发服务器的预创建技术<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 预创建技术可以为并发服务器解决以下几个显著缺点：<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 为新连接上的客户尽快提供服务，消除新建进程的时延<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2 不必为每个客户服务进程都需要建立/释放资源<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3 子进程重复利用率高<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4 通过传递文件描述符，对子进程动态管理<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UNIX套接字对<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int socketpari(int family, int type, int protocol, int sockfd[2]);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //建立两个连接好的套接字对，可以像管道一样使用<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 使用套接字和管道相比有“全双工、可以将文件描述符传递给任何进程”的优点<br>
&nbsp;<br>
&nbsp;<br>
第十四章原始套接字<br>
·14.1 原始套接字<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 类型为0的原始套接字 <br>
ICMP类型原始套接字 <br>
EGP类型原始套接字 <br>
ICMP协议实体 <br>
EGP协议实体 <br>
UDP/TCP处理模块 <br>
UDP/TCP的IP包 <br>
承载ICMP报文IP包 <br>
承载EGP报文IP包 </div>
<div><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 原始套接字的使用：<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 ip_fd=socket(AF_INET,SOCK_RAW,IPPROTO_ICMP); //只允许超级用户建立和使用<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //SOCK_RAW创建原始套接字，第三个参数是协议，可以使用0或其他<br>
&nbsp;<br>
2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bind和connect函数对原始套接字的影响<br>
原始套接字工作在传输层以下所以没有端口的概念。bind一个原始套接字的地址后，核心只把目的地址是该原始套接字的IP包发送给它，忽略其它。调用connect后，核心将传递源地址是connect地址的IP包给这个原始套接字。如果没有bind和connect原始套接字，核心将把所有协议匹配的IP包传递给它。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
IP套接字选项<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getsockopt()函数：IP_TTL获取生存期，IP_HDRINCL自行填充IP包头(可伪造)<br>
&nbsp;<br>
第十五章 多线程编程<br>
·15.1 线程的概念<br>
线程这样一种实体，它被包含在进程实体中，具有自己的运行线索，可以完成一定的任务。它和进程中其他进程共享所有的共享数据以及部分环境，并且可以和其他线程协同完成一定任务。线程常常被成为轻量级进程。<br>
&nbsp;<br>
多个线程将共享同个进程虚空间的环境包括代码段和大部分数据，所以fork需要建立的大量复制创建就不需要，不同线程可以通过共享变量进行数据传输，不需要复杂的IPC机制。<br>
&nbsp;<br>
同个进程的线程将并发运行。线程有独立的：线程ID、寄存器组&#20540;、线程堆栈、错误返回码变量errno、线程信号屏蔽码、线程优先级。<br>
线程ID <br>
32位屏蔽码 <br>
优先级 <br>
信号 <br>
调度器 <br>
进程虚空间<br>
&nbsp;<br>
....................<br>
....................<br>
....................<br>
&nbsp; <br>
大部分数据 <br>
代码段 <br>
程序计数器 <br>
堆栈基址指针 <br>
堆栈栈顶指针 <br>
&nbsp;&nbsp;&nbsp; ....... <br>
寄存器组 </div>
<div><br>
&nbsp;<br>
&nbsp;<br>
·15.2 线程的分类<br>
1 用户线程：<br>
用户线程的实现是通过运行时间系统代码来实现。这部分代码的功能是将线程恢复运行时需要保存的寄存器组信息和其他信息保存在一个结构中，然后将这个结构放在线程调度队列中，然后在线程队列中选择一个优先级最高的线程，而后将结构中保存的信息回复运行这个线程。<br>
&nbsp;<br>
2 内核线程：<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 内核线程切换是通过内核调度器来实现，和普通进程一样是核心调度器实体。<br>
&nbsp;<br>
·15.3 用户线程和内核线程的比较<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 CPU时间的分配<br>
用户线程是通过在进程中连接用户级线程包来实现，所以这个进程的多个线程将竞争CPU分配给这个进程的时间。用户级线程不能在多个CPU环境中同时运行<br>
内核线程和其他进程一起在核心调度器中竞争CPU时间，可以在多CPU环境运行更具良好的并发性<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
2 线程的并发性<br>
除非一个运行中的用户级线程放弃CPU时间去运行进程内的线程切换代码，否则其他线程将不能获取CPU时间。因此一些慢系统调用将引起线程堵塞，而其他线程却无法切换。因此在用户级线程中，可能堵塞的系统调用将被无堵塞的版本取代。也因此这些原因和CPU的时间分配，大大限制了用户级线程的并发性<br>
内核线程在发生堵塞时候，将由核心调度器把CPU时间分配给其他进程或核心线程。<br>
&nbsp;<br>
3线程调度的开销<br>
&nbsp;&nbsp;&nbsp;&nbsp; 用户级线程的调度在进程内所有开销很小；内核线程调度和进程调度类&#20284;，所以开销较大。内核线程的良好并发性是用较大的开销换取，在对于并发性要求不是很高的应用时，用户级线程更加合适。<br>
&nbsp;<br>
·线程函数库的使用<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 略<br>
·线程同步<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 采用无名信号量、互斥锁、条件变量和信号变量、信号处理器等。</div>
</div>
</td>
</tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>

</div>



<!-- Baidu Button BEGIN -->
<div id="bdshare" class="bdshare_t bds_tools get-codes-bdshare" style="float: right;">
<a class="bds_qzone"></a>
<a class="bds_tsina"></a>
<a class="bds_tqq"></a>
<a class="bds_renren"></a>
<a class="bds_t163"></a>
<span class="bds_more">更多</span>
<a class="shareCount"></a>
</div>
<!-- Baidu Button END -->


<!--192.168.100.34-->
<ul class="article_next_prev">
            <li class="prev_article"><span  onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_shangyipian']);location.href='/anghlq/article/details/5631301';">上一篇</span><a href="/anghlq/article/details/5631301" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_shangyipian'])">Signal and SIGIO</a></li>
            <li class="next_article"><span onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_xiayipian']);location.href='/anghlq/article/details/5645325';">下一篇</span><a href="/anghlq/article/details/5645325" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_xiayipian'])">消息的变迁</a></li>
</ul>

<!-- Baidu Button BEGIN -->
<script type="text/javascript" id="bdshare_js" data="type=tools&amp;uid=1536434" ></script>
<script type="text/javascript" id="bdshell_js"></script>
<script type="text/javascript">
    document.getElementById("bdshell_js").src = "http://bdimg.share.baidu.com/static/js/shell_v2.js?cdnversion=" + Math.ceil(new Date()/3600000)
</script>
<!-- Baidu Button END -->

</div>
      <dl class="blog-associat-tag">
        <dt>主题推荐</dt>
        <dd>
                <a href="http://www.csdn.net/tag/读书笔记" target="_blank" class="blog-tage-red" >读书笔记</a> 
                <a href="http://www.csdn.net/tag/网络编程" target="_blank" class="blog-tage-red" >网络编程</a> 
                <a href="http://www.csdn.net/tag/linux" target="_blank" class="blog-tage-red" >linux</a> 
                <a href="http://www.csdn.net/tag/系统管理员" target="_blank" class="blog-tage-red" >系统管理员</a> 
                <a href="http://www.csdn.net/tag/服务器软件" target="_blank" class="blog-tage-red" >服务器软件</a> 
        </dd>
    </dl> 


<dl class="blog-ass-articl tracking-ad"  data-mod="popu_36" id="res-relatived"> 
     <dt><span>猜你在找</span></dt>    
</dl>

<script type="text/javascript">
    var searchtitletags = 'LINUX网络编程的读书笔记' + ',' + '读书笔记,网络编程,linux,系统管理员,服务器软件';
    searchService({
        index: 'blog',
        query: searchtitletags,
        from: 10,
        size: 10,
        appendTo: '#res-relatived',
        url: 'recommend',
        his: 2,
        client: "blog_cf_enhance",
        tmpl: '<dd style="background:url(http://static.blog.csdn.net/skin/default/images/blog-dot-red3.gif) no-repeat 0 10px;"><a href="#{ url }" title="#{ title }" strategy="#{ strategy }">#{ title }</a></dd>'
    });

 </script>   

    <div id="ad_cen">
        <script type="text/javascript">            BAIDU_CLB_SLOT_ID = "117306";</script>
        <script type="text/javascript" src="http://cbjs.baidu.com/js/o.js"></script>
    </div>
    <script type="text/javascript">
        //new Ad(4, 'ad_cen');
    </script>
<div id="comment_title" class="panel_head">
    查看评论<a name="comments"></a></div>
<div id="comment_list">
</div>
<div id="comment_bar">
</div>
<div id="comment_form">
</div>
<div class="announce">
    * 以上用户言论只代表其个人观点，不代表CSDN网站的观点或立场<a name="reply"></a><a name="quote"></a></div>
<script type="text/javascript">
    var fileName = '5635674';
    var commentscount = 0;
    var islock = false
</script>
<script type="text/javascript" src="http://static.blog.csdn.net/scripts/comment.js"></script>
    <div id="ad_bot">
    </div>
    <script type="text/javascript">
    new Ad(5, 'ad_bot');
    </script>
<div id="report_dialog">
</div>

<div id="d-top"  style="bottom:60px;">
      

       <a id="quick-reply" class="btn btn-top q-reply" title="快速回复" style="display:none;">
            <img src="http://static.blog.csdn.net/images/blog-icon-reply.png" alt="快速回复">
        </a>    

    <a id="d-top-a" class="btn btn-top backtop"  style="display: none;" title="返回顶部" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_huidaodingbu'])" style="">         
         <img src="http://static.blog.csdn.net/images/top.png" alt="TOP">
    </a>
</div>
<script type="text/javascript">
    $(function ()
    {
        if($("#comment_content").length>0)
        {
            $("#quick-reply").show();

            $("#quick-reply").click(function(){
                setEditorFocus();
            });
        }       
     
        var d_top = $('#d-top-a');
        document.onscroll = function ()
        {
            var scrTop = (document.body.scrollTop || document.documentElement.scrollTop);
            if (scrTop > 500)
            {
                d_top.show();
            } else
            {
                d_top.hide();
            }
        }
        $('#d-top-a').click(function ()
        {
            scrollTo(0, 0);
            this.blur();
            return false;
        });
    });
  
</script>
<style type="text/css">
    .tag_list
    {
        background: none repeat scroll 0 0 #FFFFFF;
        border: 1px solid #D7CBC1;
        color: #000000;
        font-size: 12px;
        line-height: 20px;
        list-style: none outside none;
        margin: 10px 2% 0 1%;
        padding: 1px;
    }
    .tag_list h5
    {
        background: none repeat scroll 0 0 #E0DBD3;
        color: #47381C;
        font-size: 12px;
        height: 24px;
        line-height: 24px;
        padding: 0 5px;
        margin: 0;
    }
    .tag_list h5 a
    {
        color: #47381C;
    }
    .classify
    {
        margin: 10px 0;
        padding: 4px 12px 8px;
    }
    .classify a
    {
        margin-right: 20px;
        white-space: nowrap;
    }
</style>
<div class="tag_list">
    <h5>
        <a href="http://www.csdn.net/tag/" target="_blank">核心技术类目</a></h5>
    <div class="classify">
<a title="全部主题" href="http://www.csdn.net/tag" target="_blank" onclick="LogClickCount(this,336);">全部主题</a>
<a title="Java" href="http://www.csdn.net/tag/Java" target="_blank" onclick="LogClickCount(this,336);">Java</a>
<a title="VPN" href="http://www.csdn.net/tag/vpn" target="_blank" onclick="LogClickCount(this,336);">VPN</a>
<a title="Android" href="http://www.csdn.net/tag/android" target="_blank" onclick="LogClickCount(this,336);">Android</a>
<a title="iOS" href="http://www.csdn.net/tag/ios" target="_blank" onclick="LogClickCount(this,336);">iOS</a>
<a title="ERP" href="http://www.csdn.net/tag/erp" target="_blank" onclick="LogClickCount(this,336);">ERP</a>
<a title="IE10" href="http://www.csdn.net/tag/ie10" target="_blank" onclick="LogClickCount(this,336);">IE10</a>
<a title="Eclipse" href="http://www.csdn.net/tag/eclipse" target="_blank" onclick="LogClickCount(this,336);">Eclipse</a>
<a title="CRM" href="http://www.csdn.net/tag/crm" target="_blank" onclick="LogClickCount(this,336);">CRM</a>
<a title="JavaScript" href="http://www.csdn.net/tag/javascript" target="_blank" onclick="LogClickCount(this,336);">JavaScript</a>
<a title="Ubuntu" href="http://www.csdn.net/tag/ubuntu" target="_blank" onclick="LogClickCount(this,336);">Ubuntu</a>
<a title="NFC" href="http://www.csdn.net/tag/nfc" target="_blank" onclick="LogClickCount(this,336);">NFC</a>
<a title="WAP" href="http://www.csdn.net/tag/wap" target="_blank" onclick="LogClickCount(this,336);">WAP</a>
<a title="jQuery" href="http://www.csdn.net/tag/jquery" target="_blank" onclick="LogClickCount(this,336);">jQuery</a>
<a title="数据库" href="http://www.csdn.net/tag/数据库" target="_blank" onclick="LogClickCount(this,336);">数据库</a>
<a title="BI" href="http://www.csdn.net/tag/bi" target="_blank" onclick="LogClickCount(this,336);">BI</a>
<a title="HTML5" href="http://www.csdn.net/tag/html5" target="_blank" onclick="LogClickCount(this,336);">HTML5</a>
<a title="Spring" href="http://www.csdn.net/tag/spring" target="_blank" onclick="LogClickCount(this,336);">Spring</a>
<a title="Apache" href="http://www.csdn.net/tag/apache" target="_blank" onclick="LogClickCount(this,336);">Apache</a>
<a title="Hadoop" href="http://www.csdn.net/tag/hadoop" target="_blank" onclick="LogClickCount(this,336);">Hadoop</a>
<a title=".NET" href="http://www.csdn.net/tag/.net" target="_blank" onclick="LogClickCount(this,336);">.NET</a>
<a title="API" href="http://www.csdn.net/tag/api" target="_blank" onclick="LogClickCount(this,336);">API</a>
<a title="HTML" href="http://www.csdn.net/tag/html" target="_blank" onclick="LogClickCount(this,336);">HTML</a>
<a title="SDK" href="http://www.csdn.net/tag/sdk" target="_blank" onclick="LogClickCount(this,336);">SDK</a>
<a title="IIS" href="http://www.csdn.net/tag/iis" target="_blank" onclick="LogClickCount(this,336);">IIS</a>
<a title="Fedora" href="http://www.csdn.net/tag/fedora" target="_blank" onclick="LogClickCount(this,336);">Fedora</a>
<a title="XML" href="http://www.csdn.net/tag/xml" target="_blank" onclick="LogClickCount(this,336);">XML</a>
<a title="LBS" href="http://www.csdn.net/tag/lbs" target="_blank" onclick="LogClickCount(this,336);">LBS</a>
<a title="Unity" href="http://www.csdn.net/tag/unity" target="_blank" onclick="LogClickCount(this,336);">Unity</a>
<a title="Splashtop" href="http://www.csdn.net/tag/splashtop" target="_blank" onclick="LogClickCount(this,336);">Splashtop</a>
<a title="UML" href="http://www.csdn.net/tag/uml" target="_blank" onclick="LogClickCount(this,336);">UML</a>
<a title="components" href="http://www.csdn.net/tag/components" target="_blank" onclick="LogClickCount(this,336);">components</a>
<a title="Windows Mobile" href="http://www.csdn.net/tag/windowsmobile" target="_blank" onclick="LogClickCount(this,336);">Windows Mobile</a>
<a title="Rails" href="http://www.csdn.net/tag/rails" target="_blank" onclick="LogClickCount(this,336);">Rails</a>
<a title="QEMU" href="http://www.csdn.net/tag/qemu" target="_blank" onclick="LogClickCount(this,336);">QEMU</a>
<a title="KDE" href="http://www.csdn.net/tag/kde" target="_blank" onclick="LogClickCount(this,336);">KDE</a>
<a title="Cassandra" href="http://www.csdn.net/tag/cassandra" target="_blank" onclick="LogClickCount(this,336);">Cassandra</a>
<a title="CloudStack" href="http://www.csdn.net/tag/cloudstack" target="_blank" onclick="LogClickCount(this,336);">CloudStack</a>
<a title="FTC" href="http://www.csdn.net/tag/ftc" target="_blank" onclick="LogClickCount(this,336);">FTC</a>
<a title="coremail" href="http://www.csdn.net/tag/coremail" target="_blank" onclick="LogClickCount(this,336);">coremail</a>
<a title="OPhone " href="http://www.csdn.net/tag/ophone " target="_blank" onclick="LogClickCount(this,336);">OPhone </a>
<a title="CouchBase" href="http://www.csdn.net/tag/couchbase" target="_blank" onclick="LogClickCount(this,336);">CouchBase</a>
<a title="云计算" href="http://www.csdn.net/tag/云计算" target="_blank" onclick="LogClickCount(this,336);">云计算</a>
<a title="iOS6" href="http://www.csdn.net/tag/iOS6" target="_blank" onclick="LogClickCount(this,336);">iOS6</a>
<a title="Rackspace " href="http://www.csdn.net/tag/rackspace " target="_blank" onclick="LogClickCount(this,336);">Rackspace </a>
<a title="Web App" href="http://www.csdn.net/tag/webapp" target="_blank" onclick="LogClickCount(this,336);">Web App</a>
<a title="SpringSide" href="http://www.csdn.net/tag/springside" target="_blank" onclick="LogClickCount(this,336);">SpringSide</a>
<a title="Maemo" href="http://www.csdn.net/tag/maemo" target="_blank" onclick="LogClickCount(this,336);">Maemo</a>
<a title="Compuware" href="http://www.csdn.net/tag/compuware" target="_blank" onclick="LogClickCount(this,336);">Compuware</a>
<a title="大数据" href="http://www.csdn.net/tag/大数据" target="_blank" onclick="LogClickCount(this,336);">大数据</a>
<a title="aptech" href="http://www.csdn.net/tag/aptech" target="_blank" onclick="LogClickCount(this,336);">aptech</a>
<a title="Perl" href="http://www.csdn.net/tag/perl" target="_blank" onclick="LogClickCount(this,336);">Perl</a>
<a title="Tornado" href="http://www.csdn.net/tag/tornado" target="_blank" onclick="LogClickCount(this,336);">Tornado</a>
<a title="Ruby" href="http://www.csdn.net/tag/ruby" target="_blank" onclick="LogClickCount(this,336);">Ruby</a>
<a title="Hibernate" href="http://www.csdn.net/hibernate" target="_blank" onclick="LogClickCount(this,336);">Hibernate</a>
<a title="ThinkPHP" href="http://www.csdn.net/tag/thinkphp" target="_blank" onclick="LogClickCount(this,336);">ThinkPHP</a>
<a title="Spark" href="http://www.csdn.net/tag/spark" target="_blank" onclick="LogClickCount(this,336);">Spark</a>
<a title="HBase" href="http://www.csdn.net/tag/hbase" target="_blank" onclick="LogClickCount(this,336);">HBase</a>
<a title="Pure" href="http://www.csdn.net/tag/pure" target="_blank" onclick="LogClickCount(this,336);">Pure</a>
<a title="Solr" href="http://www.csdn.net/tag/solr" target="_blank" onclick="LogClickCount(this,336);">Solr</a>
<a title="Angular" href="http://www.csdn.net/tag/angular" target="_blank" onclick="LogClickCount(this,336);">Angular</a>
<a title="Cloud Foundry" href="http://www.csdn.net/tag/cloudfoundry" target="_blank" onclick="LogClickCount(this,336);">Cloud Foundry</a>
<a title="Redis" href="http://www.csdn.net/tag/redis" target="_blank" onclick="LogClickCount(this,336);">Redis</a>
<a title="Scala" href="http://www.csdn.net/tag/scala" target="_blank" onclick="LogClickCount(this,336);">Scala</a>
<a title="Django" href="http://www.csdn.net/tag/django" target="_blank" onclick="LogClickCount(this,336);">Django</a>
<a title="Bootstrap" href="http://www.csdn.net/tag/bootstrap" target="_blank" onclick="LogClickCount(this,336);">Bootstrap</a>
    </div>
</div>

                    <div class="clear">
                    </div>
                </div>
            </div>
            <div id="side">
    <div class="side">
<div id="panel_Profile" class="panel">
<ul class="panel_head"><span>个人资料</span></ul>
<ul class="panel_body profile">
<div id="blog_userface">
    <a href="http://my.csdn.net/anghlq" target="_blank">
    <img src="http://avatar.csdn.net/8/A/A/1_anghlq.jpg" title="访问我的空间" style="max-width:90%"/>
    </a>
    <br />
    <span><a href="http://my.csdn.net/anghlq" class="user_name" target="_blank">anghlq</a></span>
</div>
<div class="interact">
<a href="javascript:void(0);" class="attent" id="span_add_follow" title="[加关注]" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_guanzhu'])"></a>
<a href="javascript:void(0);" class="letter" onclick="loginto(1)" title="[发私信]" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_sixin'])"></a>
</div>
<div id="blog_medal">
</div>
<ul id="blog_rank">
    <li>访问：<span>335619次</span></li>
    <li>积分：<span>6077分</span></li>
    <li>排名：<span>第954名</span></li>
</ul>
<ul id="blog_statistics">
    <li>原创：<span>252篇</span></li>
    <li>转载：<span>141篇</span></li>
    <li>译文：<span>0篇</span></li>
    <li>评论：<span>68条</span></li>
</ul>
</ul>
</div>


<div class="panel" id="panel_Search">
    <ul class="panel_head"><span>文章搜索</span></ul>
    <ul class="panel_body">
        <form id="frmSearch" action="http://so.csdn.net/search" class="form_search" target="_blank">
        <span><input id="inputSearch" type="text" class="blogsearch" title="请输入关键字" /></span>
        <input id="btnSubmit" type="submit" value="搜索" title="search in blog" />
        <input type="hidden" name="q" id="inputQ" />
        <input type="hidden" name="t" value="blog" />
        <a id="btnSearchBlog" target="_blank"></a>
        </form>
    </ul>
</div><div id="custom_column_22889127" class="panel">
<ul class="panel_head"><span>链接表</span></ul>
<ul class="panel_body">

<div>&nbsp;&nbsp;<a href="http://www.qyjohn.net" target="_blank">蒋清野</a></div>
<div>&nbsp;&nbsp;<a href="http://lisux.tk/lishuai/" target="_blank">李帅</a></div>

</ul>
</div><div id="panel_Category" class="panel">
<ul class="panel_head"><span>文章分类</span></ul>
<ul class="panel_body">
             <li>
                <a href="http://blog.csdn.net/anghlq/article/category/1404472" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">WEB服务器比较和部分源码分析</a><span>(10)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/anghlq/article/category/1403618" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">产品</a><span>(1)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/anghlq/article/category/239354" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">.net学习笔记</a><span>(66)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/anghlq/article/category/252069" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">C/C++</a><span>(26)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/anghlq/article/category/826241" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">IT</a><span>(4)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/anghlq/article/category/310322" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">NetWork</a><span>(23)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/anghlq/article/category/240553" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">WEB编程</a><span>(60)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/anghlq/article/category/825242" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">云在天涯</a><span>(75)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/anghlq/article/category/343956" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">代码片段 C#</a><span>(12)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/anghlq/article/category/250913" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">川大00计科3班足球征战记</a><span>(2)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/anghlq/article/category/290440" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">工具</a><span>(8)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/anghlq/article/category/240275" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">数据库</a><span>(13)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/anghlq/article/category/250651" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">生活</a><span>(6)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/anghlq/article/category/239360" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">程序设计</a><span>(120)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/anghlq/article/category/887391" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">python</a><span>(2)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/anghlq/article/category/903440" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">erlang</a><span>(3)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/anghlq/article/category/931158" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">虚拟机</a><span>(8)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/anghlq/article/category/1102637" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">java</a><span>(3)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/anghlq/article/category/1110460" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">shell</a><span>(5)</span>
            </li>
             <li>
                <a href="http://blog.csdn.net/anghlq/article/category/1348806" onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); ">监控</a><span>(3)</span>
            </li>
</ul>
</div><div id="panel_Archive" class="panel">
<ul class="panel_head"><span>文章存档</span></ul>
<ul class="panel_body">
<div id="archive_list">
<!--归档统计-->
<li><a href="http://blog.csdn.net/anghlq/article/month/2014/05">2014年05月</a><span>(1)</span></li><li><a href="http://blog.csdn.net/anghlq/article/month/2014/03">2014年03月</a><span>(1)</span></li><li><a href="http://blog.csdn.net/anghlq/article/month/2014/02">2014年02月</a><span>(2)</span></li><li><a href="http://blog.csdn.net/anghlq/article/month/2014/01">2014年01月</a><span>(2)</span></li><li><a href="http://blog.csdn.net/anghlq/article/month/2013/12">2013年12月</a><span>(9)</span></li><li><a href="http://blog.csdn.net/anghlq/article/month/2013/11">2013年11月</a><span>(3)</span></li><li><a href="http://blog.csdn.net/anghlq/article/month/2013/10">2013年10月</a><span>(3)</span></li><li><a href="http://blog.csdn.net/anghlq/article/month/2013/09">2013年09月</a><span>(13)</span></li><li><a href="http://blog.csdn.net/anghlq/article/month/2013/08">2013年08月</a><span>(3)</span></li><li><a href="http://blog.csdn.net/anghlq/article/month/2013/07">2013年07月</a><span>(7)</span></li><li><a href="http://blog.csdn.net/anghlq/article/month/2013/06">2013年06月</a><span>(5)</span></li><li><a href="http://blog.csdn.net/anghlq/article/month/2013/05">2013年05月</a><span>(20)</span></li><li><a href="http://blog.csdn.net/anghlq/article/month/2013/04">2013年04月</a><span>(13)</span></li><li><a href="http://blog.csdn.net/anghlq/article/month/2013/03">2013年03月</a><span>(1)</span></li><li><a href="http://blog.csdn.net/anghlq/article/month/2013/02">2013年02月</a><span>(3)</span></li><li><a href="http://blog.csdn.net/anghlq/article/month/2013/01">2013年01月</a><span>(2)</span></li><li><a href="http://blog.csdn.net/anghlq/article/month/2012/12">2012年12月</a><span>(5)</span></li><li><a href="http://blog.csdn.net/anghlq/article/month/2012/09">2012年09月</a><span>(1)</span></li><li><a href="http://blog.csdn.net/anghlq/article/month/2012/08">2012年08月</a><span>(2)</span></li><li><a href="http://blog.csdn.net/anghlq/article/month/2012/07">2012年07月</a><span>(3)</span></li><li><a href="http://blog.csdn.net/anghlq/article/month/2012/05">2012年05月</a><span>(5)</span></li><li><a href="http://blog.csdn.net/anghlq/article/month/2012/04">2012年04月</a><span>(4)</span></li><li><a href="http://blog.csdn.net/anghlq/article/month/2012/03">2012年03月</a><span>(6)</span></li><li><a href="http://blog.csdn.net/anghlq/article/month/2012/01">2012年01月</a><span>(1)</span></li><li><a href="http://blog.csdn.net/anghlq/article/month/2011/12">2011年12月</a><span>(7)</span></li><li><a href="http://blog.csdn.net/anghlq/article/month/2011/11">2011年11月</a><span>(6)</span></li><li><a href="http://blog.csdn.net/anghlq/article/month/2011/10">2011年10月</a><span>(10)</span></li><li><a href="http://blog.csdn.net/anghlq/article/month/2011/09">2011年09月</a><span>(7)</span></li><li><a href="http://blog.csdn.net/anghlq/article/month/2011/08">2011年08月</a><span>(6)</span></li><li><a href="http://blog.csdn.net/anghlq/article/month/2011/07">2011年07月</a><span>(4)</span></li><li><a href="http://blog.csdn.net/anghlq/article/month/2011/06">2011年06月</a><span>(15)</span></li><li><a href="http://blog.csdn.net/anghlq/article/month/2011/05">2011年05月</a><span>(18)</span></li><li><a href="http://blog.csdn.net/anghlq/article/month/2011/04">2011年04月</a><span>(4)</span></li><li><a href="http://blog.csdn.net/anghlq/article/month/2011/03">2011年03月</a><span>(2)</span></li><li><a href="http://blog.csdn.net/anghlq/article/month/2011/02">2011年02月</a><span>(2)</span></li><li><a href="http://blog.csdn.net/anghlq/article/month/2011/01">2011年01月</a><span>(5)</span></li><li><a href="http://blog.csdn.net/anghlq/article/month/2010/12">2010年12月</a><span>(4)</span></li><li><a href="http://blog.csdn.net/anghlq/article/month/2010/11">2010年11月</a><span>(3)</span></li><li><a href="http://blog.csdn.net/anghlq/article/month/2010/10">2010年10月</a><span>(1)</span></li><li><a href="http://blog.csdn.net/anghlq/article/month/2010/09">2010年09月</a><span>(6)</span></li><li><a href="http://blog.csdn.net/anghlq/article/month/2010/08">2010年08月</a><span>(3)</span></li><li><a href="http://blog.csdn.net/anghlq/article/month/2010/07">2010年07月</a><span>(3)</span></li><li><a href="http://blog.csdn.net/anghlq/article/month/2010/06">2010年06月</a><span>(8)</span></li><li><a href="http://blog.csdn.net/anghlq/article/month/2010/05">2010年05月</a><span>(10)</span></li><li><a href="http://blog.csdn.net/anghlq/article/month/2010/04">2010年04月</a><span>(3)</span></li><li><a href="http://blog.csdn.net/anghlq/article/month/2009/11">2009年11月</a><span>(1)</span></li><li><a href="http://blog.csdn.net/anghlq/article/month/2009/10">2009年10月</a><span>(1)</span></li><li><a href="http://blog.csdn.net/anghlq/article/month/2009/08">2009年08月</a><span>(1)</span></li><li><a href="http://blog.csdn.net/anghlq/article/month/2009/06">2009年06月</a><span>(2)</span></li><li><a href="http://blog.csdn.net/anghlq/article/month/2009/01">2009年01月</a><span>(1)</span></li><li><a href="http://blog.csdn.net/anghlq/article/month/2008/12">2008年12月</a><span>(1)</span></li><li><a href="http://blog.csdn.net/anghlq/article/month/2008/11">2008年11月</a><span>(1)</span></li><li><a href="http://blog.csdn.net/anghlq/article/month/2008/10">2008年10月</a><span>(1)</span></li><li><a href="http://blog.csdn.net/anghlq/article/month/2008/08">2008年08月</a><span>(1)</span></li><li><a href="http://blog.csdn.net/anghlq/article/month/2008/06">2008年06月</a><span>(1)</span></li><li><a href="http://blog.csdn.net/anghlq/article/month/2008/05">2008年05月</a><span>(17)</span></li><li><a href="http://blog.csdn.net/anghlq/article/month/2008/04">2008年04月</a><span>(1)</span></li><li><a href="http://blog.csdn.net/anghlq/article/month/2008/02">2008年02月</a><span>(1)</span></li><li><a href="http://blog.csdn.net/anghlq/article/month/2008/01">2008年01月</a><span>(1)</span></li><li><a href="http://blog.csdn.net/anghlq/article/month/2007/12">2007年12月</a><span>(2)</span></li><li><a href="http://blog.csdn.net/anghlq/article/month/2007/11">2007年11月</a><span>(2)</span></li><li><a href="http://blog.csdn.net/anghlq/article/month/2007/10">2007年10月</a><span>(5)</span></li><li><a href="http://blog.csdn.net/anghlq/article/month/2007/09">2007年09月</a><span>(2)</span></li><li><a href="http://blog.csdn.net/anghlq/article/month/2007/08">2007年08月</a><span>(5)</span></li><li><a href="http://blog.csdn.net/anghlq/article/month/2007/07">2007年07月</a><span>(9)</span></li><li><a href="http://blog.csdn.net/anghlq/article/month/2007/06">2007年06月</a><span>(14)</span></li><li><a href="http://blog.csdn.net/anghlq/article/month/2007/05">2007年05月</a><span>(9)</span></li><li><a href="http://blog.csdn.net/anghlq/article/month/2007/04">2007年04月</a><span>(11)</span></li><li><a href="http://blog.csdn.net/anghlq/article/month/2007/03">2007年03月</a><span>(4)</span></li><li><a href="http://blog.csdn.net/anghlq/article/month/2007/02">2007年02月</a><span>(3)</span></li><li><a href="http://blog.csdn.net/anghlq/article/month/2007/01">2007年01月</a><span>(3)</span></li><li><a href="http://blog.csdn.net/anghlq/article/month/2006/12">2006年12月</a><span>(5)</span></li><li><a href="http://blog.csdn.net/anghlq/article/month/2006/11">2006年11月</a><span>(22)</span></li><li><a href="http://blog.csdn.net/anghlq/article/month/2006/10">2006年10月</a><span>(9)</span></li><li><a href="http://blog.csdn.net/anghlq/article/month/2006/09">2006年09月</a><span>(18)</span></li>
</div>
</ul>
</div>
<div id="newcomments" class="panel">
<ul class="panel_head"><span>最新评论</span></ul>
<ul class="panel_body itemlist">
    <li>
   
         <a href="/anghlq/article/details/6545431#comments">Linux容器虚拟技术LXC简明手册</a>
    <p style="margin:0px;"><a href="/anghlq" class="user_name">anghlq</a>:
@syy0422:试试root/root
    </p>
    </li>
    <li>
   
         <a href="/anghlq/article/details/12654119#comments">nginx + fcgi的 header问题</a>
    <p style="margin:0px;"><a href="/syy0422" class="user_name">syy0422</a>:
hi看了你LXC安装容器的文章请问http://ftp.us.debian.org/debian/ ...
    </p>
    </li>
    <li>
   
         <a href="/anghlq/article/details/12654119#comments">Linux容器虚拟技术LXC简明手册</a>
    <p style="margin:0px;"><a href="/syy0422" class="user_name">syy0422</a>:
请问 http://ftp.us.debian.org/debian/  这里下载的系统 用户名密码...
    </p>
    </li>
    <li>
   
         <a href="/anghlq/article/details/6538115#comments">HBase vs  Cassandra</a>
    <p style="margin:0px;"><a href="/yima1006" class="user_name">yima1006</a>:
谢谢分享
    </p>
    </li>
    <li>
   
         <a href="/anghlq/article/details/11017023#comments">hypertable使用问题</a>
    <p style="margin:0px;"><a href="/anghlq" class="user_name">anghlq</a>:
@llysonylin:之前成功过没?如果成功过，重启一下namenode试试
    </p>
    </li>
    <li>
   
         <a href="/anghlq/article/details/11017023#comments">hypertable使用问题</a>
    <p style="margin:0px;"><a href="/llysonylin" class="user_name">llysonylin</a>:
@anghlq:我看那个dfsbroker日志已经起来了，唯一比较奇怪的是，ESTABLISH后，立...
    </p>
    </li>
    <li>
   
         <a href="/anghlq/article/details/11017023#comments">hypertable使用问题</a>
    <p style="margin:0px;"><a href="/anghlq" class="user_name">anghlq</a>:
@llysonylin:检查一下1. 检查日志DfsBroker.hadoop.log2. hdfs...
    </p>
    </li>
    <li>
   
         <a href="/anghlq/article/details/11017023#comments">hypertable使用问题</a>
    <p style="margin:0px;"><a href="/llysonylin" class="user_name">llysonylin</a>:
大侠能否帮忙看看1380630612 ERROR Hypertable.Master : main ...
    </p>
    </li>
    <li>
   
         <a href="/anghlq/article/details/5631301#comments">Signal and SIGIO</a>
    <p style="margin:0px;"><a href="/tanqiuwei" class="user_name">tanqiuwei</a>:
csdn很垃圾啊，为啥文章不能直接转载呢
    </p>
    </li>
    <li>
   
         <a href="/anghlq/article/details/6444386#comments">全虚拟化和半虚拟化</a>
    <p style="margin:0px;"><a href="/scztg" class="user_name">scztg</a>:
vmware的ESX 那还是应该属于全虚拟化吧，Workstation可能算作半虚拟化。
    </p>
    </li>
</ul>
</div>
    </div>
    <div class="clear">
    </div>
</div>

            <div class="clear">
            </div>
        </div>
        

<script type="text/javascript" src="http://static.blog.csdn.net/scripts/newblog.min.js"></script>
<script type="text/javascript" src="http://medal.blog.csdn.net/showblogmedal.ashx?blogid=154537"></script>
<script type="text/javascript">
    document.write('<script type="text/javascript" src="http://csdnimg.cn/pubfooter/js/publib_footer.js?' + Math.floor(new Date() / 120000).toString(36) + '="></' + 'script>');
</script>
    <script type="text/javascript" src="http://passport.csdn.net/content/loginbox/login.js"></script>
<script type="text/javascript">document.write("<img src=http://counter.csdn.net/pv.aspx?id=24 border=0 width=0 height=0>");</script>
<script type="text/javascript" src="http://www.csdn.net/ui/scripts/Csdn/counter.js"></script>
<script type="text/javascript" src="http://ad.csdn.net/scripts/ad-blog.js"></script>
<script type="text/javascript" src="http://zz.csdn.net/js/count.js"></script>
<script type="text/javascript">
    $(function () {
        function __get_code_toolbar(snippet_id) {
            return $("<a href='https://code.csdn.net/snippets/"
                    + snippet_id
                    + "' target='_blank' title='在CODE上查看代码片' style='text-indent:0;'><img src='https://code.csdn.net/assets/CODE_ico.png' width=12 height=12 alt='在CODE上查看代码片' style='position:relative;top:1px;left:2px;'/></a>"
                    + "<a href='https://code.csdn.net/snippets/"
                    + snippet_id
                    + "/fork' target='_blank' title='派生到我的代码片'  style='text-indent:0;'><img src='https://code.csdn.net/assets/ico_fork.svg' width=12 height=12 alt='派生到我的代码片' style='position:relative;top:2px;left:2px;'/></a>");
        }
        
        $("[code_snippet_id]").each(function () {
            __s_id = $(this).attr("code_snippet_id");
            if (__s_id != null && __s_id != "" && __s_id != 0 && parseInt(__s_id) > 70020) {
                __code_tool = __get_code_toolbar(__s_id);
                $(this).prev().find(".tools").append(__code_tool);
            }
        });
    });
</script>

    </div>
      <!--new top-->
    
    <script id="csdn-toolbar-id" btnId="header_notice_num" wrapId="note1" count="5" subCount="5" type="text/javascript" src="http://static.csdn.net/public/common/toolbar/js/toolbar.js"></script>     <!--new top-->
</body>
</html>

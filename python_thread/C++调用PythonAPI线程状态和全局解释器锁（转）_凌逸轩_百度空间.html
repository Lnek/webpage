               <!DOCTYPE html><html  id="customDoc"><!--STATUS OK--> <head> <meta http-equiv=Content-Type content="text/html; charset=utf-8"> <title> C++调用PythonAPI线程状态和全局解释器锁（转）_凌逸轩_百度空间</title> <link rel="shortcut icon" href="http://hi.bdimg.com/static/qbase/img/mod/16_favicon.ico?v=116ba471.ico" type=image/x-icon>   <meta name=keywords content="C++调用PythonAPI线程状态和全局解释器锁（转）,Python"> <meta name=description content="阅读、书写、观察、思考、分享……,C++调用PythonAPI线程状态和全局解释器锁（转）"><script>window.wpo={start:new Date*1,pid:109,page:'qing'}</script><!--[if IE]><script type="text/javascript">(function(){var e="abbr,article,aside,audio,canvas,datalist,details,dialog,eventsource,figure,footer,header,hgroup,mark,menu,meter,nav,output,progress,section,time,video".split(","),t=e.length;while(t--)document.createElement(e[t])})();</script><![endif]--><script>window.qDomain={"qing":"http://hi.baidu.com","static":"http://hi.bdimg.com","passport":"https://passport.baidu.com","portrait":"http://tx.bdimg.com","hiup":"http://hi.baidu.com","photo":"http://hiphotos.baidu.com","message":"http://msg.baidu.com","friend":"http://frd.baidu.com","mp3":"http://mp3.baidu.com","ting":"http://ting.baidu.com","image":"http://img.baidu.com","qup":"http://upload.hi.baidu.com","www":"http://www.baidu.com"};window.qUserInfo={"userName":"Handy_Zhou","nickname":"Handy_Zhou","portrait":"012576747161676a7861676471727479731903","qingUrl":"\/vtqagjxagdqrtys","spaceName":"凌逸轩","right":"0","avatarStatus":"1","flagNeedInvite":"0","flagNotInvited":"0","version":"2"};window.qVisitorInfo={"userName":"zhu__feng001","nickname":"zhu__feng001","portrait":"a0a27a68755f5f66656e673030314312","isHost": false,"isRandUrl": false,"isForceMoved": false,"loginStatus":"activated","isOldUser":0,"qingUrl":"\/zhu__feng001","right":"0","version":"2"};window.qPageInfo={"pageUrl":"http:\/\/hi.baidu.com\/vtqagjxagdqrtys\/item\/e8498282f5c1615e850fab57","referUrl":"http:\/\/www.baidu.com\/link?url=Oq-xLzfHzmAUJEGdDNdmEUyNS_RMsJIVtE84wHw945gGzRB762AqaXdrntduNmQxEVs8AEseHPCEJ-6CAwedOnB9aJ5eb4ufSRvJGASNZaS&wd=Py_BEGIN_ALLOW_THREADS&issp=1&ie=utf-8&tn=baiduhome_pg&inputT=891"};window.qUserAvatar={size20:"http://hiphotos.baidu.com/space/scrop=20;q=100/sign=a35f78010f2442a7aa50bafaa17e9f7b/a71ea8d3fd1f4134aa0447fc251f95cad1c85e04.jpg",size40:"http://hiphotos.baidu.com/space/scrop=40;q=100/sign=322a3515d933c895a220df24a12e47c0/a71ea8d3fd1f4134aa0447fc251f95cad1c85e04.jpg",size65:"http://hiphotos.baidu.com/space/scrop=65;q=100/sign=e43dbf27d143ad4ba270019ff23f6c9a/a71ea8d3fd1f4134aa0447fc251f95cad1c85e04.jpg",size110:"http://hiphotos.baidu.com/space/scrop=110;q=100/sign=4f007b41d7ca7bcb79258070ce345a52/a71ea8d3fd1f4134aa0447fc251f95cad1c85e04.jpg",size160:"http://hiphotos.baidu.com/space/scrop=160;q=100/sign=4f007b41d7ca7bcb79258070ce345a55/a71ea8d3fd1f4134aa0447fc251f95cad1c85e04.jpg"};window.qVisitorAvatar={size20:"http://hiphotos.baidu.com/space/scrop=20;q=100/sign=2d5c86b397dda144de572bedc28ae292/54fbb2fb43166d226ec13734462309f79152d2df.jpg",size40:"http://hiphotos.baidu.com/space/scrop=40;q=100/sign=b656b6d4ad345982c1d4a2cd7cc9059d/54fbb2fb43166d226ec13734462309f79152d2df.jpg",size65:"http://hiphotos.baidu.com/space/scrop=65;q=100/sign=8cbf4e12b2b7d0a27f9743c2bbd2403c/54fbb2fb43166d226ec13734462309f79152d2df.jpg",size110:"http://hiphotos.baidu.com/space/scrop=110;q=100/sign=f08bad31cd11728b3473cb7db8c1f2ff/54fbb2fb43166d226ec13734462309f79152d2df.jpg",size160:"http://hiphotos.baidu.com/space/scrop=160;q=100/sign=f08bad31cd11728b3473cb7db8c1f2f8/54fbb2fb43166d226ec13734462309f79152d2df.jpg"};window.qBdsToken="60ac965b2cea775b448a2b0bffbc4424";window.qErrorInfo={"no":"0","msg":""};window.qServerInfo={"timeStamp":"1398672751"};window.qLongPolling={"url":"http:\/\/m.hi.baidu.com\/i\/msg\/listen"}</script><!--[if (lt IE 8.0)]><link href="http://hi.bdimg.com/static/qbase/css/qbase.css?v=d097b2a7.css" type=text/css rel=stylesheet><![endif]--><!--[if (!IE)|(gte IE 8.0)]><!--><link href="http://hi.bdimg.com/static/qbase/css/qbase_datauri.css?v=c2391e47.css" type=text/css rel=stylesheet><!--<![endif]-->     <!--[if (lt IE 8.0)]><link rel=stylesheet type=text/css href="http://hi.bdimg.com/static/qcomment/css/qcomment.css?v=5ba753ab.css"><![endif]--><!--[if (!IE)|(gte IE 8.0)]><!--><link rel=stylesheet type=text/css href="http://hi.bdimg.com/static/qcomment/css/qcomment_datauri.css?v=a90beb01.css"><!--<![endif]--><link rel=stylesheet type=text/css href="http://hi.bdimg.com/static/qhome/css/common/mod_userInfo.css?v=86bf4259.css">   <!--[if (lt IE 8.0)]><link type=text/css rel=stylesheet href="http://hi.bdimg.com/static/qhome/css/detail/20001/detail.css?v=635ae796.css"><![endif]--><!--[if (!IE)|(gte IE 8.0)]><!--><link type=text/css rel=stylesheet href="http://hi.bdimg.com/static/qhome/css/detail/20001/detail_datauri.css?v=0f094a12.css"><!--<![endif]-->    <link rel=stylesheet type=text/css href="http://hi.bdimg.com/static/qpublish/css/editor/shCoreDefault.css?v=79e715f0.css">     <script src="http://hi.bdimg.com/static/qbase/js/qing/qing.js?v=4d5f41d2.js"></script>  <script>
    /*最终页页面变量*/ 
    window.detailPage = {
        threadId : "e8498282f5c1615e850fab57",
        blogTitle: "C++调用PythonAPI线程状态和全局解释器锁（转）" || "无标题",
        contentType : "text",
        originAuthorName : "",
        originPortrait : "",
        originThreadId : ""
    }; 
    </script><script>wpo.head=new Date*1;</script> </head> <body>  <header class=mod-topbar id=modTopbar><iframe class=mod-topbar-bgframe></iframe><div class=mod-topbar-pseudo-real><div class="wrapper-box clearfix"><div class=left-box><a href="http://hi.baidu.com" class=logo-box><span id=baiduSpaceLogo class=q-logo></span></a></div> <div class=center-box><ul class=q-menubox> <li class="q-menuitem "><a href="http://hi.baidu.com/home">首页</a><li class="q-menuitem "><a href="http://hi.baidu.com/zhu__feng001">我的主页</a><li class="q-menuitem q-newicon"><a target=_blank href="http://hi.baidu.com/zhu__feng001/albums">相册</a><li class="q-menuitem " id=qMenuRecommend><a href="http://hi.baidu.com/index/">广场</a><li class="q-menuitem q-newicon q-menu-item-game"><a href=http://youxi.baidu.com/yxpm/pm.jsp?pid=10106000091_970983 target=_blank>游戏</a><div class=q-game-frame><iframe src=about:blank frameborder=no border=0 scrolling=0></iframe></div></ul></div>  <div class=right-box><ul class=q-navbox>  <li class=q-navitem> <a href="http://hi.baidu.com/zhu__feng001/qfriend/show/follow#search">昵称搜索</a>  <li class="q-navitem q-nav-sp"><span></span> <li class=q-navitem> <div class=q-msg-unread-tips> <div class=left><a href="http://hi.baidu.com/qmsg" id=qNavRightMsg>消息<span id =qMsgUnReadTips>&nbsp</span></a></div> </div>  <li class="q-navitem q-nav-sp"><span></span> <li class=q-navitem> <a href="http://msg.baidu.com" id=qNavRightLetter target=_blank>私信<span id=qUnreadNumLetter></span></a>  <li class="q-navitem q-nav-sp"><span></span> <li class=q-navitem id=qThemeNav> <a href="http://hi.baidu.com/set/show/theme" id=qNavRightTheme>模板</a>  <li class="q-navitem q-nav-sp"><span></span> <li class=q-navitem> <a href="http://hi.baidu.com/set/show/profile" id=qNavRightSet>设置</a>  <li class="q-navitem q-nav-sp"><span></span> <li class=q-navitem><a href="https://passport.baidu.com?logout&bdstoken=60ac965b2cea775b448a2b0bffbc4424&u=http://hi.baidu.com/vtqagjxagdqrtys/item/e8498282f5c1615e850fab57" id=qNavRightExit>退出</a> </ul><div class="right mod-qhome-follow-box"><a href="#" class="follow-btn a-btn-follow qing-stat-nsclick" data-nsclick=20121012follow_hdbtnaddcare>关注此空间</a></div> </div> </div></div></header>  <section class=mod-page-body> <div class="mod-page-main wordwrap clearfix">  <div class=x-page-container>    <section class="mod-topspaceinfo mod-cs-header"><div class=head-topbar></div><div class=container><h1><a class="space-name cs-header-spacename" href="/vtqagjxagdqrtys">凌逸轩</a></h1><p class="space-description cs-header-spacesummary">阅读、书写、观察、思考、分享……</p></div><div class=head-footer></div></section>   <div class=mod-blogpage-wraper> <div class="blog-bg-main-repeat hide"></div>  <div class="grid-80 mod-blogpage"> <div class="blog-bg-main hide"></div>    <div class="mod-text-content mod-post-content mod-cs-contentblock"> <div class=cs-contentblock-bg></div>   <div class="content-head clearfix">  <div class=content-other-info>  <span>2009-05-08 14:29</span>  </div>   <h2 class="title content-title">C++调用PythonAPI线程状态和全局解释器锁（转）</h2>  </div>  <div id=content class="content mod-cs-content text-content clearfix"> <p>Python 解释器不是完全线程安全的。当前线程想要安全访问 Python 对象的前提是获取用以支持多线程安全的全局锁。没有锁，甚至多线程程序中最简单的操作都会发生问题。例如，两个线程同时增加一个对象的引用计数，该引用计数可能只增加了一次而非两次。</p><p>因此，存在一个规则：只有获得了全局解释器锁的线程才能操作 Python 对象或者调用 Python/C API 函数。为了支持多线程 Python 编程，解释器有规律的释放和回收锁&mdash;&mdash;默认情况下，每100字节指令集循环一次（可以通过sys.setcheckinterval()设置）。类似文件读写之类的 i/o 片也会随锁释放和回收，这样其它的线程在请求 I/O 操作的线程等待I/O操作完成的时候也可以运行。</p><p>Python解释器需要为每个独立的线程保留一些薄记信息&mdash;&mdash;为此它使用一个称为PyThreadState的数据结构。然而，这是一个全局变量：当前 PyThreadState 结构的指针。尽管大多数线程包都有办法保存&ldquo;每线程全局数据&rdquo;，Python 的内置平台无关线程指令还不支持它。因此，必须明确操作当前的线程状态。</p><p><a name="line-27"></a><a name="line-28"></a>大多数境况下这都是很简单的。全局解释器锁的操作代码主要是以下结构：</p>1 Save the thread state in a local variable.        2 Release the interpreter lock.        3 ...Do some blocking I/O operation...        4 Reacquire the interpreter lock.        5 Restore the thread state from the local variable.<p><a name="line-37"></a><a name="line-38"></a>This is so common that a pair of macros exists to simplify it: </p><p><a name="line-39"></a><a name="line-40"></a>这种方式如此通用，我们可以用一对现成的宏来简化它：</p> 1 Py_BEGIN_ALLOW_THREADS        2 ...Do some blocking I/O operation...        3 Py_END_ALLOW_THREADS<p><a name="line-47"></a><a name="line-48"></a>The Py_BEGIN_ALLOW_THREADS macro opens a new block and declares a hidden local variable; the Py_END_ALLOW_THREADS macro closes the block. Another advantage of using these two macros is that when Python is compiled without thread support, they are defined empty, thus saving the thread state and lock manipulations. </p><p><a name="line-49"></a><a name="line-50"></a>Py_BEGIN_ALLOW_THREADS 宏打开一个新的 block 并且定义一个隐藏的局部变量；Py_END_ALLOW_THREADS 宏关闭这个 block 。这两个宏还有一个高级的用途：如果 Python 编译为不支持线程的版本，他们定义为空，因此保存线程状态并锁定操作。</p><p><a name="line-51"></a><a name="line-52"></a>When thread support is enabled, the block above expands to the following code: </p><p><a name="line-53"></a><a name="line-54"></a>如果支持线程，这个 block 就会展开为以下代码：</p>1     PyThreadState *_save;        2         3     _save = PyEval_SaveThread();        4     ...Do some blocking I/O operation...        5     PyEval_RestoreThread(_save);<p><a name="line-63"></a><a name="line-64"></a>Using even lower level primitives, we can get roughly the same effect as follows: </p><p><a name="line-65"></a><a name="line-66"></a>使用更低级的元素，我们可以获得同样的效果：</p>1     PyThreadState *_save;       2        3     _save = PyThreadState_Swap(NULL);       4     PyEval_ReleaseLock();       5     ...Do some blocking I/O operation...       6     PyEval_AcquireLock();       7     PyThreadState_Swap(_save);<p> </p><p><a name="line-79"></a><a name="line-80"></a>这里有些微妙的不同，细节上，因为锁操作不保证全局变量 erron 的一致，PyEval_RestoreThread() 保存和恢复 errno。同样，不支持线程时，PyEval_SaveThread() 和 PyEval_RestoreThread() 不操作锁，在这种情况下 PyEval_ReleaseLock() 和 PyEval_AcquireLock() 不可用。这使得不支持线程的解释器可以动态加载支持线程的扩展。</p><p><a name="line-83"></a><a name="line-84"></a>全局解释器锁用于保护当前线程状态的指针。当事方锁并保存状态的时候，当前线程状态指针必须在锁释放之前回收（因为另一个指针将会随之获取锁并且在全局变量中保存它自己的线程状态）。相反，获取锁并恢复线程状态的时候，锁必须在保存状态指针之前就获得。</p><p><a name="line-87"></a><a name="line-88"></a>为什么我要对这些进行详细介绍？因为从 C 中创建线程的时候，它们没有全局解释器锁，也没有对应的线程状态数据结构。这些线程在他们使用 Python/C API 之前必须自举，首先要创建线程状态数据结构，然后获取锁，最后保存它们的线程状态指针。完成工作之后，他们可以重置线程状态指针，释放锁，最后释放他们的线程数据结构。</p><p><a name="line-92"></a>自2.3版开始，线程可以使用 PyGILState_*()函数方便的自动获取以上的所有功能。从C线程中进入 Python 调用的典型方法现在变成：</p>1     PyGILState_STATE gstate;       2     gstate = PyGILState_Ensure();       3       4     /* Perform Python actions here.  */       5     result = CallSomeFunction();       6     /* evaluate result */       7        8     /* Release the thread. No Python API allowed beyond this point. */       9     PyGILState_Release(gstate);<p><a name="line-107"></a><a name="line-108"></a><a name="line-109"></a>注意 PyGILState_*() 函数假定只有一个全局解释器（由 Py_Initialize() 自动创建）。Python 还支持创建附加的解释器（通过 Py_NewInterpreter()），但是 PyGILState_*() 不支持混合多解释器。</p><a name="head-04911e5f7c02fdd6a699562d3776fe44e2496513"></a>1. PyInterpreterState<p><a name="line-114"></a><a name="line-115"></a>这个数据结构描述几个协作线程共享的状态。属于同一个解释器的线程共享它们的模块维护和几个其它的内部子项。这个结构没有公开成员。</p><p>属于不同解释器的线程除了可用内存、打开的文件描述符之类的进程状态不共享任何东西。全局解释器锁也由所有线程共享，与它们所属的解释器无关。</p><a name="head-aa513e6d42df9e4dbc54f4429c16a5a46fe28465"></a>2. PyThreadState<p>这个数据结构描述了单个线程的状态。唯一的数据成员是 PyInterpreterState *interp，这个线程的解释器状态。</p><a name="head-f9969ddb5d4cd70c89ed1ca17a572202cfc608ec"></a>3. void PyEval_InitThreads( )<p><a name="line-126"></a><a name="line-127"></a><a name="line-128"></a><a name="line-129"></a> </p><p><a name="line-130"></a><a name="line-131"></a>初始化和获取全局解释器锁。它应该在主线程中创建，并且应该在第二个线程创建或者类似 PyEval_ReleaseLock() 或 PyEval_ReleaseThread(tstate) 之类的线程操作之前。它不需要在 PyEval_SaveThread() 或 PyEval_RestoreThread()之前调用。</p><p><a name="line-132"></a><a name="line-133"></a>This is a no-op when called for a second time. It is safe to call this function before calling Py_Initialize(). </p><p><a name="line-134"></a><a name="line-135"></a>第二次调用没有操作（不做任何事情）。它可以在 Py_Initialize() 被调用之前安全调用。</p><p><a name="line-137"></a> </p><p><a name="line-138"></a><a name="line-139"></a>只有一个主线程的时候，不需要锁操作。这是通常的情景（大多数 Python 程序员不用线程），锁操作稍微拖慢了解释器。因此，锁没有从一开始就创建。这种情况等同于已经获取了锁：只有一个线程的时候，所有的对象访问都是安全的。因此，当该函数初始化锁，它也可以获得锁。Python 线程模块创建一个新的线程之前，它调用PyEval_InitThreads()，了解有锁或者还没有创建锁。当这个调用返回时，它确保锁以被创建，并且调用的线程已经得到它。</p><p><a name="line-140"></a><a name="line-141"></a>It is not safe to call this function when it is unknown which thread (if any) currently has the global interpreter lock. </p><p><a name="line-142"></a><a name="line-143"></a>当前拥有全局解释器锁的线程（或其它什么）未知时，调用这个函数不安全。</p><p><a name="line-144"></a><a name="line-145"></a>This function is not available when thread support is disabled at compile time. </p><p><a name="line-146"></a><a name="line-147"></a>编译时如果不支持线程，这个函数不可用。</p><a name="head-998ee9176aed8cd84f08096b545de890cd35a24e"></a>4. int PyEval_ThreadsInitialized( )<p><a name="line-148"></a><a name="line-149"></a><a name="line-150"></a><a name="line-151"></a> </p><p><a name="line-152"></a><a name="line-153"></a>如果 PyEval_InitThreads() 已经被调用，这个函数返回非0值。因为单线程的时候可以不调用锁 API，这个函数可以在没有获得锁的情况下使用。这个函数在编译时禁用线程支持的情况下不可用。2.4版新加入。</p><a name="head-ebbd8d61e5bd493246fe6df360e5928c2afd90d6"></a>5. void PyEval_AcquireLock( )<p><a name="line-154"></a><a name="line-155"></a><a name="line-156"></a><a name="line-157"></a> </p><p><a name="line-158"></a><a name="line-159"></a>获取全局解释器锁。锁必须提前创建。如果线程已经得到锁，会发生死锁。这个函数在编译时禁用线程支持的情况下不可用。</p><a name="head-a5d77cc7b3f2ea1e97c1982bee27b3ce2808d1fc"></a>6. void PyEval_ReleaseLock( )<p><a name="line-160"></a><a name="line-161"></a><a name="line-162"></a><a name="line-163"></a> </p><p><a name="line-164"></a><a name="line-165"></a>释放全局解释器锁。锁必须提前创建。这个函数在编译时禁用线程支持的情况下不可用。</p><a name="head-befc8942c33c179c363fea0315f8903411acd0fc"></a>7. void PyEval_AcquireThread( PyThreadState *tstate)<p><a name="line-166"></a><a name="line-167"></a><a name="line-168"></a><a name="line-169"></a> </p><p><a name="line-170"></a><a name="line-171"></a>获得全局解释器锁并将当前线程状态设定为 tstate ，它不能为NULL。锁必须提前创建。如果线程已经拥有锁，会发生死锁。这个函数在编译时禁用线程支持的情况下不可用。</p><a name="head-afd50bb8b551d1efc016f5ff4e6990edb1ff0c04"></a>8. void PyEval_ReleaseThread( PyThreadState *tstate)<p><a name="line-172"></a><a name="line-173"></a><a name="line-174"></a><a name="line-175"></a> </p><p><a name="line-176"></a><a name="line-177"></a>重置当前线程状态为NULL并释放全局解释器锁。锁必须提前创建并且以在当前线程中获得。参数 tstate 不能为 NULL。它只能用于校验它描述的当前线程状态&mdash;&mdash;如果它不对，会报告一个致命错误。这个函数在编译时禁用线程支持的情况下不可用。</p><a name="head-4d00cc1847bef9596ae7328e736c1367023ac7f7"></a>9. PyThreadState* PyEval_SaveThread( )<p><a name="line-178"></a><a name="line-179"></a><a name="line-180"></a><a name="line-181"></a> </p><p><a name="line-182"></a><a name="line-183"></a>释放解释器锁（如果它已经被创建而且定义了线程支持）并且将线程状态设为 NULL ，返回前一个线程状态（如果它不为 NULL ）。如果锁已经创建，当前线程必须获取它。（这个函数甚至在编译时不支持线程的情况下也能使用）。</p><a name="head-6fff732c0beab74069cfed32579da299b6a3a622"></a>10. void PyEval_RestoreThread( PyThreadState *tstate)<p><a name="line-184"></a><a name="line-185"></a><a name="line-186"></a><a name="line-187"></a> </p><p><a name="line-188"></a><a name="line-189"></a>获取解释器锁（如果支持线程并且锁已经创建）并设置线程状态为非空的 tstate。如果锁已经创建，当前线程必须没有在之前获得它，不然会发生死锁。（这个函数甚至在编译时不支持线程的情况下也能使用）。</p><p><a name="line-190"></a><a name="line-191"></a>The following macros are normally used without a trailing semicolon; look for example usage in the Python source distribution. </p><p><a name="line-192"></a><a name="line-193"></a>以下的宏通常调用的时候不以分号结尾；可以在发布的 Python 源代码中找到使用的示例。</p><a name="head-a813096206000eb1ff1b5526aeebae0e3727465f"></a>11. Py_BEGIN_ALLOW_THREADS<p><a name="line-194"></a><a name="line-195"></a><a name="line-196"></a><a name="line-197"></a> </p><p><a name="line-198"></a><a name="line-199"></a>这个宏展开为 &quot;{ PyThreadState *_save; _save = PyEval_SaveThread();&quot; 。注意它包含一个左大括号；它必须在其后匹配 Py_END_ALLOW_THREADS 宏。这个宏的介绍参见后面。当线程支持在编译时被禁用时它是一个 no-op。</p><a name="head-9604b27405d8f26349d1a71df856375b46f1d6b6"></a>12. Py_END_ALLOW_THREADS<p><a name="line-200"></a><a name="line-201"></a><a name="line-202"></a><a name="line-203"></a>This macro expands to &quot;PyEval_RestoreThread(_save); }&quot;. Note that it contains a closing brace; it must be matched with an earlier Py_BEGIN_ALLOW_THREADS macro. See above for further discussion of this macro. It is a no-op when thread support is disabled at compile time. </p><p><a name="line-204"></a><a name="line-205"></a>这个宏展开为 &quot;PyEval_RestoreThread(_save); }&quot; 。注意它包含一个右大括号；它必须在之前匹配一个 Py_BEGIN_ALLOW_THREADS 宏。这个宏的介绍参见前面。当线程支持在编译时被禁用时它是一个 no-op。</p><a name="head-654ea1f3d516eaec443c35928d16ff3bcc2a3e74"></a>13. Py_BLOCK_THREADS<p><a name="line-206"></a><a name="line-207"></a><a name="line-208"></a><a name="line-209"></a>This macro expands to &quot;PyEval_RestoreThread(_save);&quot;: it is equivalent to Py_END_ALLOW_THREADS without the closing brace. It is a no-op when thread support is disabled at compile time. </p><p><a name="line-210"></a><a name="line-211"></a>这个宏展开为 &quot;PyEval_RestoreThread(_save);&quot; ；它等同于 Py_END_ALLOW_THREADS 去掉右大括号。当线程支持在编译时被禁用时它是一个 no-op。</p><a name="head-ee00b58b6089f0ba521121a57bab2f55e1faa4bb"></a>14. Py_UNBLOCK_THREADS<p><a name="line-212"></a><a name="line-213"></a><a name="line-214"></a><a name="line-215"></a><a name="line-216"></a>This macro expands to &quot;_save = PyEval_SaveThread();&quot;: it is equivalent to Py_BEGIN_ALLOW_THREADS without the opening brace and variable declaration. It is a no-op when thread support is disabled at compile time. </p><p><a name="line-217"></a><a name="line-218"></a>这个宏展开为 &quot;_save = PyEval_SaveThread();&quot; ；它是等同于 Py_BEGIN_ALLOW_THREADS 去掉左大括号和变量声明。当线程支持在编译时被禁用时它是一个 no-op。</p><p><a name="line-219"></a><a name="line-220"></a>All of the following functions are only available when thread support is enabled at compile time, and must be called only when the interpreter lock has been created. </p><p><a name="line-221"></a><a name="line-222"></a>以下所有函数只能在编译时确认支持线程的情况下可用，并且必须在解释器锁创建后被调用。</p><a name="head-552d2a0b5deb22a6de992ffea92a55c1be008e1d"></a>15. PyInterpreterState* PyInterpreterState_New( )<p><a name="line-223"></a><a name="line-224"></a><a name="line-225"></a><a name="line-226"></a>Create a new interpreter state object. The interpreter lock need not be held, but may be held if it is necessary to serialize calls to this function. </p><p><a name="line-227"></a><a name="line-228"></a>创建一个新解释器状态对象。不必要捕获解释器锁，但是当需要同步调用这个函数进行序列化的时候可能需要锁定。</p><a name="head-d8ccb47393ad215b894a9d57cc9af1841fa5d53f"></a>16. void PyInterpreterState_Clear( PyInterpreterState *interp)<p><a name="line-229"></a><a name="line-230"></a><a name="line-231"></a><a name="line-232"></a>Reset all information in an interpreter state object. The interpreter lock must be held. </p><p><a name="line-233"></a><a name="line-234"></a>重置解释器状态对象中的所有信息。解释器锁必须被获取。</p><a name="head-0c11defc10b984f8ea83cd00ac625ddf4fb07257"></a>17. void PyInterpreterState_Delete( PyInterpreterState *interp)<p><a name="line-235"></a><a name="line-236"></a><a name="line-237"></a><a name="line-238"></a>Destroy an interpreter state object. The interpreter lock need not be held. The interpreter state must have been reset with a previous call to PyInterpreterState_Clear(). </p><p><a name="line-239"></a><a name="line-240"></a>析构一个解释器状态对象。解释器锁需要获取。解释器对象必须预先用 PyInterpreterState_Clear() 重置。</p><a name="head-7e98d26c18c23e59938bd9a95a94b4ee09d9733a"></a>18. PyThreadState* PyThreadState_New( PyInterpreterState *interp)<p><a name="line-241"></a><a name="line-242"></a><a name="line-243"></a><a name="line-244"></a>Create a new thread state object belonging to the given interpreter object. The interpreter lock need not be held, but may be held if it is necessary to serialize calls to this function. </p><p><a name="line-245"></a><a name="line-246"></a>创建一个从属于给定解释器的新线程状态对象。解释器锁不需要捕获，但是需要同步调用该函数时可能需要捕获。</p><a name="head-dae6aa72139f502ef5e54ba655acf6ca62982f7e"></a>19. void PyThreadState_Clear( PyThreadState *tstate)<p><a name="line-247"></a><a name="line-248"></a><a name="line-249"></a><a name="line-250"></a>Reset all information in a thread state object. The interpreter lock must be held. </p><p><a name="line-251"></a><a name="line-252"></a>重置指定线程状态对象的所有信息。解释器锁必须捕获。</p><a name="head-69275fdac72a1a4d38ca568aa1a30e4de971912f"></a>20. void PyThreadState_Delete( PyThreadState *tstate)<p><a name="line-253"></a><a name="line-254"></a><a name="line-255"></a><a name="line-256"></a>Destroy a thread state object. The interpreter lock need not be held. The thread state must have been reset with a previous call to PyThreadState_Clear(). </p><p><a name="line-257"></a><a name="line-258"></a>销毁一个线程状态对象。不需要捕获解释器锁。线程状态必须提前调用 PyThreadState_Clear() 进行清除。</p><a name="head-0597907effd57339f0698d7650bdda9d6b69e4b7"></a>21. PyThreadState* PyThreadState_Get( )<p><a name="line-259"></a><a name="line-260"></a><a name="line-261"></a><a name="line-262"></a>Return the current thread state. The interpreter lock must be held. When the current thread state is NULL, this issues a fatal error (so that the caller needn't check for NULL). </p><p><a name="line-263"></a><a name="line-264"></a>返回当前解释器状态。必须捕获解释器锁。当前线程状态如果为 NULL，发生一个致命错误（因此调用者不需要校验NULL）。</p><a name="head-75e55adce1edcc85e6361af8333adb4e46468704"></a>22. PyThreadState* PyThreadState_Swap( PyThreadState *tstate)<p><a name="line-265"></a><a name="line-266"></a><a name="line-267"></a><a name="line-268"></a>Swap the current thread state with the thread state given by the argument tstate, which may be NULL. The interpreter lock must be held. </p><p><a name="line-269"></a><a name="line-270"></a>将当前线程状态与给定的参数 tstate 交换，tstate可能为 NULL。解释器锁必须被捕获。</p><a name="head-8f040358f59e0cba683ca22deb824f3843385919"></a>23. PyObject* PyThreadState_GetDict( )<p><a name="line-271"></a><a name="line-272"></a><a name="line-273"></a><a name="line-274"></a>Return value: Borrowed reference. </p><p><a name="line-275"></a><a name="line-276"></a>返回值：托管引用。</p><p><a name="line-277"></a><a name="line-278"></a>Return a dictionary in which extensions can store thread-specific state information. Each extension should use a unique key to use to store state in the dictionary. It is okay to call this function when no current thread state is available. If this function returns NULL, no exception has been raised and the caller should assume no current thread state is available. Changed in version 2.3: Previously this could only be called when a current thread is active, and NULL meant that an exception was raised. </p><p><a name="line-279"></a><a name="line-280"></a>返回可存储线程独立的状态信息的一个扩展字典。每个扩展需要一个唯一键用于在字典中保存状态。当前线程状态不可用的时候它也可以调用。如果这个函数返回 NULL，没有抛出异常，调用者会假定当前线程状态无效。自 2.3 版以后的修改：以前它只能在当前线程激活的情况下被调用，如果返回 NULL 就意味着发生了异常。</p><a name="head-dab8052e5ba80491c4de9bbaf92e4eef0d603882"></a>24. int PyThreadState_SetAsyncExc( long id, PyObject *exc)<p><a name="line-281"></a><a name="line-282"></a><a name="line-283"></a><a name="line-284"></a>Asynchronously raise an exception in a thread. The id argument is the thread id of the target thread; exc is the exception object to be raised. This function does not steal any references to exc. To prevent naive misuse, you must write your own C extension to call this. Must be called with the GIL held. Returns the number of thread states modified; this is normally one, but will be zero if the thread id isn't found. If exc is NULL, the pending exception (if any) for the thread is cleared. This raises no exceptions. New in version 2.3. </p><p><a name="line-285"></a><a name="line-286"></a>在 线程中异步抛出一个异常。参数 id 是目标线程的线程 id ；exc 是要抛出的异常对象。这个函数不获取 exc 的任何引用。为了防止低级错误，你必须自己编写你的 C 扩展来调用它。调用必须捕获 GIL。返回线程状态修改数；通常为 1 ，但是如果线程 id 没有找到就会返回0。如果 exc 是 NULL，所有异常（任何可能）都会从线程中清除。不抛出异常。2.3版新加入。</p><a name="head-60df299526118f1de532e3f3359266f89f2bd5fa"></a>25. PyGILState_STATE PyGILState_Ensure( )<p><a name="line-287"></a><a name="line-288"></a><a name="line-289"></a><a name="line-290"></a>Ensure that the current thread is ready to call the Python C API regardless of the current state of Python, or of its thread lock. This may be called as many times as desired by a thread as long as each call is matched with a call to PyGILState_Release(). In general, other thread-related APIs may be used between PyGILState_Ensure() and PyGILState_Release() calls as long as the thread state is restored to its previous state before the Release(). For example, normal usage of the Py_BEGIN_ALLOW_THREADS and Py_END_ALLOW_THREADS macros is acceptable. </p><p><a name="line-291"></a><a name="line-292"></a>确 保当前线程已经可以调用与当前 Python 状态无关的 Python C API，或者它的线程锁。当一个线程每次希望匹配到 PyGILState_Release() 调用时可能会反复调用这个函数。通常，在线程状态恢复为 Release() 之前的状态时，其它线程相关的 API 可能会在一对 PyGILState_Ensure() 和 PyGILState_Release() 之间调用。例如，通常可以用于Py_BEGIN_ALLOW_THREADS 宏 Py_END_ALLOW_THREADS。</p><p><a name="line-293"></a><a name="line-294"></a>The return value is an opaque &quot;handle&quot; to the thread state when PyGILState_Acquire() was called, and must be passed to PyGILState_Release() to ensure Python is left in the same state. Even though recursive calls are allowed, these handles cannot be shared - each unique call to PyGILState_Ensure must save the handle for its call to PyGILState_Release. </p><p><a name="line-295"></a><a name="line-296"></a>PyGILState_Acquire ()被调用的时候，返回值是一个不透明的线程状态&ldquo;句柄&rdquo;，Python离开当前状态时一定会被被传递到 PyGILState_Release() 。甚至尽管允许递归调用，这些句柄也不能共享&mdash;&mdash;每次调用 PyGILState_Ensure 都是唯一的，它们的句柄对应它们的PyGILState_Release。</p><p><a name="line-297"></a><a name="line-298"></a>When the function returns, the current thread will hold the GIL. Failure is a fatal error. New in version 2.3. </p><p><a name="line-299"></a>当函数返回，当前线程将会捕获 GIL ，失败会造成致命错误。2.3版新增。</p><a name="head-a4b5218369d91302e7e3bb1612c3cb4a638f42b0"></a>26. void PyGILState_Release( PyGILState_STATE)<p><a name="line-301"></a><a name="line-302"></a><a name="line-303"></a><a name="line-304"></a>Release any resources previously acquired. After this call, Python's state will be the same as it was prior to the corresponding PyGILState_Ensure call (but generally this state will be unknown to the caller, hence the use of the GILState API.) </p><p><a name="line-305"></a><a name="line-306"></a>释放所有之前获取的资源。这个调用之后，Python的状态会与之前 PyGILState_Ensure 调用一致（但是通常这个状态对调用者是未知的，因此使用 GILState API）。</p><p><a name="line-307"></a><a name="line-308"></a>Every call to PyGILState_Ensure() must be matched by a call to PyGILState_Release() on the same thread. New in version 2.3. </p><p>每次调用 PyGILState_Ensure() 都要在同一线程对应调用 PyGILState_Release() 。2.3版本新增。</p><p>========================================================================</p><a href="http://blog.csdn.net/liguangyi/archive/2007/06/20/1659697.aspx">http://blog.csdn.net/liguangyi/archive/2007/06/20/1659697.aspx</a><br /><p><br /></p>一、首先定义一个封装类，主要是保证PyGILState_Ensure, PyGILState_Release配对使用，而且这个类是可以嵌套使用的。<br /><br />#include &lt;python.h&gt;<br /><br />class PyThreadStateLock<br />{<br />public:<br />&nbsp;&nbsp;&nbsp;  PyThreadStateLock(void)<br />&nbsp;&nbsp;&nbsp;  {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  state = PyGILState_Ensure( );<br />&nbsp;&nbsp;&nbsp;  }<br /><br />&nbsp;&nbsp;&nbsp;  ~PyThreadStateLock(void)<br />&nbsp;&nbsp;&nbsp;  {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  PyGILState_Release( state );<br />&nbsp;&nbsp;&nbsp;  }<br />private:<br />&nbsp;&nbsp;&nbsp;  PyGILState_STATE state;<br />};<br /><br /><br />二、在主线程中，这样处理<br /><br />&nbsp;&nbsp;&nbsp;  // 初始化<br />&nbsp;&nbsp;&nbsp;  Py_Initialize();<br />&nbsp;&nbsp;&nbsp;  // 初始化线程支持<br />&nbsp;&nbsp;&nbsp;  PyEval_InitThreads();<br />&nbsp;&nbsp;&nbsp;  // 启动子线程前执行，为了释放PyEval_InitThreads获得的全局锁，否则子线程可能无法获取到全局锁。<br />&nbsp;&nbsp;&nbsp;  PyEval_ReleaseThread(PyThreadState_Get());<tt><br />&nbsp;&nbsp;&nbsp;  <br />&nbsp;&nbsp;&nbsp;  // 其他的处理，如启动子线程等<br />&nbsp;&nbsp;&nbsp;  ......<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  <br />&nbsp;&nbsp;&nbsp;  // 保证子线程调用都结束后<br />&nbsp;&nbsp;&nbsp;  PyGILState_Ensure();<br />&nbsp;&nbsp;&nbsp;  Py_Finalize();<br />&nbsp;&nbsp;&nbsp;  // 之后不能再调用任何python的API<br /><br />三、在主线程，或者子线程中，调用python本身函数的都采用如下处理<br /><br />&nbsp;&nbsp;&nbsp;  {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  class PyThreadStateLock PyThreadLock; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  // 调用python的API函数处理<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  ......<br />&nbsp;&nbsp;&nbsp;  }<br /><br />四</tt><tt>、</tt><tt>另外还有两个和全局锁有关的宏，Py_BEGIN_ALLOW_THREADS 和 Py_END_ALLOW_THREADS。这两个宏是为了在较长时间的C函数调用前，临时释放全局锁，完成后重新获取全局锁，以避免阻塞其他 python的线程继续运行。这两个宏可以这样调用<br /><br />&nbsp;&nbsp;&nbsp;  {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  class PyThreadStateLock PyThreadLock; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  // 调用python的API函数处理<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  ......<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  Py_BEGIN_ALLOW_THREADS<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  // 调用需要长时间的C函数<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  ......<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  Py_END_ALLOW_THREADS<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  // 调用python的API函数处理<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  ......<br />&nbsp;&nbsp;&nbsp;  }</tt><p> </p><p>========================================================================</p><p>都来自网上，经本人整理。</p> </div>    <div class="mod-tagbox clearfix">   <a class="tag" href="/tag/Python/feeds">#Python</a>  </div> <div class="mod-post-info clearfix">  <div class=x-bdshare>  <div id=bdshare class="bdshare_t bds_tools get-codes-bdshare" data="{'wbuid':1727466295}"> <span class=bds_more>分享到：</span> <a class=bds_qzone></a> <a class=bds_tsina></a> <a class=bds_tqq></a> <a class=bds_renren></a> </div> <script id=bdshare_js data="type=tools&amp;uid=713670"></script> <script id=bdshell_js></script> <script>
        var bds_config = {'bdTop':240};
                    var all_img = qing.g('content').getElementsByTagName('img');
            if(all_img.length>0){
                bds_config.bdPic = all_img[0].src;
            }
                document.getElementById("bdshell_js").src = "http://bdimg.share.baidu.com/static/js/shell_v2.js?v=72836429.js?cdnversion=" + Math.ceil(new Date()/3600000);
    </script> </div> <div class="op-box mod-cs-opBox">  <a class="report-btn hide" target=_blank href="#"> 举报 </a>  <span class=pv>浏览(524)</span> <a class=comment-bnt id=commentBnt href="#" onclick="return false"> 评论<span class=comment-nub></span> </a>   <a href="#" id=shareBnt onclick="return false" class=share-bnt> 转载<span id=shareNub class=share-nub></span> </a>   </div> </div>   </div>    <div class=mod-share-detail id=shareDetail style=display:none></div>   <div class=mod-relate-blogs id=relateBlog> <h3 class=relate-title>你可能也喜欢</h3> <ul class="relate-blog-list clearfix">   <li  class=first > <a href="http://hi.baidu.com/zhanggui201206/item/05d2aee048769219560f1ded" target=_blank class=qing-stat-nsclick data-nsclick=m_20121105_detail_relates_img> <img src="http://d.hiphotos.baidu.com/space/scrop=90/sign=8fc808c25cdf8db1b8703b3b791ee464/dbb44aed2e738bd460b4bb6ba38b87d6267ff9d7.jpg" class=relate-img alt="感恩父亲" title="感恩父亲"> </a> <a href="http://hi.baidu.com/zhanggui201206/item/05d2aee048769219560f1ded" target=_blank class="relate-txt qing-stat-nsclick" data-nsclick=m_20121105_detail_relates_txt>感恩父亲</a>    <li > <a href="http://hi.baidu.com/glsxb/item/a70927447c0ba282df2a9f1a" target=_blank class=qing-stat-nsclick data-nsclick=m_20121105_detail_relates_img> <img src="http://f.hiphotos.baidu.com/space/scrop=90/sign=24a235c739c79f3d8bbfa36fca9cf421/503d269759ee3d6db864f7f341166d224f4ade6c.jpg" class=relate-img alt="【空间周刊】年末特别策划：都市异乡人" title="【空间周刊】年末特别策划：都市异乡人"> </a> <a href="http://hi.baidu.com/glsxb/item/a70927447c0ba282df2a9f1a" target=_blank class="relate-txt qing-stat-nsclick" data-nsclick=m_20121105_detail_relates_txt>【空间周刊】年末特别策划：都市异乡人</a>    <li > <a href="http://hi.baidu.com/zlrei/item/80a132b3e42dec432aebe3f9" target=_blank class=qing-stat-nsclick data-nsclick=m_20121105_detail_relates_img> <img src="http://e.hiphotos.baidu.com/space/scrop=90/sign=cf10035fd058ccbf1fe2f26569e5850e/29381f30e924b899d5cfd3d56f061d950b7bf668.jpg" class=relate-img alt="为宝宝守候一份思念——一波未平一波又起" title="为宝宝守候一份思念——一波未平一波又起"> </a> <a href="http://hi.baidu.com/zlrei/item/80a132b3e42dec432aebe3f9" target=_blank class="relate-txt qing-stat-nsclick" data-nsclick=m_20121105_detail_relates_txt>为宝宝守候一份思念——一波未平一波又起</a>    <li > <a href="http://hi.baidu.com/abcdfe/item/a947e1195c1be3f4756a84f9" target=_blank class=qing-stat-nsclick data-nsclick=m_20121105_detail_relates_img> <img src="http://g.hiphotos.baidu.com/space/scrop=90/sign=7d346bf543a98226bc9f6c78fabf8031/b3b7d0a20cf431ad5d1faab94b36acaf2fdd9865.jpg" class=relate-img alt="我的故乡-我的家" title="我的故乡-我的家"> </a> <a href="http://hi.baidu.com/abcdfe/item/a947e1195c1be3f4756a84f9" target=_blank class="relate-txt qing-stat-nsclick" data-nsclick=m_20121105_detail_relates_txt>我的故乡-我的家</a>    <li > <a href="http://hi.baidu.com/numbox/item/6ac1c70d27070fd61ff046dc" target=_blank class=qing-stat-nsclick data-nsclick=m_20121105_detail_relates_img> <img src="http://e.hiphotos.baidu.com/space/scrop=90/sign=504eb972f01f3a295e969291e9188501/728da9773912b31b6c4bd5858618367adab4e173.jpg" class=relate-img alt="那年，那月，那时光，悄然流逝，辗转二年" title="那年，那月，那时光，悄然流逝，辗转二年"> </a> <a href="http://hi.baidu.com/numbox/item/6ac1c70d27070fd61ff046dc" target=_blank class="relate-txt qing-stat-nsclick" data-nsclick=m_20121105_detail_relates_txt>那年，那月，那时光，悄然流逝，辗转二年</a>    <li > <a href="http://hi.baidu.com/19691123/item/7dd674c13b416410b77a2455" target=_blank class=qing-stat-nsclick data-nsclick=m_20121105_detail_relates_img> <img src="http://f.hiphotos.baidu.com/space/scrop=90/sign=40a73d2d00087bf479b210b682ee6e1c/8d5494eef01f3a2970c7d7a89b25bc315c607c4c.jpg" class=relate-img alt="母亲    （原创）" title="母亲    （原创）"> </a> <a href="http://hi.baidu.com/19691123/item/7dd674c13b416410b77a2455" target=_blank class="relate-txt qing-stat-nsclick" data-nsclick=m_20121105_detail_relates_txt>母亲    （原创）</a>    <li > <a href="http://hi.baidu.com/vtqagjxagdqrtys/item/860b4319adf907413b176e56" target=_blank class=qing-stat-nsclick data-nsclick=m_20121105_detail_relates_img> <img src="http://f.hiphotos.baidu.com/space/scrop=90/sign=a52c05bc0cf3d7ca08a8782982228739/a71ea8d3fd1f4134aa0447fc251f95cad1c85e04.jpg" class=relate-img alt="超越C++标准库——如何在如何在WINDOWS下编译BOOST C++库" title="超越C++标准库——如何在如何在WINDOWS下编译BOOST C++库"> </a> <a href="http://hi.baidu.com/vtqagjxagdqrtys/item/860b4319adf907413b176e56" target=_blank class="relate-txt qing-stat-nsclick" data-nsclick=m_20121105_detail_relates_txt>超越C++标准库——如何在如何在WINDOWS下编译BOOST C++库</a>   </ul> </div>   <div class="mod-detail-pager clearfix">  <div class=detail-nav-pre> <a href="http://hi.baidu.com/vtqagjxagdqrtys/item/2b85cacf9800ee61f6c95d52" hidefocus title="上一篇"></a> </div>   <div class=detail-nav-next> <a href="http://hi.baidu.com/vtqagjxagdqrtys/item/869cb0cda81052c7994aa057" hidefocus title="下一篇"></a> </div>  </div>   <div id=commentDetail class="mod-comment-detail clearfix mod-cs-comment">   <div class=mod-recent-readers> <h3 class=recent-readers-title>本文最近访客</h3> <ul class="readers-list clearfix">    <li  class=first > <a target=_blank href="http://hi.baidu.com/web_wxw"> <img src="http://hiphotos.baidu.com/space/scrop%3D65%3Bq%3D100/sign%3D1d731881fdfaaf5180bdc6e0fc69a2db/023b5bb5c9ea15cee5bb50aeb6003af33b87b2c4.jpg" title="passexam" alt="passexam" class=portrait> </a> <a target=_blank href="http://hi.baidu.com/web_wxw" class=user-name title="passexam"> passexam </a> <div class=visit-time data-visit-time="1394075116"></div>      <li > <a target=_blank href="http://hi.baidu.com/200712020400"> <img src="http://hiphotos.baidu.com/space/scrop%3D65%3Bq%3D100/sign%3D3ddaaa0ea9014c081d656ffa7a46343d/e7cd7b899e510fb3dbda5030d933c895d0430c51.jpg" title="200712020400" alt="200712020400" class=portrait> </a> <a target=_blank href="http://hi.baidu.com/200712020400" class=user-name title="200712020400"> 200712020400 </a> <div class=visit-time data-visit-time="1352696550"></div>    </ul> </div>  <div class=comment-title>评论</div> <div class=comment-content></div> </div>   </div>  </div>  </div> </div> </section>  <footer class="mod-footer mod-cs-footer"><div class="clearfix hidden-box"></div><div class=footer-box><div class=inner-box><a href=http://help.baidu.com/question?prod_en=hi target=_blank>帮助中心</a><span>&nbsp;|&nbsp;</span><a href=http://tieba.baidu.com/p/1781683739 target=_blank>空间客服</a><span>&nbsp;|&nbsp;</span><a href=http://tousu.baidu.com/hi/add target=_blank>投诉中心</a><span>&nbsp;|&nbsp;</span><a href=http://www.baidu.com/search/hi_contract.html target=_blank>空间协议</a></div><div class=copy-box>&copy;2014&nbsp;Baidu</div></div></footer>  <script src="http://hi.bdimg.com/static/qbase/js/mod/mod_foot.js?v=382c615f.js"></script> <script>
        	qing.dom.ready(function(){
                if (qVisitorInfo.loginStatus == 'activated'){
                    qext.stat.ns('m_20121012_loga_num');
					qext.fn.setStoken();
				}
			});
        </script>        <script>qext.stat.ns('m_20120425_');</script>  <script src="http://hi.bdimg.com/static/qcomment/js/qcmt_import.js?v=ac96f988.js"></script>  <script src="http://hi.bdimg.com/static/qpublish/js/editor/shCore.js?v=805e084f.js"></script> <script>
        SyntaxHighlighter.highlight();
    </script>   <script src="http://hi.bdimg.com/static/qhome/js/detail/20001/detail.js?v=3d7781df.js"></script>   <!--[if (lt IE 8.0)]><link rel=stylesheet type=text/css href="http://hi.bdimg.com/static/qmessage/css/qmessage_mod_msg_bubble.css?v=a727011c.css"><![endif]--><!--[if (!IE)|(gte IE 8.0)]><!--><link rel=stylesheet type=text/css href="http://hi.bdimg.com/static/qmessage/css/qmessage_mod_msg_bubble_datauri.css?v=6ddd3ba9.css"><!--<![endif]--><script src="http://hi.bdimg.com/static/qmessage/js/boot_qmessage_mod_bubble.js?v=56fecbc3.js"></script><link href="http://hi.bdimg.com/static/qbase/css/yoyo/yoyo.css?v=4dd11df1.css" type=text/css rel=stylesheet><script src="http://hi.bdimg.com/static/qbase/js/yoyo/yoyo.js?v=4c5bc7ae.js"></script><script>wpo.tti=new Date*1;</script><script src="http://hi.baidu.com/cm/static/js/allsite.js?v=75674092.js?v=201404281612"></script><script src="http://hi.bdimg.com/static/qbase/js/mod/mod_bubble.js?v=a9273ef3.js"></script><script>document.write(unescape("%3Cscript src='http://hm.baidu.com/h.js%3F8c869b543955d43e496c2efee5b55823' type='text/javascript'%3E%3C/script%3E"));qext.stat.ns('m_20120713_qing_pv');</script>
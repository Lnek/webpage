<!DOCTYPE html>
<html lang="zh-cn">
<head>
<meta charset="utf-8"/>
<title>什么是HTTP Headers？ - yuzhongwusan - 博客园</title>
<link type="text/css" rel="stylesheet" href="/bundles/blog-common.css?v=RFWbSMVn474Meo5c6rKa1DH_M4ldFPuI9Jah-EA-L5Q1"/>
<link id="MainCss" type="text/css" rel="stylesheet" href="/skins/darkgreentrip/bundle-darkgreentrip.css?v=xPXJVC4GCITs1yYYgSeLkcicCxapqseaPVQLFGMO1wc1"/>
<link title="RSS" type="application/rss+xml" rel="alternate" href="http://www.cnblogs.com/yuzhongwusan/rss"/>
<link title="RSD" type="application/rsd+xml" rel="EditURI" href="http://www.cnblogs.com/yuzhongwusan/rsd.xml"/>
<link type="application/wlwmanifest+xml" rel="wlwmanifest" href="http://www.cnblogs.com/yuzhongwusan/wlwmanifest.xml"/>
<script src="http://common.cnblogs.com/script/jquery.js" type="text/javascript"></script>  
<script type="text/javascript">var currentBlogApp = 'yuzhongwusan', cb_enable_mathjax=false;</script>
<script src="/bundles/blog-common.js?v=NRIlPIHMlVEgoqJZIuk9OQtjtZjNFcz_ov8kYhFFdoM1" type="text/javascript"></script>
</head>
<body>
<a name="top"></a>
<!--PageBeginHtml Block Begin-->
雨中无伞与您一同见证前端开发，这里提供最新前端开发知识
<!--PageBeginHtml Block End-->

<!--done-->
<div id="home">
<div id="header">
	<div id="blogTitle">
	<a id="lnkBlogLogo" href="http://www.cnblogs.com/yuzhongwusan/"><img id="blogLogo" src="/Skins/custom/images/logo.gif" alt="返回主页" /></a>			
		
<!--done-->
<h1><a id="Header1_HeaderTitle" class="headermaintitle" href="http://www.cnblogs.com/yuzhongwusan/">雨中无伞-----WEB前端开发</a></h1>
<h2></h2>



		
	</div><!--end: blogTitle 博客的标题和副标题 -->
	<div id="navigator">
		
<ul id="navList">
<li><a id="MyLinks1_HomeLink" class="menu" href="http://www.cnblogs.com/">博客园</a></li>
<li><a id="MyLinks1_MyHomeLink" class="menu" href="http://www.cnblogs.com/yuzhongwusan/">首页</a></li>
<li><a id="MyLinks1_NewPostLink" class="menu" rel="nofollow" href="http://i.cnblogs.com/EditPosts.aspx?opt=1">新随笔</a></li>
<li><a id="MyLinks1_ContactLink" class="menu" rel="nofollow" href="http://space.cnblogs.com/msg/send/yuzhongwusan">联系</a></li>
<li><a id="MyLinks1_Syndication" class="menu" href="http://www.cnblogs.com/yuzhongwusan/rss">订阅</a>
<!--<a id="MyLinks1_XMLLink" class="aHeaderXML" href="http://www.cnblogs.com/yuzhongwusan/rss"><img src="http://www.cnblogs.com/images/xml.gif" alt="订阅" /></a>--></li>
<li><a id="MyLinks1_Admin" class="menu" rel="nofollow" href="http://i.cnblogs.com/">管理</a></li>
</ul>
		<div class="blogStats">
			
			
<!--done-->
随笔- 437&nbsp;
文章- 5&nbsp;
评论- 214&nbsp;

			
		</div><!--end: blogStats -->
	</div><!--end: navigator 博客导航栏 -->
</div><!--end: header 头部 -->

<div id="main">
	<div id="mainContent">
	<div class="forFlow">
		

<!--done-->
<div id="topics">
	<div class = "post">
		<h1 class = "postTitle">
			<a id="cb_post_title_url" class="postTitle2" href="http://www.cnblogs.com/yuzhongwusan/archive/2011/10/20/2218954.html">什么是HTTP Headers？</a>
		</h1>
		<div class="clear"></div>
		<div class="postBody">
			<div id="cnblogs_post_body"><div><h3>什么是HTTP Headers</h3> <p>HTTP是&#8220;Hypertext Transfer Protocol&#8221;的所写，整个万维网都在使用这种协议，几乎你在浏览器里看到的大部分内容都是通过http协议来传输的，比如这篇文章。</p> <p>HTTP Headers是HTTP请求和相应的核心，它承载了关于客户端浏览器，请求页面，服务器等相关的信息。</p> <p>&nbsp;</p> <p><img alt="" src="http://pic002.cnblogs.com/images/2011/337467/2011102010591864.png" /></p> <h3>示例</h3> <p>当你在浏览器地址栏里键入一个url，你的浏览器将会类似如下的http请求：<br /><code>GET /tutorials/other/top-20-mysql-best-practices/ HTTP/1.1<br />Host: net.tutsplus.com<br />User-Agent: Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US; rv:1.9.1.5) Gecko/20091102 Firefox/3.5.5 (.NET CLR 3.5.30729)<br />Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8<br />Accept-Language: en-us,en;q=0.5<br />Accept-Encoding: gzip,deflate<br />Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7<br />Keep-Alive: 300<br />Connection: keep-alive<br />Cookie: PHPSESSID=r2t5uvjq435r4q7ib3vtdjq120<br />Pragma: no-cache<br />Cache-Control: no-cache<br /></code><br />第一行被称为&#8220;Request Line&#8221; 它描述的是这个请求的基本信息，剩下的就是HTTP headers了。</p> <p>请求完成之后，你的浏览器可能会收到如下的HTTP响应：</p> <p><code>HTTP/1.x 200 OK<br />Transfer-Encoding: chunked<br />Date: Sat, 28 Nov 2009 04:36:25 GMT<br />Server: LiteSpeed<br />Connection: close<br />X-Powered-By: W3 Total Cache/0.8<br />Pragma: public<br />Expires: Sat, 28 Nov 2009 05:36:25 GMT<br />Etag: "pub1259380237;gz"<br />Cache-Control: max-age=3600, public<br />Content-Type: text/html; charset=UTF-8<br />Last-Modified: Sat, 28 Nov 2009 03:50:37 GMT<br />X-Pingback: http://net.tutsplus.com/xmlrpc.php<br />Content-Encoding: gzip<br />Vary: Accept-Encoding, Cookie, User-Agent<br />&lt;!-- ... rest of the html ... --&gt;</code></p> <p>第一行呢被称为&#8220;Status Line&#8221;，它之后就是http headers，空行完了就开始输出内容了（在这个案例中是一些html输出）。</p> <p>但你查看页面源代码却不能看到HTTP headers，虽然它们同你能看到的东西一起被传送至浏览器了。</p> <p>这个HTTP请求也发出了一些其它资源的接收请求，例如图片，css文件，js文件等等。</p> <p>下面我们来看看细节。</p> <h3>怎样才能看到HTTP Headers</h3> <p>下面这些FireFox扩展能够帮助你分析HTTP headers：</p> <p>1. <a href="http://getfirebug.com/" target="_blank">firebug</a></p> <p><img alt="" src="http://pic002.cnblogs.com/images/2011/337467/2011102010505249.png" /></p> <p>2.<a href="https://addons.mozilla.org/en-US/firefox/addon/3829">Live HTTP Headers</a></p> <p>&nbsp;</p> <p><img alt="" src="http://pic002.cnblogs.com/images/2011/337467/2011102010594573.png" /></p> <p>&nbsp;</p> <p>3. 在PHP中：</p> <ul><li><a href="http://php.net/manual/en/function.getallheaders.php">getallheaders()</a> 用来获取请求头部. 你也可以使用 $_SERVER 数组.</li><li><a href="http://www.php.net/manual/en/function.headers-list.php">headers_list()</a> 用来获取响应头部.</li></ul> <p>文章下面将会看到一些使用php示范的例子。</p> <h3>HTTP Request 的结构</h3> <p><img alt="" src="http://pic002.cnblogs.com/images/2011/337467/2011102010513138.png" /></p> <p>被称作&#8220;first line&#8221;的第一行包含三个部分：</p> <ul><li>&#8220;method&#8221; 表明这是何种类型的请求. 最常见的请求类型有 GET, POST 和 HEAD.</li><li>&#8220;path&#8221; 体现的是主机之后的路径. 例如，当你请求  &#8220;http://net.tutsplus.com/tutorials/other/top-20-mysql-best-practices/&#8221;时 ,  path 就会是 &#8220;/tutorials/other/top-20-mysql-best-practices/&#8221;.</li><li>&#8220;protocol&#8221; 包含有 &#8220;HTTP&#8221; 和版本号, 现代浏览器都会使用1.1.</li></ul> <p>剩下的部分每行都是一个&#8220;Name：Value&#8221;对。它们包含了各式各样关于请求和你浏览器的信息。例如&#8221;User-Agent&#8220;就表明了你浏览器版本和你所用的操作系统。&#8221;Accept-Encoding&#8220;会告诉服务器你的浏览可以接受类似gzip的压缩输出。</p> <p>这些headers大部分都是可选的。HTTP 请求甚至可以被精简成这样子：</p> <p><code>GET&nbsp;/tutorials/other/top-20-mysql-best-practices/&nbsp;HTTP/1.1<br />Host:&nbsp;net.tutsplus.com</code></p> <p>并且你仍旧可以从服务器收到有效的响应。</p> <h3>请求类型</h3> <p>三种最常见的请求类型是：GET，POST 和 HEAD ，从html的编写过程中你可能已经熟悉了前两种。</p> <h3>GET：获取一个文档</h3> <p>大部分被传输到浏览器的html，images，js，css, &#8230; 都是通过GET方法发出请求的。它是获取数据的主要方法。</p> <p>例如，要获取Nettuts+ 的文章，http request的第一行通常看起来是这样的：</p> <p><code>GET&nbsp;/tutorials/other/top-20-mysql-best-practices/&nbsp;HTTP/1.1</code></p> <p>一旦html加载完成，浏览器将会发送GET 请求去获取图片，就像下面这样：</p> <p><code>GET&nbsp;/wp-content/themes/tuts_theme/images/header_bg_tall.png&nbsp;HTTP/1.1</code></p> <p>表单也可以通过GET方法发送，下面是个例子：</p> <p><code>&lt;form action="foo.php" method="GET"&gt;<br />First Name: &lt;input name="first_name" type="text" /&gt;<br />Last Name: &lt;input name="last_name" type="text" /&gt;<br />&lt;input name="action" type="submit" value="Submit" /&gt;<br />&lt;/form&gt;</code></p> <p>当这个表单被提交时，HTTP request 就会像这样：</p> <p><code>GET /foo.php?first_name=John&amp;last_name=Doe&amp;action=Submit HTTP/1.1<br />...</code></p> <p>你可以将表单输入通过附加进查询字符串的方式发送至服务器。</p> <h3>POST：发送数据至服务器</h3> <p>尽管你可以通过GET方法将数据附加到url中传送给服务器，但在很多情况下使用POST发送数据给服务器更加合适。通过GET发送大量数据是不现实的，它有一定的局限性。</p> <p>用POST请求来发送表单数据是普遍的做法。我们来吧上面的例子改造成使用POST方式：</p> <p><code>&lt;form action="foo.php" method="POST"&gt;<br />First Name: &lt;input name="first_name" type="text" /&gt;<br />Last Name: &lt;input name="last_name" type="text" /&gt;<br />&lt;input name="action" type="submit" value="Submit" /&gt;<br />&lt;/form&gt;</code></p> <p>提交这个表单会创建一个如下的HTTP 请求：</p> <p><code>POST /foo.php HTTP/1.1<br />Host: localhost<br />User-Agent: Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US; rv:1.9.1.5) Gecko/20091102 Firefox/3.5.5 (.NET CLR 3.5.30729)<br />Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8<br />Accept-Language: en-us,en;q=0.5<br />Accept-Encoding: gzip,deflate<br />Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7<br />Keep-Alive: 300<br />Connection: keep-alive<br />Referer: http://localhost/test.php<br />Content-Type: application/x-www-form-urlencoded<br />Content-Length: 43<br />first_name=John&amp;last_name=Doe&amp;action=Submit</code></p> <p>这里有三个需要注意的地方：</p> <ul><li>第一行的路径已经变为简单的 /foo.php , 已经没了查询字符串。</li><li>新增了 Content-Type 和 Content-Lenght 头部，它提供了发送信息的相关信息.</li><li>所有数据都在headers之后，以查询字符串的形式被发送.</li></ul> <p>POST方式的请求也可用在AJAX，应用程序，cURL &#8230; 之上。并且所有的文件上传表单都被要求使用POST方式。</p> <h3>HEAD：接收头部信息</h3> <p>HEAD和GET很相似，只不过HEAD不接受HTTP响应的内容部分。当你发送了一个HEAD请求，那就意味着你只对HTTP头部感兴趣，而不是文档本身。</p> <p>这个方法可以让浏览器判断页面是否被修改过，从而控制缓存。也可判断所请求的文档是否存在。</p> <p>例如，假如你的网站上有很多链接，那么你就可以简单的给他们分别发送HEAD请求来判断是否存在死链，这比使用GET要快很多。</p> <h3>http响应结构</h3> <p>当浏览器发送了HTTP请求之后，服务器就会通过一个HTTP response来响应这个请求。如果不关心内容，那么这个请求看起来会是这样的：</p> <p><img alt="" src="http://pic002.cnblogs.com/images/2011/337467/2011102010521258.png" /></p> <p>第一个有价值的信息就是协议。目前服务器都会使用 HTTP/1.x 或者 HTTP/1.1。</p> <p>接下来一个简短的信息代表状态。代码200意味着我们的请求已经发送成功了，服务器将会返回给我们所请求的文档，在头部信息之后。</p> <p>我们都见过&#8220;404&#8221;页面。当我向服务器请求一个不存在的路径时，服务器就用用404来代替200响应我们。</p> <p>余下的响应内容和HTTP请求相似。这些内容是关于服务器软件的，页面/文件何时被修改过，mime type 等等&#8230;</p> <p>同样，这些头部信息也是可选的。</p> <h2>HTTP状态码</h2> <ul><li>200 用来表示请求成功.</li><li>300 来表示重定向.</li><li>400 用来表示请求出现问题.</li><li>500 用来表示服务器出现问题.</li></ul> <p><strong>200 成功 （OK）</strong></p> <p>前文已经提到，200是用来表示请求成功的。</p> <p><strong>206 部分内容 （Partial Content）</strong></p> <p>如果一个应用只请求某范围之内的文件，那么就会返回206.</p> <p>这通常被用来进行下载管理，断点续传或者文件分块下载。</p> <p><strong>404 没有找到 （Not Found）</strong></p> <p>&nbsp;</p> <p><img alt="" src="http://pic002.cnblogs.com/images/2011/337467/2011102010525331.png" /></p> <p>很容易理解</p> <p><strong>401 未经授权 （Unauthorized）</strong></p> <p>受密码保护的页面会返回这个状态。如果你没有输入正确的密码，那么你就会在浏览器中看到如下的信息：</p> <p>&nbsp;<img alt="" src="http://pic002.cnblogs.com/images/2011/337467/2011102010532654.png" /></p> <p>注意这只是受密码保护页面，请求输入密码的弹出框是下面这个样子的：</p> <p><img alt="" src="http://pic002.cnblogs.com/images/2011/337467/2011102010540648.png" /></p> <p><strong>403 被禁止（Forbidden）</strong></p> <p>如果你没有权限访问某个页面，那么就会返回403状态。这种情况通常会发生在你试图打开一个没有index页面的文件夹。如果服务器设置不允许查看目录内容，那么你就会看到403错误。</p> <p>其它一些一些方式也会发送权限限制，例如你可以通过IP地址进行阻止，这需要一些htaccess的协助。</p> <p><code>order allow,deny<br />deny from 192.168.44.201<br />deny from 224.39.163.12<br />deny from 172.16.7.92<br />allow from all</code></p> <p><strong>302（或307）临时移动（Moved Temporarily） 和 301 永久移动（Moved Permanently）</strong></p> <p>这两个状态会出现在浏览器重定向时。例如，你使用了类似 bit.ly 的网址缩短服务。这也是它们如何获知谁点击了他们链接的方法。</p> <p>302和301对于浏览器来说是非常相似的，但对于搜索引擎爬虫就有一些差别。打个比方，如果你的网站正在维护，那么你就会将客户端浏览器用302 重定向到另外一个地址。搜索引擎爬虫就会在将来重新索引你的页面。但是如果你使用了301重定向，这就等于你告诉了搜索引擎爬虫：你的网站已经永久的移动 到了新的地址。</p> <p><strong>500 服务器错误（Internal Server Error）</strong></p> <p><img alt="" src="http://pic002.cnblogs.com/images/2011/337467/2011102010543919.png" /></p> <p>这个代码通常会在页面脚本崩溃时出现。大部分CGI脚本都不会像PHP那样输出错误信息给浏览器。如果出现了致命的错误，它们只会发送一个500的状态码。这时需要查看服务器错误日志来排错。</p> <p><strong>完整的列表</strong></p> <p>你可以<a href="http://en.wikipedia.org/wiki/List_of_HTTP_status_codes" target="_blank">在这里</a>找到完整的HTTP 状态码说明。</p> <h2>HTTP Headers 中的 HTTP请求</h2> <p>现在我们来看一些在HTTP headers中常见的HTTP请求信息。</p> <p>所有这些头部信息都可以在PHP的$_SERVER数组中找到。你也可以用<a href="http://php.net/manual/en/function.getallheaders.php">getallheaders()</a> 函数一次性获取所有的头部信息。</p> <h3>Host</h3> <p>一个HTTP请求会发送至一个特定的IP地址，但是大部分服务器都有在同一IP地址下托管多个网站的能力，那么服务器必须知道浏览器请求的是哪个域名下的资源。</p> <p><code>Host: rlog.cn</code></p> <p>这只是基本的主机名，包含域名和子级域名。</p> <p>在PHP中，可以通过$_SERVER['HTTP_HOST'] 或 $_SERVER['SERVER_NAME']来查看。</p> <h3>User-Agent</h3> <p><code>User-Agent: Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US; rv:1.9.1.5) Gecko/20091102 Firefox/3.5.5 (.NET CLR 3.5.30729)</code></p> <p>这个头部可以携带如下几条信息：</p> <ul><li>浏览器名和版本号.</li><li>操作系统名和版本号.</li><li>默认语言.</li></ul> <p>这就是某些网站用来收集访客信息的一般手段。例如，你可以判断访客是否在使用手机访问你的网站，然后决定是否将他们引导至一个在低分辨率下表现良好的移动网站。</p> <p>在PHP中，可以通过 $_SERVER['HTTP_USER_AGENT'] 来获取User-Agent</p> <p><code>if ( strstr($_SERVER['HTTP_USER_AGENT'],'MSIE 6') ) {<br />echo "Please stop using IE6!";<br />}</code></p> <h3>Accept-Language</h3> <p><code>Accept-Language: en-us,en;q=0.5</code></p> <p>这个信息可以说明用户的默认语言设置。如果网站有不同的语言版本，那么就可以通过这个信息来重定向用户的浏览器。</p> <p>它可以通过逗号分割来携带多国语言。第一个会是首选的语言，其它语言会携带一个&#8220;q&#8221;值，来表示用户对该语言的喜好程度（0~1）。</p> <p>在PHP中用&nbsp;$_SERVER["HTTP_ACCEPT_LANGUAGE"] 来获取这一信息。</p> <p><code>if (substr($_SERVER['HTTP_ACCEPT_LANGUAGE'], 0, 2) == 'fr') {<br />header('Location: http://french.mydomain.com');<br />}</code></p> <h3>Accept-Encoding</h3> <p><code>Accept-Encoding: gzip,deflate</code></p> <p>大部分的现代浏览器都支持gzip压缩，并会把这一信息报告给服务器。这时服务器就会压缩过的HTML发送给浏览器。这可以减少近80%的文件大小，以节省下载时间和带宽。</p> <p>在PHP中可以使用&nbsp;$_SERVER["HTTP_ACCEPT_ENCODING"] 获取该信息。 然后调用<a href="http://www.php.net/manual/en/function.ob-gzhandler.php">ob_gzhandler()</a>方法时会自动检测该值，所以你无需手动检测。</p> <p><code>// enables output buffering<br />// and all output is compressed if the browser supports it<br />ob_start('ob_gzhandler');</code></p> <h3>If-Modified-Since</h3> <p>如果一个页面已经在你的浏览器中被缓存，那么你下次浏览时浏览器将会检测文档是否被修改过，那么它就会发送这样的头部：</p> <p><code>If-Modified-Since: Sat, 28 Nov 2009 06:38:19 GMT</code></p> <p>如果自从这个时间以来未被修改过，那么服务器将会返回&#8220;304 Not Modified&#8221;，而且不会再返回内容。浏览器将自动去缓存中读取内容</p> <p>在PHP中，可以用$_SERVER['HTTP_IF_MODIFIED_SINCE'] 来检测。</p> <p><code>// assume $last_modify_time was the last the output was updated<br />// did the browser send If-Modified-Since header?<br />if(isset($_SERVER['HTTP_IF_MODIFIED_SINCE'])) {<br />// if the browser cache matches the modify time<br />if ($last_modify_time == strtotime($_SERVER['HTTP_IF_MODIFIED_SINCE'])) {<br />// send a 304 header, and no content<br />header("HTTP/1.1 304 Not Modified");<br />exit;<br />}<br />}</code></p> <p>还有一个叫Etag的HTTP头信息，它被用来确定缓存的信息是否正确，稍后我们将会解释它。</p> <h3>Cookie</h3> <p>顾名思义，他会发送你浏览器中存储的Cookie信息给服务器。</p> <p><code>Cookie: PHPSESSID=r2t5uvjq435r4q7ib3vtdjq120; foo=bar</code></p> <p>它是用分号分割的一组名值对。Cookie也可以包含session id。</p> <p>在PHP中，单一的Cookie可以访问$_COOKIE数组获得。你可以直接用$_SESSION array获取session变量。如果你需要session id，那么你可以使用session_id()函数代替cookie。</p> <p><code>echo $_COOKIE['foo'];<br />// output: bar<br />echo $_COOKIE['PHPSESSID'];<br />// output: r2t5uvjq435r4q7ib3vtdjq120<br />session_start();<br />echo session_id();<br />// output: r2t5uvjq435r4q7ib3vtdjq120</code></p> <h3>Referer</h3> <p>顾名思义, 头部将会包含referring url信息。</p> <p>例如，我访问Nettuts+的主页并点击了一个链接，这个头部信息将会发送到浏览器：<br /><code>Referer:&nbsp;http://net.tutsplus.com/ </code></p> <p>在PHP中，可以通过&nbsp;$_SERVER['HTTP_REFERER'] 获取该值。</p> <p><code>if (isset($_SERVER['HTTP_REFERER'])) {<br />$url_info = parse_url($_SERVER['HTTP_REFERER']);<br />// is the surfer coming from Google?<br />if ($url_info['host'] == 'www.google.com') {<br />parse_str($url_info['query'], $vars);<br />echo "You searched on Google for this keyword: ". $vars['q'];<br />}<br />}<br />// if the referring url was:<br />// http://www.google.com/search?source=ig&amp;hl=en&amp;rlz=&amp;=&amp;q=http+headers&amp;aq=f&amp;oq=&amp;aqi=g-p1g9<br />// the output will be:<br />// You searched on Google for this keyword: http headers</code></p> <p>You may have noticed the word &#8220;referrer&#8221; is misspelled as &#8220;referer&#8221;.  Unfortunately it made into the official HTTP specifications like that  and got stuck.</p> <h3>Authorization</h3> <p>当一个页面需要授权，浏览器就会弹出一个登陆窗口，输入正确的帐号后，浏览器会发送一个HTTP请求，但此时会包含这样一个头部：</p> <p><code>Authorization: Basic bXl1c2VyOm15cGFzcw==</code></p> <p>包含在头部的这部分信息是base64 encoded。例如，base64_decode(&#8216;bXl1c2VyOm15cGFzcw==&#8217;) 会被转化为 &#8216;myuser:mypass&#8217; 。</p> <p>在PHP中，这个值可以用$_SERVER['PHP_AUTH_USER'] 和 $_SERVER['PHP_AUTH_PW'] 获得。</p> <p>更多细节我们会在WWW-Authenticate部分讲解。</p> <h2>HTTP Headers 中的 HTTP响应</h2> <p>现在让我了解一些常见的HTTP Headers中的HTTP响应信息。</p> <p>在PHP中，你可以通过&nbsp;<a href="http://php.net/manual/en/function.header.php">header()</a> 来设置头部响应信息。PHP已经自动发送了一些必要的头部信息，如 载入的内容，设置 cookies 等等&#8230; 你可以通过&nbsp;<a href="http://www.php.net/manual/en/function.headers-list.php">headers_list()</a> 函数看到已发送和将要发送的头部信息。你也可以使用<a href="http://www.php.net/manual/en/function.headers-sent.php">headers_sent()</a>函数来检查头部信息是否已经被发送。</p> <h3>Cache-Control</h3> <p>w3.org 的定义是：&#8220;The Cache-Control general-header field is used to  specify directives which MUST be obeyed by all caching mechanisms along  the request/response chain.&#8221; 其中&#8220;caching mechanisms&#8221; 包含一些你ISP可能会用到的  网关和代理信息。</p> <p>例如：</p> <p><code>Cache-Control: max-age=3600, public</code></p> <p>&#8220;public&#8221;意味着这个响应可以被任何人缓存，&#8220;max-age&#8221; 则表明了该缓存有效的秒数。允许你的网站被缓存降大大减少下载时间和带宽，同时也提高的浏览器的载入速度。</p> <p>也可以通过设置 &#8220;no-cache&#8221; &nbsp;指令来禁止缓存：</p> <p><code>Cache-Control:&nbsp;no-cache </code></p> <p>更多详情请参见<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9">w3.org</a>。</p> <h3>Content-Type</h3> <p>这个头部包含了文档的&#8221;mime-type&#8221;。浏览器将会依据该参数决定如何对文档进行解析。例如，一个html页面（或者有html输出的php页面）将会返回这样的东西：</p> <p><code>Content-Type: text/html; charset=UTF-8</code></p> <p><span>&#8216;text&#8217; 是文档类型，&#8216;html&#8217;则是文档子类型。 这个头部还包括了更多信息，例如 charset。</span></p> <p><span>如果是一个图片，将会发送这样的响应：</span></p> <p><code>Content-Type: image/gif</code></p> <p>浏览器可以通过mime-type来决定使用外部程序还是自身扩展来打开该文档。如下的例子降调用Adobe Reader：</p> <p><code>Content-Type: application/pdf</code></p> <p>直接载入，Apache通常会自动判断文档的mime-type并且添加合适的信息到头部去。并且大部分浏览器都有一定程度的容错，在头部未提供或者错误提供该信息的情况下它会去自动检测mime-type。</p> <p>你可以在<a href="http://www.webmaster-toolkit.com/mime-types.shtml" target="_blank">这里</a>找到一个常用mime-type列表。</p> <p>在PHP中你可以通过&nbsp;<a href="http://www.php.net/manual/en/function.finfo-file.php">finfo_file()</a> 来检测文件的ime-type。</p> <h3>Content-Disposition</h3> <p>这个头部信息将告诉浏览器打开一个文件下载窗口，而不是试图解析该响应的内容。例如：</p> <p><code>Content-Disposition: attachment; filename="download.zip"</code></p> <p>他会导致浏览器出现这样的对话框：</p> <p><img alt="" src="http://pic002.cnblogs.com/images/2011/337467/2011102010552819.png" /></p> <p>注意，适合它的Content-Type头信息同时也会被发送</p> <p><code>Content-Type: application/zip<br />Content-Disposition: attachment; filename="download.zip"</code></p> <h3>Content-Length</h3> <p>当内容将要被传输到浏览器时，服务器可以通过该头部告知浏览器将要传送文件的大小（bytes）。</p> <p><code>Content-Length: 89123</code></p> <p><span>对于文件下载来说这个信息相当的有用。这就是为什么浏览器知道下载进度的原因。</span></p> <p><span>例如，这里我写了一段虚拟脚本，来模拟一个慢速下载。</span></p> <p><code>// it's a zip file<br />header('Content-Type: application/zip');<br />// 1 million bytes (about 1megabyte)<br />header('Content-Length: 1000000');<br />// load a download dialogue, and save it as download.zip<br />header('Content-Disposition: attachment; filename="download.zip"');<br />// 1000 times 1000 bytes of data<br />for ($i = 0; $i &lt; 1000; $i++) {<br />echo str_repeat(".",1000);<br />// sleep to slow down the download<br />usleep(50000);<br />}</code></p> <p>结果将会是这样的：</p> <p><img alt="" src="http://pic002.cnblogs.com/images/2011/337467/2011102010560235.png" /></p> <p>现在，我将Content-Length头部注释掉：</p> <p><code>// it's a zip file<br />header('Content-Type: application/zip');<br />// the browser won't know the size<br />// header('Content-Length: 1000000');<br />// load a download dialogue, and save it as download.zip<br />header('Content-Disposition: attachment; filename="download.zip"');<br />// 1000 times 1000 bytes of data<br />for ($i = 0; $i &lt; 1000; $i++) {<br />echo str_repeat(".",1000);<br />// sleep to slow down the download<br />usleep(50000);<br />}</code></p> <p>结果就变成了这样：</p> <p><img alt="" src="http://pic002.cnblogs.com/images/2011/337467/2011102010563325.png" /></p> <p>这个浏览器只会告诉你已下载了多少，但不会告诉你总共需要下载多少。而且进度条也不会显示进度。</p> <h3>Etag</h3> <p>这是另一个为缓存而产生的头部信息。它看起来会是这样：</p> <p><code>Etag: "pub1259380237;gz"</code></p> <p><span>服务器可能会将该信息和每个被发送文件一起响应给浏览器。该值可以包含文档的最后修改日期，文件大小或者文件校验和。浏览会把它和所接收到的文档一起缓存。下一次当浏览器再次请求同一文件时将会发送如下的HTTP请求：</span></p> <p><code>If-None-Match: "pub1259380237;gz"</code></p> <p>如果所请求的文档Etag值和它一致，服务器将会发送304状态码，而不是2oo。并且不返回内容。浏览器此时就会从缓存加载该文件。</p> <h3>Last-Modified</h3> <p>顾名思义，这个头部信息用GMT格式表明了文档的最后修改时间：</p> <p><code>Last-Modified: Sat, 28 Nov 2009 03:50:37 GMT</code></p> <p><code>$modify_time = filemtime($file);<br />header("Last-Modified: " . gmdate("D, d M Y H:i:s", $modify_time) . " GMT");</code></p> <p>它提供了另一种缓存机制。浏览器可能会发送这样的请求：</p> <p><code>If-Modified-Since: Sat, 28 Nov 2009 06:38:19 GMT</code></p> <p><span>在If-Modified-Since一节我们已经讨论过了。</span></p> <h3>Location</h3> <p>这个头部是用来重定向的。如果响应代码为 301 或者 302 ，服务器就必须发送该头部。例如，当你访问&nbsp;http://www.nettuts.com 时浏览器就会收到如下的响应：</p> <p><code>HTTP/1.x&nbsp;301&nbsp;Moved&nbsp;Permanently<br />...<br />Location:&nbsp;http://net.tutsplus.com/<br />...</code></p> <p>在PHP中你可以通过这种方式对访客重定向：<br /><code>header('Location: http://net.tutsplus.com/');</code></p> <p>默认会发送302状态码，如果你想发送301，就这样写：</p> <p><code>header('Location: http://net.tutsplus.com/', true, 301);</code></p> <h3>Set-Cookie</h3> <p>当一个网站需要设置或者更新你浏览的cookie信息时，它就会使用这样的头部：</p> <p><code>Set-Cookie: skin=noskin; path=/; domain=.amazon.com; expires=Sun, 29-Nov-2009 21:42:28 GMT<br />Set-Cookie: session-id=120-7333518-8165026; path=/; domain=.amazon.com; expires=Sat Feb 27 08:00:00 2010 GMT</code></p> <p>每个cookie会作为单独的一条头部信息。注意，通过js设置cookie将不会体现在HTTP头中。</p> <p>在PHP中，你可以通过<a href="http://php.net/manual/en/function.setcookie.php">setcookie()</a>函数来设置cookie，PHP会发送合适的HTTP 头。</p> <p><code>setcookie("TestCookie", "foobar");</code></p> <p>它会发送这样的头信息：</p> <p><code>Set-Cookie: TestCookie=foobar</code></p> <p>如果未指定到期时间，cookie就会在浏览器关闭后被删除。</p> <h3>WWW-Authenticate</h3> <p>一个网站可能会通过HTTP发送这个头部信息来验证用户。当浏览器看到头部有这个响应时就会打开一个弹出窗。</p> <p><code>WWW-Authenticate: Basic realm="Restricted Area"</code></p> <p>它会看起来像这样：</p> <p><img alt="" src="http://pic002.cnblogs.com/images/2011/337467/2011102010571638.png" /></p> <p>在<a href="http://nettuts.s3.amazonaws.com/511_http/401_prompt.png" target="_blank">PHP手册的一章</a>中就有一段简单的代码演示了如果用PHP做这样的事情：</p> <p><code>if (!isset($_SERVER['PHP_AUTH_USER'])) {<br />header('WWW-Authenticate: Basic realm="My Realm"');<br />header('HTTP/1.0 401 Unauthorized');<br />echo 'Text to send if user hits Cancel button';<br />exit;<br />} else {<br />echo "&lt;p&gt;Hello {$_SERVER['PHP_AUTH_USER']}.&lt;/p&gt;";<br />echo "&lt;p&gt;You entered {$_SERVER['PHP_AUTH_PW']} as your password.&lt;/p&gt;";<br />}</code></p> <h3>Content-Encoding</h3> <p>这个头部通常会在返回内容被压缩时设置。</p> <p><code>Content-Encoding: gzip</code></p> <p>在PHP中，如果你调用了<a href="http://www.php.net/manual/en/function.ob-gzhandler.php">ob_gzhandler()</a>函数，这个头部将会自动被设置。</p></div>转载：<div>http://www.cnblogs.com/guyoung/archive/2011/10/20/2218647.html</div></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>


		</div>
		<div class = "postDesc">posted @ <span id="post-date">2011-10-20 14:49</span> <a href='http://www.cnblogs.com/yuzhongwusan/'>yuzhongwusan</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href ="http://i.cnblogs.com/EditPosts.aspx?postid=2218954" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(2218954);return false;">收藏</a></div>
	</div>
	<script type="text/javascript">var allowComments=true,isLogined=false,cb_blogId=38146,cb_entryId=2218954,cb_blogApp=currentBlogApp,cb_blogUserGuid='753e420b-63cf-dd11-9e4d-001cf0cd104b',cb_entryCreatedDate='2011/10/20 14:49:00';loadViewCount(cb_entryId);</script>
	
</div><!--end: topics 文章、评论容器-->
<a name="!comments"></a><div id="blog-comments-placeholder"></div><script type="text/javascript">var commentManager = new blogCommentManager();commentManager.renderComments(0);</script>
<div id="comment_form" class="commentform">
<a name="commentform"></a>
<div id="divCommentShow"></div>
<div id="comment_nav"><span id="span_refresh_tips"></span><a href="javascript:void(0);" id="lnk_RefreshComments" onclick="return RefreshCommentList();">刷新评论</a><a href="#" onclick="return RefreshPage();">刷新页面</a><a href="#top">返回顶部</a></div>
<div id="comment_form_container"></div>
<div class="ad_text_commentbox" id="ad_text_under_commentbox"></div>
<div id="site_nav_under"><a href="http://www.cnblogs.com/" target="_blank" title="开发者的网上家园">博客园首页</a><a href="http://q.cnblogs.com/" target="_blank" title="程序员问答社区">博问</a><a href="http://news.cnblogs.com/" target="_blank" title="IT新闻">新闻</a><a href="http://home.cnblogs.com/ing/" target="_blank">闪存</a><a href="http://job.cnblogs.com/" target="_blank">程序员招聘</a><a href="http://kb.cnblogs.com/" target="_blank">知识库</a></div>
<div id="opt_under_post"></div>
<script type="text/javascript">
    var enableGoogleAd = canShowAdsense(); var googletag = googletag || {}; googletag.cmd = googletag.cmd || [];
    fixPostBodyFormat();
</script>
<div id="ad_under_post_holder">
<script type='text/javascript'>
    var googletag = googletag || {};
    googletag.cmd = googletag.cmd || [];
    (function () {
        if (enableGoogleAd) {
            var gads = document.createElement('script');
            gads.async = true;
            gads.type = 'text/javascript';
            var useSSL = 'https:' == document.location.protocol;
            gads.src = (useSSL ? 'https:' : 'http:') + '//www.googletagservices.com/tag/js/gpt.js';
            var node = document.getElementsByTagName('script')[0];
            node.parentNode.insertBefore(gads, node);
        }
    })();
</script>
<script type='text/javascript'>
    try {
        if (enableGoogleAd) {
            googletag.cmd.push(function () {
                googletag.defineSlot('/1090369/cnblogs_blogpost_C1_sitehome', [300, 250], 'div-gpt-ad-1346480159711-0').addService(googletag.pubads());
                googletag.defineSlot('/1090369/cnblogs_blogpost_C2', [468, 60], 'div-gpt-ad-1410860226396-0').addService(googletag.pubads());
                googletag.pubads().enableSingleRequest();
                googletag.enableServices();
            });
        };
    } catch (e) { }
</script>
<div id="google_ad_c1" class="c_ad_block">
    <div id='div-gpt-ad-1346480159711-0' style='width:300px; height:250px;'>
    <script type='text/javascript'>
        try {
            if (enableGoogleAd) {
                googletag.cmd.push(function () { googletag.display('div-gpt-ad-1346480159711-0'); });            
            } else {
                $('#div-gpt-ad-1346480159711-0').hide();
            }
    } catch (e) { }
    </script>
    </div>
</div>
</div>
<div id="under_post_news"></div>
<div id="google_ad_c2" class="c_ad_block">
<div id='div-gpt-ad-1410860226396-0' style='width:468px; height:60px;'>
<script type='text/javascript'>
try {
    if (enableGoogleAd) {
        googletag.cmd.push(function () { googletag.display('div-gpt-ad-1410860226396-0'); });
    } else {
        $('#div-gpt-ad-1346480159711-0').hide();
    }
} catch (e) { }
</script>
</div>
</div>
<div id="under_post_kb"></div>
<div id="HistoryToday" class="c_ad_block"></div>
<script type="text/javascript">
$(function () {
    loadNewsAndKb();
    loadBlogSignature();
    LoadPostInfoBlock(cb_blogId, cb_entryId, cb_blogApp, cb_blogUserGuid);
    GetPrevNextPost(cb_entryId, cb_blogId, cb_entryCreatedDate);
    loadOptUnderPost();
    GetHistoryToday(cb_blogId, cb_blogApp, cb_entryCreatedDate);
    setTimeout(function () { incrementViewCount(cb_entryId); }, 200);
});
</script>
</div>

	</div><!--end: forFlow -->
	</div><!--end: mainContent 主体内容容器-->

	<div id="sideBar">
		<div id="sideBarMain">
			
<!--done-->
<div class="newsItem">
<h3 class="catListTitle">公告</h3>
	<div id="blog-news"></div><script type="text/javascript">loadBlogNews();</script>
</div>

			<div id="blog-calendar" style="display:none"></div><script type="text/javascript">loadBlogDefaultCalendar();</script>
			
			<div id="leftcontentcontainer">
				<div id="blog-sidecolumn"></div><script type="text/javascript">loadBlogSideColumn();</script>
			</div>
			
		</div><!--end: sideBarMain -->
	</div><!--end: sideBar 侧边栏容器 -->
	<div class="clear"></div>
	</div><!--end: main -->
	<div class="clear"></div>
	<div id="footer">
		
<!--done-->
Copyright &copy;2015 yuzhongwusan
	</div><!--end: footer -->
</div><!--end: home 自定义的最大容器 -->
<!--PageEndHtml Block Begin-->
<style>
#header {
background: url('/skins/summerGarden/images/header.jpg') no-repeat right -14px;}
</style>
<!--PageEndHtml Block End-->
</body>
</html>

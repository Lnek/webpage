<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>libnl: Core Netlink API</title>
<link href="libnl.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<h1>Core Netlink API</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user" compact><dt><b>1) Creating the netlink handle</b></dt><dd></dd></dl>

<p>
<div class="fragment"><pre class="fragment"> <span class="keyword">struct </span>nl_handle *handle;

 <span class="comment">// Allocate and initialize a new netlink handle</span>
 handle = nl_handle_new();

 <span class="comment">// Are multiple handles being allocated? You have to provide a unique</span>
 <span class="comment">// netlink process id and overwrite the default local process id.</span>
 <a class="code" href="group__nl.html#g22553b091b68b944b1f630035684ca10">nl_handle_set_pid</a>(handle, MY_UNIQUE_PID);

 <span class="comment">// Is this socket used for event processing? You need to disable sequence</span>
 <span class="comment">// number checking in order to be able to receive messages not explicitely</span>
 <span class="comment">// requested.</span>
 <a class="code" href="group__nl.html#g0ff2f43147e3a4547f7109578b3ca422">nl_disable_sequence_check</a>(handle);

 <span class="comment">// Use nl_handle_get_fd() to fetch the file description, for example to</span>
 <span class="comment">// put a socket into non-blocking i/o mode.</span>
 fcntl(<a class="code" href="group__nl.html#gee55e77a728b9d25360859f74560f0aa">nl_handle_get_fd</a>(handle), F_SETFL, O_NONBLOCK);
</pre></div><p>
<dl class="user" compact><dt><b>2) Joining Groups</b></dt><dd><div class="fragment"><pre class="fragment"> <span class="comment">// You may join/subscribe to as many groups as you want, don't forget</span>
 <span class="comment">// to eventually disable sequence number checking. Note: Joining must</span>
 <span class="comment">// be done before connecting/binding the socket.</span>
 <a class="code" href="group__nl.html#gb6a2c1fb173efe3696184bdb2c5f5ae7">nl_join_groups</a>(handle, GROUP_ID1 | GROUP_ID2);
</pre></div></dd></dl>
<dl class="user" compact><dt><b>3) Connecting the socket</b></dt><dd><div class="fragment"><pre class="fragment"> <span class="comment">// Bind and connect the socket to a protocol, NETLINK_ROUTE in this example.</span>
 <a class="code" href="group__nl.html#g68655d7fa8bd1944bec4761c95e576e9">nl_connect</a>(handle, NETLINK_ROUTE);
</pre></div></dd></dl>
<dl class="user" compact><dt><b>4) Sending data</b></dt><dd><div class="fragment"><pre class="fragment"> <span class="comment">// The most rudimentary method is to use nl_sendto() simply pushing</span>
 <span class="comment">// a piece of data to the other netlink peer. This method is not</span>
 <span class="comment">// recommended.</span>
 <span class="keyword">const</span> <span class="keywordtype">char</span> buf[] = { 0x01, 0x02, 0x03, 0x04 };
 <a class="code" href="group__nl.html#g53ee384f123fa3c354ad43adb6cf647d">nl_sendto</a>(handle, buf, <span class="keyword">sizeof</span>(buf));

 <span class="comment">// A more comfortable interface is nl_send() taking a pointer to</span>
 <span class="comment">// a netlink message.</span>
 <span class="keyword">struct </span>nl_msg *msg = my_msg_builder();
 <a class="code" href="group__nl.html#g5f3fff85c39f18946100c85f09d2c41c">nl_send</a>(handle, <a class="code" href="group__msg.html#ga5f29579d86d2bdab26c312b44b56de7">nlmsg_hdr</a>(msg));

 <span class="comment">// nl_sendmsg() provides additional control over the sendmsg() message</span>
 <span class="comment">// header in order to allow more specific addressing of multiple peers etc.</span>
 <span class="keyword">struct </span>msghdr hdr = { ... };
 <a class="code" href="group__nl.html#gf3dca993337ed2d60a42269eaab65585">nl_sendmsg</a>(handle, <a class="code" href="group__msg.html#ga5f29579d86d2bdab26c312b44b56de7">nlmsg_hdr</a>(msg), &amp;hdr);

 <span class="comment">// You're probably too lazy to fill out the netlink pid, sequence number</span>
 <span class="comment">// and message flags all the time. nl_send_auto_complete() automatically</span>
 <span class="comment">// extends your message header as needed with an appropriate sequence</span>
 <span class="comment">// number, the netlink pid stored in the netlink handle and the message</span>
 <span class="comment">// flags NLM_F_REQUEST and NLM_F_ACK</span>
 <a class="code" href="group__nl.html#g01a2aad82350f867e704d5c696438b60">nl_send_auto_complete</a>(handle, <a class="code" href="group__msg.html#ga5f29579d86d2bdab26c312b44b56de7">nlmsg_hdr</a>(msg));

 <span class="comment">// Simple protocols don't require the complex message construction interface</span>
 <span class="comment">// and may favour nl_send_simple() to easly send a bunch of payload</span>
 <span class="comment">// encapsulated in a netlink message header.</span>
 <a class="code" href="group__nl.html#g73ed88a505f2d67bcf328183fe1e692a">nl_send_simple</a>(handle, MY_MSG_TYPE, 0, buf, <span class="keyword">sizeof</span>(buf));
</pre></div></dd></dl>
<dl class="user" compact><dt><b>5) Receiving data</b></dt><dd><div class="fragment"><pre class="fragment"> <span class="comment">// nl_recv() receives a single message allocating a buffer for the message</span>
 <span class="comment">// content and gives back the pointer to you.</span>
 <span class="keyword">struct </span><a class="code" href="structsockaddr__nl.html">sockaddr_nl</a> peer;
 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *msg;
 <a class="code" href="group__nl.html#g060acc8371fdb242c5ae3d5b761d28e1">nl_recv</a>(handle, &amp;peer, &amp;msg);

 <span class="comment">// nl_recvmsgs() receives a bunch of messages until the callback system</span>
 <span class="comment">// orders it to state, usually after receving a compolete multi part</span>
 <span class="comment">// message series.</span>
 <a class="code" href="group__nl.html#g1bb066e1772b89f79fe1d76a4ef243a6">nl_recvmsgs</a>(handle, my_callback_configuration);

 <span class="comment">// nl_recvmsgs_def() acts just like nl_recvmsg() but uses the callback</span>
 <span class="comment">// configuration stored in the handle.</span>
 <a class="code" href="group__nl.html#g4e2c8db16c58634c08fd92f8d52a6873">nl_recvmsgs_def</a>(handle);

 <span class="comment">// In case you want to wait for the ACK to be recieved that you requested</span>
 <span class="comment">// with your latest message, you can call nl_wait_for_ack()</span>
 <a class="code" href="group__nl.html#ga65fec588e0a0a2de1881fb8366ccd79">nl_wait_for_ack</a>(handle);
</pre></div></dd></dl>
<dl class="user" compact><dt><b>6) Cleaning up</b></dt><dd><div class="fragment"><pre class="fragment"> <span class="comment">// Close the socket first to release kernel memory</span>
 <a class="code" href="group__nl.html#g25039e93db5ab64ce4345ffe14379530">nl_close</a>(handle);

 <span class="comment">// Finally destroy the netlink handle</span>
 <a class="code" href="group__nl.html#gf73c4d1d895ec4cd19f504aae96219b5">nl_handle_destroy</a>(handle);
</pre></div> </dd></dl>

<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Modules</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__attr.html">Attributes</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Netlink Attributes Construction/Parsing Interface. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cb.html">Callbacks/Customization</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Customization via callbacks. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__msg.html">Messages</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Netlink Message Construction/Parsing Interface. <br></td></tr>

<p>
<tr><td colspan="2"><br><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsockaddr__nl.html">sockaddr_nl</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Netlink socket address.  <a href="structsockaddr__nl.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Netlink Family Translations</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nl.html#g2012d14c1247975ca68fd8070e18cb3d">nl_nlfamily2str</a> (int family, char *buf, size_t size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert netlink family to character string.  <a href="#g2012d14c1247975ca68fd8070e18cb3d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nl.html#g864f4b90d7777ec2b9d978a0db9404a7">nl_str2nlfamily</a> (const char *name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert character string to netlink family.  <a href="#g864f4b90d7777ec2b9d978a0db9404a7"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Handle Management</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">nl_handle *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nl.html#g3c7b2f6b613e7bde0e610a138afd07b4">nl_handle_alloc_nondefault</a> (enum <a class="el" href="group__cb.html#gba3fabad0c62db483941101e1a18d14d">nl_cb_kind</a> kind)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate and initialize new non-default netlink handle.  <a href="#g3c7b2f6b613e7bde0e610a138afd07b4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">nl_handle *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nl.html#gf903c9ea089735b1ba8e40dae801c47d">nl_handle_alloc</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate and initialize new netlink handle.  <a href="#gf903c9ea089735b1ba8e40dae801c47d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nl.html#gf73c4d1d895ec4cd19f504aae96219b5">nl_handle_destroy</a> (struct nl_handle *handle)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroy netlink handle.  <a href="#gf73c4d1d895ec4cd19f504aae96219b5"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Utilities</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nl.html#g0b6d4741ee2ec8f0392b600a626ff1fd">nl_set_buffer_size</a> (struct nl_handle *handle, int rxbuf, int txbuf)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set socket buffer size of netlink handle.  <a href="#g0b6d4741ee2ec8f0392b600a626ff1fd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nl.html#g4caab1fb14937565d7b38b57742a82ce">nl_set_passcred</a> (struct nl_handle *handle, int state)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enable/disable credential passing on netlink handle.  <a href="#g4caab1fb14937565d7b38b57742a82ce"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nl.html#gb6a2c1fb173efe3696184bdb2c5f5ae7">nl_join_groups</a> (struct nl_handle *handle, int groups)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Join multicast groups.  <a href="#gb6a2c1fb173efe3696184bdb2c5f5ae7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nl.html#ge7f554f1cfd2c07e9adcb05105e59c79">nl_join_group</a> (struct nl_handle *handle, int group)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set socket buffer size of netlink handle.  <a href="#ge7f554f1cfd2c07e9adcb05105e59c79"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nl.html#g0ff2f43147e3a4547f7109578b3ca422">nl_disable_sequence_check</a> (struct nl_handle *handle)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disable sequence number checking.  <a href="#g0ff2f43147e3a4547f7109578b3ca422"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nl.html#g631ac82d7c9eaa99699ee2f6cb7b89e9">SOL_NETLINK</a>&nbsp;&nbsp;&nbsp;270</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set socket buffer size of netlink handle.  <a href="#g631ac82d7c9eaa99699ee2f6cb7b89e9"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Acccess Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">pid_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nl.html#g6c7211051174ef2e72f92b907b2899eb">nl_handle_get_pid</a> (struct nl_handle *handle)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get netlink process identifier of netlink handle.  <a href="#g6c7211051174ef2e72f92b907b2899eb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nl.html#g22553b091b68b944b1f630035684ca10">nl_handle_set_pid</a> (struct nl_handle *handle, pid_t pid)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set netlink process identifier of netlink handle.  <a href="#g22553b091b68b944b1f630035684ca10"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">pid_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nl.html#gd6077e0c736002818ae0fc27e5249a9d">nl_handle_get_peer_pid</a> (struct nl_handle *handle)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get netlink process identifier of peer from netlink handle.  <a href="#gd6077e0c736002818ae0fc27e5249a9d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nl.html#g20d5d58031456e8ecccf9cdf063adc22">nl_handle_set_peer_pid</a> (struct nl_handle *handle, pid_t pid)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set netlink process identifier of peer in netlink handle.  <a href="#g20d5d58031456e8ecccf9cdf063adc22"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nl.html#gee55e77a728b9d25360859f74560f0aa">nl_handle_get_fd</a> (struct nl_handle *handle)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get file descriptor of netlink handle.  <a href="#gee55e77a728b9d25360859f74560f0aa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsockaddr__nl.html">sockaddr_nl</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nl.html#g5fba711956ae0c71a2639dd9bfb4c762">nl_handle_get_local_addr</a> (struct nl_handle *handle)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get local netlink address of netlink handle.  <a href="#g5fba711956ae0c71a2639dd9bfb4c762"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsockaddr__nl.html">sockaddr_nl</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nl.html#gefe94defe49ed2d3c6ea5f91058f6e22">nl_handle_get_peer_addr</a> (struct nl_handle *handle)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get peer netlink address of netlink handle.  <a href="#gefe94defe49ed2d3c6ea5f91058f6e22"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">nl_cb *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nl.html#g684f3801dbd5dc27bfa630da486a281f">nl_handle_get_cb</a> (struct nl_handle *handle)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get callback configuration of netlink handle.  <a href="#g684f3801dbd5dc27bfa630da486a281f"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Connection Management</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nl.html#g68655d7fa8bd1944bec4761c95e576e9">nl_connect</a> (struct nl_handle *handle, int protocol)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create and connect netlink socket.  <a href="#g68655d7fa8bd1944bec4761c95e576e9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nl.html#g25039e93db5ab64ce4345ffe14379530">nl_close</a> (struct nl_handle *handle)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Close/Disconnect netlink socket.  <a href="#g25039e93db5ab64ce4345ffe14379530"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Send</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nl.html#g53ee384f123fa3c354ad43adb6cf647d">nl_sendto</a> (struct nl_handle *handle, void *buf, size_t size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send raw data over netlink socket.  <a href="#g53ee384f123fa3c354ad43adb6cf647d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nl.html#gf3dca993337ed2d60a42269eaab65585">nl_sendmsg</a> (struct nl_handle *handle, struct nl_msg *msg, struct msghdr *hdr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send netlink message with control over sendmsg() message header.  <a href="#gf3dca993337ed2d60a42269eaab65585"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nl.html#g5f3fff85c39f18946100c85f09d2c41c">nl_send</a> (struct nl_handle *handle, struct nl_msg *msg)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send netlink message.  <a href="#g5f3fff85c39f18946100c85f09d2c41c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nl.html#g01a2aad82350f867e704d5c696438b60">nl_send_auto_complete</a> (struct nl_handle *handle, struct nl_msg *msg)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send netlink message and check &amp; extend header values as needed.  <a href="#g01a2aad82350f867e704d5c696438b60"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nl.html#g73ed88a505f2d67bcf328183fe1e692a">nl_send_simple</a> (struct nl_handle *handle, int type, int flags, void *buf, size_t size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send simple netlink message using <a class="el" href="group__nl.html#g01a2aad82350f867e704d5c696438b60">nl_send_auto_complete()</a>.  <a href="#g73ed88a505f2d67bcf328183fe1e692a"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Receive</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nl.html#g060acc8371fdb242c5ae3d5b761d28e1">nl_recv</a> (struct nl_handle *handle, struct <a class="el" href="structsockaddr__nl.html">sockaddr_nl</a> *nla, unsigned char **buf, struct ucred **creds)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Receive netlink message from netlink socket.  <a href="#g060acc8371fdb242c5ae3d5b761d28e1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nl.html#g1bb066e1772b89f79fe1d76a4ef243a6">nl_recvmsgs</a> (struct nl_handle *handle, struct nl_cb *cb)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Receive a set of messages from a netlink socket.  <a href="#g1bb066e1772b89f79fe1d76a4ef243a6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nl.html#g4e2c8db16c58634c08fd92f8d52a6873">nl_recvmsgs_def</a> (struct nl_handle *handle)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Receive a set of message from a netlink socket using handlers in nl_handle.  <a href="#g4e2c8db16c58634c08fd92f8d52a6873"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nl.html#ga65fec588e0a0a2de1881fb8366ccd79">nl_wait_for_ack</a> (struct nl_handle *handle)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for ACK.  <a href="#ga65fec588e0a0a2de1881fb8366ccd79"></a><br></td></tr>
</table>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="g631ac82d7c9eaa99699ee2f6cb7b89e9"></a><!-- doxytag: member="nl.c::SOL_NETLINK" ref="g631ac82d7c9eaa99699ee2f6cb7b89e9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOL_NETLINK&nbsp;&nbsp;&nbsp;270          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set socket buffer size of netlink handle. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>Netlink handle. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rxbuf</em>&nbsp;</td><td>New receive socket buffer size in bytes. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>txbuf</em>&nbsp;</td><td>New transmit socket buffer size in bytes.</td></tr>
  </table>
</dl>
Sets the socket buffer size of a netlink handle to the specified values <code>rxbuf</code> and <code>txbuf</code>. Providing a value of <code>0</code> assumes a good default value.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>It is not required to call this function prior to <a class="el" href="group__nl.html#g68655d7fa8bd1944bec4761c95e576e9">nl_connect()</a>. </dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on sucess or a negative error code. </dd></dl>

<p>
Definition at line <a class="el" href="nl_8c-source.html#l00275">275</a> of file <a class="el" href="nl_8c-source.html">nl.c</a>.
<p>
Referenced by <a class="el" href="nl_8c-source.html#l00278">nl_join_group()</a>.
</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="g3c7b2f6b613e7bde0e610a138afd07b4"></a><!-- doxytag: member="nl.c::nl_handle_alloc_nondefault" ref="g3c7b2f6b613e7bde0e610a138afd07b4" args="(enum nl_cb_kind kind)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct nl_handle* nl_handle_alloc_nondefault           </td>
          <td>(</td>
          <td class="paramtype">enum <a class="el" href="group__cb.html#gba3fabad0c62db483941101e1a18d14d">nl_cb_kind</a>&nbsp;</td>
          <td class="paramname"> <em>kind</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Allocate and initialize new non-default netlink handle. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>kind</em>&nbsp;</td><td>Kind of callback handler to use per default.</td></tr>
  </table>
</dl>
Allocates and initializes a new netlink handle, the netlink process id is set to the local process id which may conflict if multiple handles are created, therefore you may have to overwrite it using <a class="el" href="group__nl.html#g22553b091b68b944b1f630035684ca10">nl_handle_set_pid()</a>. The initial sequence number is initialized to the current UNIX time.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Newly allocated netlink handle or NULL. </dd></dl>

<p>
Definition at line <a class="el" href="nl_8c-source.html#l00140">140</a> of file <a class="el" href="nl_8c-source.html">nl.c</a>.
<p>
References <a class="el" href="handlers_8c-source.html#l00411">nl_cb_new()</a>, and <a class="el" href="nl_8c-source.html#l00185">nl_handle_destroy()</a>.
<p>
Referenced by <a class="el" href="nl_8c-source.html#l00176">nl_handle_alloc()</a>.
</div>
</div><p>
<a class="anchor" name="gf903c9ea089735b1ba8e40dae801c47d"></a><!-- doxytag: member="nl.c::nl_handle_alloc" ref="gf903c9ea089735b1ba8e40dae801c47d" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct nl_handle* nl_handle_alloc           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Allocate and initialize new netlink handle. 
<p>
Allocates and initializes a new netlink handle, the netlink process id is set to the local process id which may conflict if multiple handles are created, therefore you may have to overwrite it using <a class="el" href="group__nl.html#g22553b091b68b944b1f630035684ca10">nl_handle_set_pid()</a>. The initial sequence number is initialized to the current UNIX time. The default callback (NL_CB_DEFAULT) handlers are being used.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Newly allocated netlink handle or NULL. </dd></dl>

<p>
Definition at line <a class="el" href="nl_8c-source.html#l00176">176</a> of file <a class="el" href="nl_8c-source.html">nl.c</a>.
<p>
References <a class="el" href="group__cb.html#ggba3fabad0c62db483941101e1a18d14d07baae9c246d899cffd1ad49d7c001ce">NL_CB_DEFAULT</a>, and <a class="el" href="nl_8c-source.html#l00140">nl_handle_alloc_nondefault()</a>.
</div>
</div><p>
<a class="anchor" name="gf73c4d1d895ec4cd19f504aae96219b5"></a><!-- doxytag: member="nl.c::nl_handle_destroy" ref="gf73c4d1d895ec4cd19f504aae96219b5" args="(struct nl_handle *handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nl_handle_destroy           </td>
          <td>(</td>
          <td class="paramtype">struct nl_handle *&nbsp;</td>
          <td class="paramname"> <em>handle</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destroy netlink handle. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>Netlink handle. </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="nl_8c-source.html#l00185">185</a> of file <a class="el" href="nl_8c-source.html">nl.c</a>.
<p>
References <a class="el" href="handlers_8c-source.html#l00437">nl_cb_destroy()</a>.
<p>
Referenced by <a class="el" href="nl_8c-source.html#l00140">nl_handle_alloc_nondefault()</a>.
</div>
</div><p>
<a class="anchor" name="g0b6d4741ee2ec8f0392b600a626ff1fd"></a><!-- doxytag: member="nl.c::nl_set_buffer_size" ref="g0b6d4741ee2ec8f0392b600a626ff1fd" args="(struct nl_handle *handle, int rxbuf, int txbuf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nl_set_buffer_size           </td>
          <td>(</td>
          <td class="paramtype">struct nl_handle *&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>rxbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>txbuf</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set socket buffer size of netlink handle. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>Netlink handle. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rxbuf</em>&nbsp;</td><td>New receive socket buffer size in bytes. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>txbuf</em>&nbsp;</td><td>New transmit socket buffer size in bytes.</td></tr>
  </table>
</dl>
Sets the socket buffer size of a netlink handle to the specified values <code>rxbuf</code> and <code>txbuf</code>. Providing a value of <code>0</code> assumes a good default value.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>It is not required to call this function prior to <a class="el" href="group__nl.html#g68655d7fa8bd1944bec4761c95e576e9">nl_connect()</a>. </dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on sucess or a negative error code. </dd></dl>

<p>
Definition at line <a class="el" href="nl_8c-source.html#l00214">214</a> of file <a class="el" href="nl_8c-source.html">nl.c</a>.
<p>
Referenced by <a class="el" href="nl_8c-source.html#l00415">nl_connect()</a>.
</div>
</div><p>
<a class="anchor" name="g4caab1fb14937565d7b38b57742a82ce"></a><!-- doxytag: member="nl.c::nl_set_passcred" ref="g4caab1fb14937565d7b38b57742a82ce" args="(struct nl_handle *handle, int state)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nl_set_passcred           </td>
          <td>(</td>
          <td class="paramtype">struct nl_handle *&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>state</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enable/disable credential passing on netlink handle. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>Netlink handle </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>state</em>&nbsp;</td><td>New state (0 - disabled, 1 - enabled) </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="nl_8c-source.html#l00244">244</a> of file <a class="el" href="nl_8c-source.html">nl.c</a>.
</div>
</div><p>
<a class="anchor" name="gb6a2c1fb173efe3696184bdb2c5f5ae7"></a><!-- doxytag: member="nl.c::nl_join_groups" ref="gb6a2c1fb173efe3696184bdb2c5f5ae7" args="(struct nl_handle *handle, int groups)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nl_join_groups           </td>
          <td>(</td>
          <td class="paramtype">struct nl_handle *&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>groups</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Join multicast groups. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>Netlink handle. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>groups</em>&nbsp;</td><td>Bitmask of groups to join.</td></tr>
  </table>
</dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Joining of groups must be done prior to connecting/binding the socket (<a class="el" href="group__nl.html#g68655d7fa8bd1944bec4761c95e576e9">nl_connect()</a>). </dd></dl>

<p>
Definition at line <a class="el" href="nl_8c-source.html#l00269">269</a> of file <a class="el" href="nl_8c-source.html">nl.c</a>.
</div>
</div><p>
<a class="anchor" name="ge7f554f1cfd2c07e9adcb05105e59c79"></a><!-- doxytag: member="nl.c::nl_join_group" ref="ge7f554f1cfd2c07e9adcb05105e59c79" args="(struct nl_handle *handle, int group)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nl_join_group           </td>
          <td>(</td>
          <td class="paramtype">struct nl_handle *&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>group</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set socket buffer size of netlink handle. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>Netlink handle. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rxbuf</em>&nbsp;</td><td>New receive socket buffer size in bytes. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>txbuf</em>&nbsp;</td><td>New transmit socket buffer size in bytes.</td></tr>
  </table>
</dl>
Sets the socket buffer size of a netlink handle to the specified values <code>rxbuf</code> and <code>txbuf</code>. Providing a value of <code>0</code> assumes a good default value.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>It is not required to call this function prior to <a class="el" href="group__nl.html#g68655d7fa8bd1944bec4761c95e576e9">nl_connect()</a>. </dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on sucess or a negative error code. </dd></dl>

<p>
Definition at line <a class="el" href="nl_8c-source.html#l00278">278</a> of file <a class="el" href="nl_8c-source.html">nl.c</a>.
<p>
References <a class="el" href="nl_8c-source.html#l00275">SOL_NETLINK</a>.
</div>
</div><p>
<a class="anchor" name="g0ff2f43147e3a4547f7109578b3ca422"></a><!-- doxytag: member="nl.c::nl_disable_sequence_check" ref="g0ff2f43147e3a4547f7109578b3ca422" args="(struct nl_handle *handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nl_disable_sequence_check           </td>
          <td>(</td>
          <td class="paramtype">struct nl_handle *&nbsp;</td>
          <td class="paramname"> <em>handle</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Disable sequence number checking. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>Netlink handle.</td></tr>
  </table>
</dl>
Disables checking of sequence numbers on the netlink handle. This is required to allow messages to be processed which were not requested by a preceding request message, e.g. netlink events. 
<p>
Definition at line <a class="el" href="nl_8c-source.html#l00304">304</a> of file <a class="el" href="nl_8c-source.html">nl.c</a>.
<p>
References <a class="el" href="group__cb.html#ggba3fabad0c62db483941101e1a18d14d22448271a402b4c4a55733ef4884c038">NL_CB_CUSTOM</a>, <a class="el" href="group__cb.html#gg3f60f4515ada826d2bf16395ee722363e73e906b997f00e8911b09e0f254364d">NL_CB_SEQ_CHECK</a>, <a class="el" href="handlers_8c-source.html#l00478">nl_cb_set()</a>, and <a class="el" href="nl_8c-source.html#l00393">nl_handle_get_cb()</a>.
</div>
</div><p>
<a class="anchor" name="g6c7211051174ef2e72f92b907b2899eb"></a><!-- doxytag: member="nl.c::nl_handle_get_pid" ref="g6c7211051174ef2e72f92b907b2899eb" args="(struct nl_handle *handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pid_t nl_handle_get_pid           </td>
          <td>(</td>
          <td class="paramtype">struct nl_handle *&nbsp;</td>
          <td class="paramname"> <em>handle</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get netlink process identifier of netlink handle. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>Netlink handle. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Netlink process identifier. </dd></dl>

<p>
Definition at line <a class="el" href="nl_8c-source.html#l00322">322</a> of file <a class="el" href="nl_8c-source.html">nl.c</a>.
</div>
</div><p>
<a class="anchor" name="g22553b091b68b944b1f630035684ca10"></a><!-- doxytag: member="nl.c::nl_handle_set_pid" ref="g22553b091b68b944b1f630035684ca10" args="(struct nl_handle *handle, pid_t pid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nl_handle_set_pid           </td>
          <td>(</td>
          <td class="paramtype">struct nl_handle *&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pid_t&nbsp;</td>
          <td class="paramname"> <em>pid</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set netlink process identifier of netlink handle. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>Netlink handle. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pid</em>&nbsp;</td><td>New netlink process identifier. </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="nl_8c-source.html#l00332">332</a> of file <a class="el" href="nl_8c-source.html">nl.c</a>.
</div>
</div><p>
<a class="anchor" name="gd6077e0c736002818ae0fc27e5249a9d"></a><!-- doxytag: member="nl.c::nl_handle_get_peer_pid" ref="gd6077e0c736002818ae0fc27e5249a9d" args="(struct nl_handle *handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pid_t nl_handle_get_peer_pid           </td>
          <td>(</td>
          <td class="paramtype">struct nl_handle *&nbsp;</td>
          <td class="paramname"> <em>handle</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get netlink process identifier of peer from netlink handle. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>Netlink handle. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Netlink process identifier. </dd></dl>

<p>
Definition at line <a class="el" href="nl_8c-source.html#l00342">342</a> of file <a class="el" href="nl_8c-source.html">nl.c</a>.
</div>
</div><p>
<a class="anchor" name="g20d5d58031456e8ecccf9cdf063adc22"></a><!-- doxytag: member="nl.c::nl_handle_set_peer_pid" ref="g20d5d58031456e8ecccf9cdf063adc22" args="(struct nl_handle *handle, pid_t pid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nl_handle_set_peer_pid           </td>
          <td>(</td>
          <td class="paramtype">struct nl_handle *&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pid_t&nbsp;</td>
          <td class="paramname"> <em>pid</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set netlink process identifier of peer in netlink handle. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>Netlink handle. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pid</em>&nbsp;</td><td>New netlink process identifier. </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="nl_8c-source.html#l00352">352</a> of file <a class="el" href="nl_8c-source.html">nl.c</a>.
</div>
</div><p>
<a class="anchor" name="gee55e77a728b9d25360859f74560f0aa"></a><!-- doxytag: member="nl.c::nl_handle_get_fd" ref="gee55e77a728b9d25360859f74560f0aa" args="(struct nl_handle *handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nl_handle_get_fd           </td>
          <td>(</td>
          <td class="paramtype">struct nl_handle *&nbsp;</td>
          <td class="paramname"> <em>handle</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get file descriptor of netlink handle. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>Netlink handle. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>File descriptor of netlink socket or -1 if not connected. </dd></dl>

<p>
Definition at line <a class="el" href="nl_8c-source.html#l00362">362</a> of file <a class="el" href="nl_8c-source.html">nl.c</a>.
</div>
</div><p>
<a class="anchor" name="g5fba711956ae0c71a2639dd9bfb4c762"></a><!-- doxytag: member="nl.c::nl_handle_get_local_addr" ref="g5fba711956ae0c71a2639dd9bfb4c762" args="(struct nl_handle *handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structsockaddr__nl.html">sockaddr_nl</a>* nl_handle_get_local_addr           </td>
          <td>(</td>
          <td class="paramtype">struct nl_handle *&nbsp;</td>
          <td class="paramname"> <em>handle</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get local netlink address of netlink handle. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>Netlink handle. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Local netlink address. </dd></dl>

<p>
Definition at line <a class="el" href="nl_8c-source.html#l00372">372</a> of file <a class="el" href="nl_8c-source.html">nl.c</a>.
</div>
</div><p>
<a class="anchor" name="gefe94defe49ed2d3c6ea5f91058f6e22"></a><!-- doxytag: member="nl.c::nl_handle_get_peer_addr" ref="gefe94defe49ed2d3c6ea5f91058f6e22" args="(struct nl_handle *handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structsockaddr__nl.html">sockaddr_nl</a>* nl_handle_get_peer_addr           </td>
          <td>(</td>
          <td class="paramtype">struct nl_handle *&nbsp;</td>
          <td class="paramname"> <em>handle</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get peer netlink address of netlink handle. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>Netlink handle. </td></tr>
  </table>
</dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The peer address is undefined while the socket is unconnected. </dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Netlink address of the peer. </dd></dl>

<p>
Definition at line <a class="el" href="nl_8c-source.html#l00383">383</a> of file <a class="el" href="nl_8c-source.html">nl.c</a>.
</div>
</div><p>
<a class="anchor" name="g684f3801dbd5dc27bfa630da486a281f"></a><!-- doxytag: member="nl.c::nl_handle_get_cb" ref="g684f3801dbd5dc27bfa630da486a281f" args="(struct nl_handle *handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct nl_cb* nl_handle_get_cb           </td>
          <td>(</td>
          <td class="paramtype">struct nl_handle *&nbsp;</td>
          <td class="paramname"> <em>handle</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get callback configuration of netlink handle. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>Netlink handle. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Currently active callback configuration or NULL if not available. </dd></dl>

<p>
Definition at line <a class="el" href="nl_8c-source.html#l00393">393</a> of file <a class="el" href="nl_8c-source.html">nl.c</a>.
<p>
Referenced by <a class="el" href="cache_8c-source.html#l00391">nl_cache_pickup()</a>, <a class="el" href="nl_8c-source.html#l00304">nl_disable_sequence_check()</a>, <a class="el" href="nl_8c-source.html#l00499">nl_sendmsg()</a>, and <a class="el" href="nl_8c-source.html#l01007">nl_wait_for_ack()</a>.
</div>
</div><p>
<a class="anchor" name="g68655d7fa8bd1944bec4761c95e576e9"></a><!-- doxytag: member="nl.c::nl_connect" ref="g68655d7fa8bd1944bec4761c95e576e9" args="(struct nl_handle *handle, int protocol)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nl_connect           </td>
          <td>(</td>
          <td class="paramtype">struct nl_handle *&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>protocol</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create and connect netlink socket. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>Netlink handle. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>protocol</em>&nbsp;</td><td>Netlink protocol to use.</td></tr>
  </table>
</dl>
Creates a netlink socket using the specified protocol, binds the socket and issues a connection attempt.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success or a negative error code. </dd></dl>

<p>
Definition at line <a class="el" href="nl_8c-source.html#l00415">415</a> of file <a class="el" href="nl_8c-source.html">nl.c</a>.
<p>
References <a class="el" href="nl_8c-source.html#l00214">nl_set_buffer_size()</a>.
</div>
</div><p>
<a class="anchor" name="g25039e93db5ab64ce4345ffe14379530"></a><!-- doxytag: member="nl.c::nl_close" ref="g25039e93db5ab64ce4345ffe14379530" args="(struct nl_handle *handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nl_close           </td>
          <td>(</td>
          <td class="paramtype">struct nl_handle *&nbsp;</td>
          <td class="paramname"> <em>handle</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Close/Disconnect netlink socket. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>Netlink handle </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="nl_8c-source.html#l00456">456</a> of file <a class="el" href="nl_8c-source.html">nl.c</a>.
</div>
</div><p>
<a class="anchor" name="g53ee384f123fa3c354ad43adb6cf647d"></a><!-- doxytag: member="nl.c::nl_sendto" ref="g53ee384f123fa3c354ad43adb6cf647d" args="(struct nl_handle *handle, void *buf, size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nl_sendto           </td>
          <td>(</td>
          <td class="paramtype">struct nl_handle *&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Send raw data over netlink socket. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>Netlink handle. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>Data buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Size of data buffer. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Number of characters written on success or a negative error code. </dd></dl>

<p>
Definition at line <a class="el" href="nl_8c-source.html#l00480">480</a> of file <a class="el" href="nl_8c-source.html">nl.c</a>.
</div>
</div><p>
<a class="anchor" name="gf3dca993337ed2d60a42269eaab65585"></a><!-- doxytag: member="nl.c::nl_sendmsg" ref="gf3dca993337ed2d60a42269eaab65585" args="(struct nl_handle *handle, struct nl_msg *msg, struct msghdr *hdr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nl_sendmsg           </td>
          <td>(</td>
          <td class="paramtype">struct nl_handle *&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct nl_msg *&nbsp;</td>
          <td class="paramname"> <em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct msghdr *&nbsp;</td>
          <td class="paramname"> <em>hdr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Send netlink message with control over sendmsg() message header. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>Netlink handle. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>msg</em>&nbsp;</td><td>Netlink message to be sent. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hdr</em>&nbsp;</td><td>Sendmsg() message header. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Number of characters sent on sucess or a negative error code. </dd></dl>

<p>
Definition at line <a class="el" href="nl_8c-source.html#l00499">499</a> of file <a class="el" href="nl_8c-source.html">nl.c</a>.
<p>
References <a class="el" href="group__cb.html#gg3f60f4515ada826d2bf16395ee7223630b43ab5eccae67470bb8ed0b09e2f650">NL_CB_MSG_OUT</a>, <a class="el" href="nl_8c-source.html#l00393">nl_handle_get_cb()</a>, <a class="el" href="group__cb.html#gg0c50cb29c507b3d7e8bc7d76c74675f8406fb6f14b29e70a49bece37560278db">NL_PROCEED</a>, <a class="el" href="msg_8c-source.html#l00499">nlmsg_hdr()</a>, <a class="el" href="netlink-kernel_8h-source.html#l00053">nlmsghdr::nlmsg_len</a>, and <a class="el" href="msg_8c-source.html#l00538">nlmsg_set_src()</a>.
<p>
Referenced by <a class="el" href="nl_8c-source.html#l00534">nl_send()</a>.
</div>
</div><p>
<a class="anchor" name="g5f3fff85c39f18946100c85f09d2c41c"></a><!-- doxytag: member="nl.c::nl_send" ref="g5f3fff85c39f18946100c85f09d2c41c" args="(struct nl_handle *handle, struct nl_msg *msg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nl_send           </td>
          <td>(</td>
          <td class="paramtype">struct nl_handle *&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct nl_msg *&nbsp;</td>
          <td class="paramname"> <em>msg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Send netlink message. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>Netlink handle </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>msg</em>&nbsp;</td><td>Netlink message to be sent. </td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__nl.html#gf3dca993337ed2d60a42269eaab65585">nl_sendmsg()</a> </dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Number of characters sent on success or a negative error code. </dd></dl>

<p>
Definition at line <a class="el" href="nl_8c-source.html#l00534">534</a> of file <a class="el" href="nl_8c-source.html">nl.c</a>.
<p>
References <a class="el" href="netlink-kernel_8h-source.html#l00032">sockaddr_nl::nl_family</a>, <a class="el" href="nl_8c-source.html#l00499">nl_sendmsg()</a>, <a class="el" href="msg_8c-source.html#l00564">nlmsg_get_creds()</a>, and <a class="el" href="msg_8c-source.html#l00553">nlmsg_get_dst()</a>.
<p>
Referenced by <a class="el" href="nl_8c-source.html#l00582">nl_send_auto_complete()</a>.
</div>
</div><p>
<a class="anchor" name="g01a2aad82350f867e704d5c696438b60"></a><!-- doxytag: member="nl.c::nl_send_auto_complete" ref="g01a2aad82350f867e704d5c696438b60" args="(struct nl_handle *handle, struct nl_msg *msg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nl_send_auto_complete           </td>
          <td>(</td>
          <td class="paramtype">struct nl_handle *&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct nl_msg *&nbsp;</td>
          <td class="paramname"> <em>msg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Send netlink message and check &amp; extend header values as needed. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>Netlink handle. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>msg</em>&nbsp;</td><td>Netlink message to be sent.</td></tr>
  </table>
</dl>
Checks the netlink message <code>nlh</code> for completness and extends it as required before sending it out. Checked fields include pid, sequence nr, and flags.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__nl.html#g5f3fff85c39f18946100c85f09d2c41c">nl_send()</a> </dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Number of characters sent or a negative error code. </dd></dl>

<p>
Definition at line <a class="el" href="nl_8c-source.html#l00582">582</a> of file <a class="el" href="nl_8c-source.html">nl.c</a>.
<p>
References <a class="el" href="nl_8c-source.html#l00534">nl_send()</a>, <a class="el" href="netlink-kernel_8h-source.html#l00097">NLM_F_ACK</a>, <a class="el" href="netlink-kernel_8h-source.html#l00086">NLM_F_REQUEST</a>, <a class="el" href="netlink-kernel_8h-source.html#l00063">nlmsghdr::nlmsg_flags</a>, <a class="el" href="msg_8c-source.html#l00499">nlmsg_hdr()</a>, <a class="el" href="netlink-kernel_8h-source.html#l00073">nlmsghdr::nlmsg_pid</a>, and <a class="el" href="netlink-kernel_8h-source.html#l00068">nlmsghdr::nlmsg_seq</a>.
<p>
Referenced by <a class="el" href="lookup_8c-source.html#l00272">flnl_lookup()</a>, <a class="el" href="nl_8c-source.html#l00615">nl_send_simple()</a>, <a class="el" href="route_2addr_8c-source.html#l00740">rtnl_addr_add()</a>, <a class="el" href="route_2addr_8c-source.html#l00813">rtnl_addr_delete()</a>, <a class="el" href="class_8c-source.html#l00295">rtnl_class_add()</a>, <a class="el" href="classifier_8c-source.html#l00309">rtnl_cls_add()</a>, <a class="el" href="classifier_8c-source.html#l00355">rtnl_cls_change()</a>, <a class="el" href="classifier_8c-source.html#l00403">rtnl_cls_delete()</a>, <a class="el" href="link_8c-source.html#l00876">rtnl_link_change()</a>, <a class="el" href="neigh_8c-source.html#l00636">rtnl_neigh_add()</a>, <a class="el" href="neigh_8c-source.html#l00750">rtnl_neigh_change()</a>, <a class="el" href="neigh_8c-source.html#l00691">rtnl_neigh_delete()</a>, <a class="el" href="neightbl_8c-source.html#l00600">rtnl_neightbl_change()</a>, <a class="el" href="qdisc_8c-source.html#l00363">rtnl_qdisc_add()</a>, <a class="el" href="qdisc_8c-source.html#l00418">rtnl_qdisc_change()</a>, <a class="el" href="qdisc_8c-source.html#l00487">rtnl_qdisc_delete()</a>, <a class="el" href="rule_8c-source.html#l00566">rtnl_rule_add()</a>, and <a class="el" href="rule_8c-source.html#l00620">rtnl_rule_delete()</a>.
</div>
</div><p>
<a class="anchor" name="g73ed88a505f2d67bcf328183fe1e692a"></a><!-- doxytag: member="nl.c::nl_send_simple" ref="g73ed88a505f2d67bcf328183fe1e692a" args="(struct nl_handle *handle, int type, int flags, void *buf, size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nl_send_simple           </td>
          <td>(</td>
          <td class="paramtype">struct nl_handle *&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Send simple netlink message using <a class="el" href="group__nl.html#g01a2aad82350f867e704d5c696438b60">nl_send_auto_complete()</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>Netlink handle. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>Netlink message type. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Netlink message flags. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>Data buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Size of data buffer.</td></tr>
  </table>
</dl>
Builds a netlink message with the specified type and flags and appends the specified data as payload to the message.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__nl.html#g01a2aad82350f867e704d5c696438b60">nl_send_auto_complete()</a> </dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Number of characters sent on success or a negative error code. </dd></dl>

<p>
Definition at line <a class="el" href="nl_8c-source.html#l00615">615</a> of file <a class="el" href="nl_8c-source.html">nl.c</a>.
<p>
References <a class="el" href="nl_8c-source.html#l00582">nl_send_auto_complete()</a>, <a class="el" href="msg_8c-source.html#l00441">nlmsg_append()</a>, <a class="el" href="msg_8c-source.html#l00373">nlmsg_build()</a>, <a class="el" href="msg_8c-source.html#l00512">nlmsg_free()</a>, <a class="el" href="netlink-kernel_8h-source.html#l00053">nlmsghdr::nlmsg_len</a>, and <a class="el" href="msg_8c-source.html#l00166">nlmsg_msg_size()</a>.
<p>
Referenced by <a class="el" href="rtnl_8c-source.html#l00039">nl_rtgen_request()</a>.
</div>
</div><p>
<a class="anchor" name="g060acc8371fdb242c5ae3d5b761d28e1"></a><!-- doxytag: member="nl.c::nl_recv" ref="g060acc8371fdb242c5ae3d5b761d28e1" args="(struct nl_handle *handle, struct sockaddr_nl *nla, unsigned char **buf, struct ucred **creds)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nl_recv           </td>
          <td>(</td>
          <td class="paramtype">struct nl_handle *&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structsockaddr__nl.html">sockaddr_nl</a> *&nbsp;</td>
          <td class="paramname"> <em>nla</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char **&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct ucred **&nbsp;</td>
          <td class="paramname"> <em>creds</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Receive netlink message from netlink socket. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>Netlink handle. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nla</em>&nbsp;</td><td>Destination pointer for peer's netlink address. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>Destination pointer for message content. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>creds</em>&nbsp;</td><td>Destination pointer for credentials.</td></tr>
  </table>
</dl>
Receives a netlink message, allocates a buffer in <code>*buf</code> and stores the message content. The peer's netlink address is stored in <code>*nla</code>. The caller is responsible for freeing the buffer allocated in <code>*buf</code> if a positive value is returned. Interruped system calls are handled by repeating the read. The input buffer size is determined by peeking before the actual read is done.<p>
A non-blocking sockets causes the function to return immediately if no data is available.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Number of octets read, 0 on EOF or a negative error code. </dd></dl>

<p>
Definition at line <a class="el" href="nl_8c-source.html#l00665">665</a> of file <a class="el" href="nl_8c-source.html">nl.c</a>.
<p>
Referenced by <a class="el" href="nl_8c-source.html#l00765">nl_recvmsgs()</a>.
</div>
</div><p>
<a class="anchor" name="g1bb066e1772b89f79fe1d76a4ef243a6"></a><!-- doxytag: member="nl.c::nl_recvmsgs" ref="g1bb066e1772b89f79fe1d76a4ef243a6" args="(struct nl_handle *handle, struct nl_cb *cb)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nl_recvmsgs           </td>
          <td>(</td>
          <td class="paramtype">struct nl_handle *&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct nl_cb *&nbsp;</td>
          <td class="paramname"> <em>cb</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Receive a set of messages from a netlink socket. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>netlink handle </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cb</em>&nbsp;</td><td>set of callbacks to control the behaviour.</td></tr>
  </table>
</dl>
Repeatedly calls <a class="el" href="group__nl.html#g060acc8371fdb242c5ae3d5b761d28e1">nl_recv()</a> and parses the messages as netlink messages. Stops reading if one of the callbacks returns NL_EXIT or nl_recv returns either 0 or a negative error code.<p>
A non-blocking sockets causes the function to return immediately if no data is available.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success or a negative error code from <a class="el" href="group__nl.html#g060acc8371fdb242c5ae3d5b761d28e1">nl_recv()</a>. </dd></dl>

<p>
Definition at line <a class="el" href="nl_8c-source.html#l00765">765</a> of file <a class="el" href="nl_8c-source.html">nl.c</a>.
<p>
References <a class="el" href="group__cb.html#gg3f60f4515ada826d2bf16395ee7223638295b387c07bd076ccdee45b555f1134">NL_CB_ACK</a>, <a class="el" href="group__cb.html#gg3f60f4515ada826d2bf16395ee722363044400d11ee451b692333a0d95cf3d32">NL_CB_FINISH</a>, <a class="el" href="group__cb.html#gg3f60f4515ada826d2bf16395ee722363f5b5448bf122561db88d510e5d153a8a">NL_CB_INVALID</a>, <a class="el" href="group__cb.html#gg3f60f4515ada826d2bf16395ee722363160d69995bab2c325bd25d7ee2d5292d">NL_CB_MSG_IN</a>, <a class="el" href="group__cb.html#gg3f60f4515ada826d2bf16395ee72236325c8376dc758b16bcaeb76c329719dae">NL_CB_OVERRUN</a>, <a class="el" href="group__cb.html#gg3f60f4515ada826d2bf16395ee722363f2930b7775d1444c359cd11d7ce2cd02">NL_CB_SEND_ACK</a>, <a class="el" href="group__cb.html#gg3f60f4515ada826d2bf16395ee722363e73e906b997f00e8911b09e0f254364d">NL_CB_SEQ_CHECK</a>, <a class="el" href="group__cb.html#gg3f60f4515ada826d2bf16395ee722363034ec83d5ba891deb3d3e54f9e15d3a0">NL_CB_SKIPPED</a>, <a class="el" href="group__cb.html#gg3f60f4515ada826d2bf16395ee7223636e1f371d16186a460f25ea9bb1306c47">NL_CB_VALID</a>, <a class="el" href="group__cb.html#gg0c50cb29c507b3d7e8bc7d76c74675f840b828a3344251a54a27188ff79de1d9">NL_EXIT</a>, <a class="el" href="nl_8c-source.html#l00665">nl_recv()</a>, <a class="el" href="group__cb.html#gg0c50cb29c507b3d7e8bc7d76c74675f8f77d78aac004c6d4bee57741d3a295ae">NL_SKIP</a>, <a class="el" href="netlink-kernel_8h-source.html#l00097">NLM_F_ACK</a>, <a class="el" href="msg_8c-source.html#l00402">nlmsg_convert()</a>, <a class="el" href="msg_8c-source.html#l00200">nlmsg_data()</a>, <a class="el" href="netlink-kernel_8h-source.html#l00189">NLMSG_DONE</a>, <a class="el" href="netlink-kernel_8h-source.html#l00184">NLMSG_ERROR</a>, <a class="el" href="msg_8c-source.html#l00512">nlmsg_free()</a>, <a class="el" href="msg_8c-source.html#l00166">nlmsg_msg_size()</a>, <a class="el" href="msg_8c-source.html#l00274">nlmsg_next()</a>, <a class="el" href="netlink-kernel_8h-source.html#l00177">NLMSG_NOOP</a>, <a class="el" href="msg_8c-source.html#l00259">nlmsg_ok()</a>, <a class="el" href="netlink-kernel_8h-source.html#l00194">NLMSG_OVERRUN</a>, <a class="el" href="msg_8c-source.html#l00558">nlmsg_set_creds()</a>, <a class="el" href="msg_8c-source.html#l00528">nlmsg_set_proto()</a>, and <a class="el" href="msg_8c-source.html#l00538">nlmsg_set_src()</a>.
<p>
Referenced by <a class="el" href="cache_8c-source.html#l00391">nl_cache_pickup()</a>, <a class="el" href="nl_8c-source.html#l00986">nl_recvmsgs_def()</a>, and <a class="el" href="nl_8c-source.html#l01007">nl_wait_for_ack()</a>.
</div>
</div><p>
<a class="anchor" name="g4e2c8db16c58634c08fd92f8d52a6873"></a><!-- doxytag: member="nl.c::nl_recvmsgs_def" ref="g4e2c8db16c58634c08fd92f8d52a6873" args="(struct nl_handle *handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nl_recvmsgs_def           </td>
          <td>(</td>
          <td class="paramtype">struct nl_handle *&nbsp;</td>
          <td class="paramname"> <em>handle</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Receive a set of message from a netlink socket using handlers in nl_handle. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>netlink handle</td></tr>
  </table>
</dl>
Calls <a class="el" href="group__nl.html#g1bb066e1772b89f79fe1d76a4ef243a6">nl_recvmsgs()</a> with the handlers configured in the netlink handle. 
<p>
Definition at line <a class="el" href="nl_8c-source.html#l00986">986</a> of file <a class="el" href="nl_8c-source.html">nl.c</a>.
<p>
References <a class="el" href="nl_8c-source.html#l00765">nl_recvmsgs()</a>.
</div>
</div><p>
<a class="anchor" name="ga65fec588e0a0a2de1881fb8366ccd79"></a><!-- doxytag: member="nl.c::nl_wait_for_ack" ref="ga65fec588e0a0a2de1881fb8366ccd79" args="(struct nl_handle *handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nl_wait_for_ack           </td>
          <td>(</td>
          <td class="paramtype">struct nl_handle *&nbsp;</td>
          <td class="paramname"> <em>handle</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Wait for ACK. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>netlink handle </td></tr>
  </table>
</dl>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd>The netlink socket must be in blocking state.</dd></dl>
Waits until an ACK is received for the latest not yet acknowledged netlink message. 
<p>
Definition at line <a class="el" href="nl_8c-source.html#l01007">1007</a> of file <a class="el" href="nl_8c-source.html">nl.c</a>.
<p>
References <a class="el" href="group__cb.html#gg3f60f4515ada826d2bf16395ee7223638295b387c07bd076ccdee45b555f1134">NL_CB_ACK</a>, <a class="el" href="handlers_8c-source.html#l00448">nl_cb_clone()</a>, <a class="el" href="group__cb.html#ggba3fabad0c62db483941101e1a18d14d22448271a402b4c4a55733ef4884c038">NL_CB_CUSTOM</a>, <a class="el" href="handlers_8c-source.html#l00437">nl_cb_destroy()</a>, <a class="el" href="handlers_8c-source.html#l00478">nl_cb_set()</a>, <a class="el" href="nl_8c-source.html#l00393">nl_handle_get_cb()</a>, and <a class="el" href="nl_8c-source.html#l00765">nl_recvmsgs()</a>.
<p>
Referenced by <a class="el" href="route_2addr_8c-source.html#l00740">rtnl_addr_add()</a>, <a class="el" href="route_2addr_8c-source.html#l00813">rtnl_addr_delete()</a>, <a class="el" href="class_8c-source.html#l00295">rtnl_class_add()</a>, <a class="el" href="classifier_8c-source.html#l00309">rtnl_cls_add()</a>, <a class="el" href="classifier_8c-source.html#l00355">rtnl_cls_change()</a>, <a class="el" href="classifier_8c-source.html#l00403">rtnl_cls_delete()</a>, <a class="el" href="link_8c-source.html#l00876">rtnl_link_change()</a>, <a class="el" href="neigh_8c-source.html#l00636">rtnl_neigh_add()</a>, <a class="el" href="neigh_8c-source.html#l00750">rtnl_neigh_change()</a>, <a class="el" href="neigh_8c-source.html#l00691">rtnl_neigh_delete()</a>, <a class="el" href="neightbl_8c-source.html#l00600">rtnl_neightbl_change()</a>, <a class="el" href="qdisc_8c-source.html#l00363">rtnl_qdisc_add()</a>, <a class="el" href="qdisc_8c-source.html#l00418">rtnl_qdisc_change()</a>, <a class="el" href="qdisc_8c-source.html#l00487">rtnl_qdisc_delete()</a>, <a class="el" href="rule_8c-source.html#l00566">rtnl_rule_add()</a>, and <a class="el" href="rule_8c-source.html#l00620">rtnl_rule_delete()</a>.
</div>
</div><p>
<a class="anchor" name="g2012d14c1247975ca68fd8070e18cb3d"></a><!-- doxytag: member="nl.c::nl_nlfamily2str" ref="g2012d14c1247975ca68fd8070e18cb3d" args="(int family, char *buf, size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* nl_nlfamily2str           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>family</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convert netlink family to character string. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>family</em>&nbsp;</td><td>Netlink family. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>Destination buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Size of destination buffer.</td></tr>
  </table>
</dl>
Converts a netlink family to a character string and stores it in the specified destination buffer.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The destination buffer or the family encoded in hexidecimal form if no match was found. </dd></dl>

<p>
Definition at line <a class="el" href="nl_8c-source.html#l01059">1059</a> of file <a class="el" href="nl_8c-source.html">nl.c</a>.
</div>
</div><p>
<a class="anchor" name="g864f4b90d7777ec2b9d978a0db9404a7"></a><!-- doxytag: member="nl.c::nl_str2nlfamily" ref="g864f4b90d7777ec2b9d978a0db9404a7" args="(const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nl_str2nlfamily           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convert character string to netlink family. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Name of netlink family.</td></tr>
  </table>
</dl>
Converts the provided character string specifying a netlink family to the corresponding numeric value.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Numeric netlink family or a negative value if no match was found. </dd></dl>

<p>
Definition at line <a class="el" href="nl_8c-source.html#l01074">1074</a> of file <a class="el" href="nl_8c-source.html">nl.c</a>.
</div>
</div><p>
<hr size="1"><address style="align: right;"><small>Generated on Fri Mar 16 11:21:34 2007 for libnl by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1 </small></address>
</body>
</html>

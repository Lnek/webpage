<!DOCTYPE html>
<html lang="zh-cn">
<head>
<meta charset="utf-8"/>
<title>makefile 速成 - welkinwalker - 博客园</title>
<link type="text/css" rel="stylesheet" href="/bundles/blog-common.css?v=gdNkSiQMyBMkpTeO1ex9qW-60UbMszQItnCUpBAT3LQ1"/>
<link id="MainCss" type="text/css" rel="stylesheet" href="http://common.cnblogs.com/Skins/Valentine/style.css?id=20140415"/>
<link title="RSS" type="application/rss+xml" rel="alternate" href="http://www.cnblogs.com/welkinwalker/rss"/>
<link title="RSD" type="application/rsd+xml" rel="EditURI" href="http://www.cnblogs.com/welkinwalker/rsd.xml"/>
<link type="application/wlwmanifest+xml" rel="wlwmanifest" href="http://www.cnblogs.com/welkinwalker/wlwmanifest.xml"/>
<script src="http://common.cnblogs.com/script/jquery.js" type="text/javascript"></script>  
<script type="text/javascript">var currentBlogApp = 'welkinwalker', cb_enable_mathjax=false;</script>
<script src="/bundles/blog-common.js?v=iPflrWoIo72rhU3cYfJbnUvK6QAYRd4QPEVSKbmA4gw1" type="text/javascript"></script>
</head>
<body>
<a name="top"></a>

<!--done-->
<TABLE cellpadding="0" cellspacing="0" border="0" align="center" width="100%">
<TR>
	<TD width=184 background="/skins/Valentine/images/banner1.gif"></TD>
	<TD background="/skins/Valentine/images/banner.gif">
<!--done-->
<div class="header">
	<div class="headerText">
		<a id="Header1_HeaderTitle" class="headermaintitle" href="http://www.cnblogs.com/welkinwalker/">渔舟唱晚的天空</a><br>
		<span style="font-size:12px;color:#4371A6;padding-left:20;">——welkinwalker的遐想</span>
	</div>
</div>
</TD>
	<TD width=295 background="/skins/Valentine/images/banner2.gif"></TD>
</TR>
</TABLE>
<div id="mylinks">
<!--done-->
<a id="MyLinks1_HomeLink" class="menu" href="http://www.cnblogs.com/">博客园</a>&nbsp;&nbsp;&nbsp;<a id="MyLinks1_MyHomeLink" class="mainmenu" href="http://www.cnblogs.com/welkinwalker/">首页</a>&nbsp;&nbsp;&nbsp;<a id="MyLinks1_NewPostLink" class="mainmenu" rel="nofollow" href="http://i.cnblogs.com/EditPosts.aspx?opt=1">新随笔</a>&nbsp;&nbsp;&nbsp;<a id="MyLinks1_NewArticleLink" class="mainmenu" href="/EnterMyBlog.aspx?NewArticle=1">新文章</a>&nbsp;&nbsp;&nbsp;<a id="MyLinks1_ContactLink" accesskey="9" class="mainmenu" rel="nofollow" href="http://space.cnblogs.com/msg/send/welkinwalker">联系</a>&nbsp;&nbsp;&nbsp;<a id="MyLinks1_Syndication" class="mainmenu" href="http://www.cnblogs.com/welkinwalker/rss">订阅</a><a id="MyLinks1_XMLLink" href="http://www.cnblogs.com/welkinwalker/rss"><img src="http://www.cnblogs.com/images/xml.gif" alt="订阅" /></a>&nbsp;&nbsp;&nbsp;<a id="MyLinks1_Admin" class="menu" rel="nofollow" href="http://i.cnblogs.com/">管理</a>
</div>
<div id="mytopmenu">
	
		<DIV id="mystats">
			
<!--done-->
<div class="blogStats">
posts - 111,comments - 13,trackbacks - 0

</div></DIV>
	
</div>
<div id="leftcontent">
	
		<DIV id="leftcontentcontainer">
			<div id="blog-calendar" style="display:none"></div><script type="text/javascript">loadBlogDefaultCalendar();</script><br>
			
<!--done-->
<div class="newsItem">
	<div id="blog-news"></div><script type="text/javascript">loadBlogNews();</script>
</div>

			<div id="blog-sidecolumn"></div><script type="text/javascript">loadBlogSideColumn();</script></DIV>
	
</div>
<div id="centercontent">
	

<!--done-->
<div class = "post">
	<div class = "postTitle">
		<a id="cb_post_title_url" class="postTitle2" href="http://www.cnblogs.com/welkinwalker/archive/2011/09/06/2168454.html">makefile 速成</a>
	</div>
	<div id="cnblogs_post_body"><div><p align="left" style="text-align:left"><strong><span style="font-family:宋体;color:#1F497D">分享一篇前短时间总结的makefile速成，教你一天搞定makefile，略加实践掌握其最核心部分。</span></strong></p>  <p align="left" style="text-align:left"><span style="font-family:宋体">可以从下面的几个维度来学习和理解makefile：</span></p>  <ul type="disc">  <li style="      text-align:left;"><span style="font-family:宋体">规则</span></li>  <li style="      text-align:left;"><span style="font-family:宋体">变量</span></li>  <li style="      text-align:left;"><span style="font-family:宋体">函数</span></li>  <li style="      text-align:left;"><span style="font-family:宋体">命令</span></li>  <li style="      text-align:left;"><span style="font-family:宋体">make</span><span style="font-family:      宋体">的命令选项</span></li>  <li style="      text-align:left;"><span style="font-family:宋体">一个大型项目的makefile例子</span></li>  <li style="      text-align:left;"><span style="font-family:宋体">make </span><span style="font-family:      宋体">&#8211;p的输出概览</span></li> </ul>  <p align="left" style="text-align:left;text-indent:18.0pt"><span style="font-family:宋体">在正式介绍makefile的以上四个方面之前，首先一句话概括一下makefile是什么：makefile是用来描述文件依赖关系，并告诉make命令如何根据这种依赖关系，调用shell完成目标文件建立的文件。</span></p>  <p align="left" style="text-align:left;text-indent:18.0pt"><span style="font-family: 宋体">makefile</span><span style="font-family:宋体">的执行时通过两步来完成的，第一步是扫描文件中的依赖关系，并藉此建立依赖关系树，然后从最底层想上来执行。</span></p>  <p style="margin-left:0cm;text-indent:0cm"><span><span>1.<span style="font:7.0pt &quot;Times New Roman&quot;"> </span></span></span>规则（rule）</p>  <p align="left" style="text-align:left; text-indent:18.0pt"><span style="font-family:宋体">Makefile</span><span style="font-family:宋体">从本质上说就是描述项目中文件依赖关系的文件。这种依赖关系的描述就是规则。Makefile的编写中的一切都是围绕规则来展开的，上面提到的四个方面：规则、变量、函数、命令都是为了规则能够方便快捷的发挥作用才引入的。</span></p>  <p align="left" style="text-align:left;text-indent:18.0pt"><span style="font-family:宋体">一个简单规则可以表述为：</span></p>  <p align="left" style="text-align:left"><span style="font-family: 宋体">目标文件：依赖文件（不同文件以空格分隔）</span></p>  <p align="left" style="margin-bottom:12.0pt;text-align:left"><span style="font-family:宋体">&lt;tab&gt;</span><span style="font-family: 宋体">得到目标文件需要的<strong>命令</strong></span></p>  <p align="left" style="text-align:left"><span style="font-family: 宋体">规则的常见种类有：</span></p>  <p align="left" style="margin-left:21.0pt;text-align:left; text-indent:-21.0pt;"><span style="font-family:Wingdings;">l&nbsp;</span><strong><span style="font-family:宋体">Explicit Rule</span></strong><span style="font-family:宋体">最简单的rule，明确指出了目标和依赖，以及如何有依赖得到目标。举例：</span></p>  <p align="left" style="margin-left:21.0pt;text-align:left"><span style="font-family:宋体">Hello.o:hello.cpp</span></p>  <p align="left" style="margin-left:21.0pt;text-align:left;text-indent:21.0pt"><span style="font-family: 宋体">g++ -c hello.cpp</span></p>  <p align="left" style="margin-left:21.0pt;text-align:left; text-indent:-21.0pt;"><span style="font-family:Wingdings;">l&nbsp;</span><strong><span style="font-family:宋体">Pattern Rule</span></strong><span style="font-family:宋体">使用了wildcard（通配符）的规则。makefile中的通配符是百分号%，相当于bash中的*，在描述规则的时候使用的都是%。makefile中也可以看到通配符*，这个一般是出现在命令之中，命令是要放到shell中运行的，所以要使用*作为通配符。举例：</span></p>  <p align="left" style="margin-left:21.0pt;text-align:left"><span style="font-family:宋体">prog:*.c</span></p>  <p align="left" style="margin-left:21.0pt;text-align:left"><span style="font-family:宋体">&nbsp;&nbsp;&nbsp; g++ -o prog $^</span></p>  <p align="left" style="margin-left:21.0pt;text-align:left; text-indent:-21.0pt;"><span style="font-family:Wingdings;">l&nbsp;</span><strong><span style="font-family:宋体">Suffix Rule</span></strong> <span style="font-family:宋体">顾名思义，是只使用后缀来描述的rule，描述的时候不使用pattern，举例：</span></p>  <p align="left" style="margin-left:21.0pt;text-align:left"><span style="font-family:宋体">.c.o:</span></p>  <p align="left" style="margin-left:21.0pt;text-align:left"><span style="font-family:宋体">&nbsp;&nbsp;&nbsp; $(COMPILE.C) $(OUTPUT_OPTION) $&lt;</span></p>  <p align="left" style="margin-left:21.0pt;text-align:left"><span style="font-family:宋体">这个<span>suffix rule</span>的作用和下面这个pattern rule的作用是完全一样的。区别仅在于描述依赖的时候，一个把目标放在后，一个把目标放在前面。</span></p>  <p align="left" style="margin-left:21.0pt;text-align:left"><span style="font-family:宋体">%.o:%.c</span></p>  <p align="left" style="margin-left:21.0pt;text-align:left"><span style="font-family:宋体">&nbsp;&nbsp;&nbsp; $(COMPILE.C) $(OUTPUT_OPTION) $&lt;</span></p>  <p align="left" style="margin-left:21.0pt;text-align:left; text-indent:-21.0pt;"><span style="font-family:Wingdings;">l&nbsp;</span><strong><span style="font-family:宋体">Implicit Rule</span></strong><span style="font-family:宋体">就是看不到的rule，这些rule是make的内置rule。makefile有众多的build-in rule，这些规则为我们编写makefile带来了很大的便利。它们可以通过make &#8211;p 来查看（在&#8220;<span># Implicit Rules </span>&#8220;部分）。另外内置的规则里面还有大量的后缀规则，由于这些后缀规则在makefile中也不能直接看到，所以也可以叫做implicit rule。</span></p>  <p align="left" style="text-align:left;text-indent:18.0pt">&nbsp;</p>  <p align="left" style="text-align:left;text-indent:18.0pt"><span style="font-family:宋体">上面说的rule目标文件都是实实在在的文件，还有一种目标，它不代表文件，叫做phony target（伪目标）。<strong>伪目标总是未更新的</strong>。最常用的就是clean这个phony target，他声明为：</span></p>  <p align="left" style="text-align:left"><span style="font-family:宋体">.PHONY: clean</span></p>  <p align="left" style="text-align:left"><span style="font-family:宋体">clean:</span></p>  <p align="left" style="text-align:left"><span style="font-family:宋体">&nbsp;&nbsp;&nbsp; ls;who;rm *.cpp</span></p>  <p align="left" style="text-align:left"><span style="font-family:宋体">&nbsp;&nbsp;&nbsp; </span><span style="font-family:宋体">伪目标可以帮用来帮我们测试我们的makefile，当我们想测试一段Makefile是不是正确的时候，可以把要执行的命令放到伪目标（比如伪目标test）的下面，然后执行make test就可以查看执行结果了。</span></p>  <p style="margin-left:0cm;text-indent:0cm"><span><span>2.<span style="font:7.0pt &quot;Times New Roman&quot;"> </span></span></span>变量</p>  <p style="margin-left:0cm;text-indent:0cm">自动变量</p>  <p align="left" style="text-align:left;text-indent:18.0pt"><span style="font-family:宋体">刚刚在介绍规则的时候用到了$&lt;，这东西是什么呢？他是makefile中的automatic variable。这中变量是Makefile特有的变量，他是在股则的命令中自动得到的，不同规则中执行命令时使用相同的自动变量得到的结果不同，正是因为这个原因，所以叫做<strong>自动变量</strong>。下面列出最常用的自动变量：</span></p>  <p align="left" style="margin-left:21.0pt;text-align:left; text-indent:-21.0pt;"><span style="font-family:Wingdings;">l&nbsp;</span><span style="font-family:宋体">$@&nbsp; </span><span style="font-family: 宋体">规则的目标</span></p>  <p align="left" style="margin-left:21.0pt;text-align:left; text-indent:-21.0pt;"><span style="font-family:Wingdings;">l&nbsp;</span><span style="font-family:宋体">$%&nbsp; </span><span style="font-family: 宋体">档案文件成员（archive member）结构中的文件名元素</span></p>  <p align="left" style="margin-left:21.0pt;text-align:left; text-indent:-21.0pt;"><span style="font-family:Wingdings;">l&nbsp;</span><span style="font-family:宋体">$&lt;&nbsp; </span><span style="font-family: 宋体">第一个依赖文件名</span></p>  <p align="left" style="margin-left:21.0pt;text-align:left; text-indent:-21.0pt;"><span style="font-family:Wingdings;">l&nbsp;</span><span style="font-family:宋体">$^&nbsp; </span><span style="font-family: 宋体">所有的依赖文件名（已经消重），以空格分隔</span></p>  <p align="left" style="margin-left:21.0pt;text-align:left; text-indent:-21.0pt;"><span style="font-family:Wingdings;">l&nbsp;</span><span style="font-family:宋体">$+&nbsp; </span><span style="font-family: 宋体">所有的依赖文件名（未经消重），以空格分隔</span></p>  <p align="left" style="margin-left:21.0pt;text-align:left; text-indent:-21.0pt;"><span style="font-family:Wingdings;">l&nbsp;</span><span style="font-family:宋体">$*&nbsp; </span><span style="font-family: 宋体">所有除掉后缀的依赖文件名，以空格分隔，仅适用于模式规则。注：文件名包含stem和suffix，去掉suffix就剩下了stem。比如hello.cpp的stem是hello，suffix就是cpp。</span></p>  <p align="left" style="margin-left:21.0pt;text-align:left; text-indent:-21.0pt;"><span style="font-family:Wingdings;">l&nbsp;</span><span style="font-family:宋体">$?&nbsp; </span><span style="font-family: 宋体">比目标文件新的依赖文件。</span></p>  <p style="margin-left:0cm;text-indent:0cm">vpath和VPATH变量</p>  <p align="left" style="text-align:left"><span style="font-family:宋体">&nbsp;&nbsp;&nbsp; vpath</span><span style="font-family: 宋体">用来告诉make命令到什么地方去寻找文件。如：</span></p>  <p align="left" style="text-align:left"><span style="font-family:宋体">&nbsp;&nbsp;&nbsp; VPATH:src</span></p>  <p align="left" style="text-align:left"><span style="font-family:宋体">&nbsp;&nbsp;&nbsp; </span><span style="font-family:宋体">也可以用下面的形式，告诉make命令到指定的文件去查找对应类型的文件：</span></p>  <p align="left" style="margin-left:21.0pt;text-align:left"><span style="font-family:宋体">vpath %.h $(include_dirs)</span></p>  <p align="left" style="margin-left:21.0pt;text-align:left"><span style="font-family:宋体">vpath %.a $(lib_dir) $(extra_lib_dirs)</span></p>  <p style="margin-left:0cm;text-indent:0cm">变量基本知识</p>  <p align="left" style="text-align:left;text-indent:21.0pt"><span style="font-family:宋体">和bash中变量赋值的情况不同，makefile里面的变量使用是$()方式的。虽然使用${}也可以，但这种方式并不常见。在使用$()来引用变量时，如果变量的长度为1，则可以省略括号，否则不能。如$arg，在makefile中$arg并没有被识别为一个变量，而是变量$a和字母rg。上面说到的自动变量$^ $&lt;都是这种情况。</span></p>  <p align="left" style="text-align:left;text-indent:21.0pt"><span style="font-family:宋体">另外，要特别注意的是makefile中使用的变量和bash中的变量不是一个体系，bash中的变量不能在makefile中使用。且makefile有自己的内置变量。如CURDIR，代表当前的目录，SHELL，代表用来执行命令使用的shell。这些变量可以再make &#8211;<span>p </span>的# Variables中找到，表示为:</span> <span style="font-family:宋体"># default</span><span style="font-family:宋体">。</span></p>  <p style="margin-left:0cm;text-indent:0cm">变量的展开和赋值</p>  <p style="margin-left:21.0pt">makefile<span style="font-family:宋体">中的</span>=<span style="font-family:宋体">并不立即赋值而是要延迟到是使用变量的时候。对于下面的</span>makefile<span style="font-family:宋体">，运行</span>make 5.o<span style="font-family:宋体">，</span> </p>  <p style="margin-left:21.0pt"><span style="font-family:宋体"><img src="http://images.cnblogs.com/cnblogs_com/welkinwalker/1.JPG" border="0" alt="" width="149" height="78" />结果是：<img src="http://images.cnblogs.com/cnblogs_com/welkinwalker/2.JPG" width="57" height="24" alt="" /></span></p>  <p><span style="font-family:宋体">而，如果写成下面的形式：</span></p>  <p><span>&nbsp; &nbsp; &nbsp;&nbsp;<img src="http://images.cnblogs.com/cnblogs_com/welkinwalker/3.JPG" width="149" height="82" alt="" /></span><span style="font-family:宋体">结果就变成：<img src="http://images.cnblogs.com/cnblogs_com/welkinwalker/4.JPG" width="54" height="23" alt="" /></span></p>  <p><span style="font-family:宋体">除了上面的两个赋值符号，还有两种符号是：</span></p>  <p style="margin-left:42.0pt;text-indent:-21.0pt;"><span style="font-family:Wingdings;">l&nbsp;</span>?=&nbsp;&nbsp;&nbsp;&nbsp; <span style="font-family:宋体">在变量不存在的情况下进行赋值。咽喉扩展</span></p>  <p style="margin-left:42.0pt;text-indent:-21.0pt;"><span style="font-family:Wingdings;">l&nbsp;</span><span>+=&nbsp;&nbsp;&nbsp;&nbsp; append operator</span><span style="font-family:宋体">，作用和</span>C<span style="font-family:宋体">语言中相同。如果左边部分已经被定义则进行&#8220;立即扩展&#8221;，否则延后扩展</span></p>  <p>&nbsp;</p>  <p>C/C++<span style="font-family:宋体">编译过程中用到的内置变量（</span>make &#8211;p<span style="font-family:宋体">可以看到）：</span></p>  <p align="center" style="text-align:center"><img src="http://images.cnblogs.com/cnblogs_com/welkinwalker/5.JPG" width="475" height="305" alt="" /><br /></p>  <p style="margin-left:0cm;text-indent:0cm">宏</p>  <p style="text-indent:21.2pt"><span style="font-family:宋体">变量适合用来存储单行形式的值，可是对于多行形式的值，例如命令脚本，如果我们想在不同的地方执行它，该怎办？方法就是使用宏。宏是封装的命令序列。他可以内置换行符。</span></p>  <p style="margin-left:21.0pt"><span style="font-family:宋体">用下面的方式定义宏：</span></p>  <p style="margin-left:21.0pt">define <em><span style="font-size:14.0pt">create-jar</span></em></p>  <p style="margin-left:21.0pt"><span><span>&nbsp;@echo Creating <a class="smarterwiki-linkify" href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#36;&#64;&#46;&#46;&#46;">$@...</a></span></span></p>  <p style="margin-left:21.0pt"><span>&nbsp;$(RM) $(TMP_JAR_DIR)</span></p>  <p style="margin-left:21.0pt"><span>&nbsp;$(MKDIR) $(TMP_JAR_DIR)</span></p>  <p style="margin-left:21.0pt"><span>&nbsp;$(CP) -r $^ $(TMP_JAR_DIR)</span></p>  <p style="margin-left:21.0pt"><span>&nbsp;cd $(TMP_JAR_DIR) &amp;&amp; $(JAR) $(JARFLAGS) $@ .</span></p>  <p style="margin-left:21.0pt"><span>&nbsp;$(JAR) -ufm $@ $(MANIFEST)</span></p>  <p style="margin-left:21.0pt"><span>&nbsp;$(RM) $(TMP_JAR_DIR)</span></p>  <p style="margin-left:21.0pt">endef</p>  <p style="margin-left:21.0pt"><span style="font-family:宋体">使用宏和使用变量的方式相同，如下：</span></p>  <p style="margin-left:21.0pt"><span>$(UI_JAR): $(UI_CLASSES)</span></p>  <p style="margin-left:21.0pt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $(</span><em><span style="font-size:14.0pt">create-jar)</span></em></p>  <p style="margin-left:0cm;text-indent:0cm;"><span><span>3.<span style="font:7.0pt &quot;Times New Roman&quot;"> </span></span></span>函数</p>  <p style="margin-left:21.0pt"><span style="font-family:宋体">函数可以分为字符串函数、文件名函数、流程控制函数，用户还可以自定应函数。</span></p>  <p style="margin-left:21.0pt"><span style="font-family:宋体">函数调用形式为：</span></p>  <p style="margin-left:21.0pt"><span>$(function-name arg<sub>1</sub>[, arg<sub>n</sub>])</span></p>  <p style="margin-left:21.0pt"><span style="font-family:宋体">注意：</span></p>  <p style="margin-left:42.0pt;text-indent:-21.0pt;"><span style="font-family:Wingdings;">l&nbsp;</span><span style="font-family:宋体">函数调用使用</span>$()<span style="font-family:宋体">括起来</span></p>  <p style="margin-left:42.0pt;text-indent:-21.0pt;"><span style="font-family:Wingdings;">l&nbsp;</span>$(<span style="font-family:宋体">后面直接跟函数名称</span></p>  <p style="margin-left:42.0pt;text-indent:-21.0pt;"><span style="font-family:Wingdings;">l&nbsp;</span><span style="font-family:宋体">函数名和第一个参数之间用空格，后面的参数之间使用逗号间隔</span></p>  <p style="margin-left:21.0pt"><span style="font-family:宋体">例如：</span></p>  <p style="margin-left:21.0pt"><span>objects = $(subst .cpp,.o,$(sources))</span></p>  <p style="margin-left:21.0pt"><span style="font-family:宋体">调用函数吧</span>$(sources)<span style="font-family:宋体">中的</span>.cpp<span style="font-family:宋体">替换成</span>.o<span style="font-family:宋体">。</span></p>  <p style="margin-left:21.0pt"><span style="font-family:宋体">常用函数有：</span></p>  <p style="margin-left:21.0pt"><img src="http://images.cnblogs.com/cnblogs_com/welkinwalker/6.JPG" width="368" height="465" alt="" /><br /></p>  <p style="margin-left:0cm;text-indent:0cm;"><span><span>4.<span style="font:7.0pt &quot;Times New Roman&quot;"> </span></span></span>命令</p>  <p style="margin-left:42.0pt;text-indent:-21.0pt;"><span style="font-family:Wingdings;">&#216;&nbsp;</span><span style="font-family:宋体">必须讲明，</span><strong>makefile</strong><strong><span style="font-family:宋体">的命令是要调用</span>shell</strong><strong><span style="font-family:宋体">来运行的</span></strong><span style="font-family:宋体">，而到底是使用的哪个</span>shell<span style="font-family:宋体">取决于</span>makefile<span style="font-family:宋体">中</span>SHELL<span style="font-family:宋体">变量的设置，默认为</span>/bin/sh<span style="font-family:宋体">就是</span>bash<span style="font-family:宋体">。</span></p>  <p style="margin-left:42.0pt;text-indent:-21.0pt;"><span style="font-family:Wingdings;">&#216;&nbsp;</span><strong><span style="font-family:宋体">在</span>makefile</strong><strong><span style="font-family:宋体">中使用</span>bash</strong><strong><span style="font-family:宋体">的变量。</span></strong>makefile<span style="font-family:宋体">中使用</span>$()<span style="font-family:宋体">引用的是</span>makefile<span style="font-family:宋体">内的变量，如果想使用</span>bash<span style="font-family:宋体">环境的变量要使用双美元引用</span>$$<span style="font-family:宋体">，使用单个</span>$<span style="font-family:宋体">引用的变量全部被解释为</span>makefile<span style="font-family:宋体">的变量。以此类推，如果要想试图用</span>bash<span style="font-family:宋体">中的进程号码就要使用四个</span>$<span style="font-family:宋体">，即：</span>$$$$<span style="font-family:宋体">。</span><strong></strong></p>  <p style="margin-left:42.0pt;text-indent:-21.0pt;"><span style="font-family:Wingdings;">&#216;&nbsp;</span><span style="font-family:宋体">另外，值得强调的一点是：</span><strong>makefile</strong><strong><span style="font-family:宋体">是一次发送一行命令，每发送一次命令，就会启动一个</span>subshell</strong><strong><span style="font-family:宋体">来运行</span></strong><span style="font-family:宋体">。这意味着命令之间不能共享变量，而且</span>bash<span style="font-family:宋体">中可以使用的</span>for<span style="font-family:宋体">和</span>while<span style="font-family:宋体">，在这里面也不能换行，因为每行会被单独的发送给</span>bash<span style="font-family:宋体">来执行。要解决这个问题，要么使用</span>makefile<span style="font-family:宋体">中的换行符</span>&#8221;\&#8221;<span style="font-family:宋体">，要么写成单行的形式。如：</span></p>  <p style="text-indent:21.0pt"><span style="font-family:宋体">使用换行符：</span></p>  <p style="text-indent:21.0pt"><img src="http://images.cnblogs.com/cnblogs_com/welkinwalker/7.JPG" width="465" height="135" alt="" /><br /></p>  <p style="text-indent:21.0pt"><span style="font-family:宋体">写成单行：<img src="http://images.cnblogs.com/cnblogs_com/welkinwalker/8.JPG" width="314" height="16" alt="" /></span></p>  <p style="text-indent:21.0pt"><span style="font-family:宋体">再如：<img src="http://images.cnblogs.com/cnblogs_com/welkinwalker/9.JPG" width="441" height="19" alt="" /></span></p>  <p style="text-indent:21.0pt">$$n<span style="font-family:宋体">是用来引用</span>bash<span style="font-family:宋体">环境中的变量</span>n<span style="font-family:宋体">的，上面第二条有解释。</span></p>  <p style="text-indent:21.0pt">makefile<span style="font-family:宋体">的命令修饰符</span></p>  <p style="text-indent:21.0pt"><span style="font-family:宋体">有三种：</span></p>  <p style="margin-left:42.0pt;text-indent:-21.0pt;"><span style="font-family:Wingdings;">l&nbsp;</span>@&nbsp;&nbsp;&nbsp;&nbsp; <span style="font-family:宋体">不打印运行的命令</span></p>  <p style="margin-left:42.0pt;text-indent:-21.0pt;"><span style="font-family:Wingdings;">l&nbsp;</span><span>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-family:宋体">屏蔽命令出错信息</span></p>  <p style="margin-left:42.0pt;text-indent:-21.0pt;"><span style="font-family:Wingdings;">l&nbsp;</span><span>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-family:宋体">只打印运行的命令，不运行</span></p>  <p style="margin-left:0cm;text-indent:0cm;"><span><span>5.<span style="font:7.0pt &quot;Times New Roman&quot;"> </span></span></span>make命令行选项</p>  <p style="text-indent:21.0pt"><span style="font-family:宋体">在</span>make<span style="font-family:宋体">的命令行上可以指定</span>make<span style="font-family:宋体">使用的变量，覆盖</span>makefile<span style="font-family:宋体">中的赋值。</span></p>  <p style="text-indent:21.0pt"><span style="font-family:宋体">比如：</span>make CXX=gcc</p>  <p style="text-indent:21.0pt"><span style="font-family:宋体">另外，可以使用</span>-C<span style="font-family:宋体">运行其他文件下面的</span>makefile<span style="font-family:宋体">。</span></p>  <p style="text-indent:21.0pt"><span style="font-family:宋体">例如：</span>make -C src/main</p>  <p style="text-indent:21.0pt"><span style="font-family:宋体">再如，你可能感觉</span>make<span style="font-family:宋体">的时间特长，那么试试</span>-j<span style="font-family:宋体">选项吧，这是</span>make<span style="font-family:宋体">内置的并行指令</span></p>  <p style="text-indent:21.0pt"><span style="font-family:宋体">方法：</span>make -j 8&nbsp; #<span style="font-family:宋体">这就是并行</span>8<span style="font-family:宋体">个</span>job<span style="font-family:宋体">来完成</span>make</p>  <p style="margin-left:0cm;text-indent:0cm;"><span><span>6.<span style="font:7.0pt &quot;Times New Roman&quot;"> </span></span></span>一个大型项目makefile例子</p>  <p><strong><span style="font-size:16.0pt;font-family:宋体;color:#1F497D">根目录下的</span></strong><strong><span style="font-size:16.0pt;color:#1F497D">makefile</span></strong></p>  <p>#<span style="font-family:宋体">初始化</span>4<span style="font-family:宋体">个变量，用来收集子文件夹下面的信息</span></p>  <p><span>modules &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; := src/main src/util src/test src/ext &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #</span><span style="font-family:宋体">程序包括哪些模块，或者说文件夹</span></p>  <p><span>programs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :=&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #</span><span style="font-family:宋体">收集</span>excutable<span style="font-family:宋体">的</span></p>  <p><span>sources&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :=&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #</span><span style="font-family:宋体">收集</span>cpp<span style="font-family:宋体">的</span></p>  <p><span>libraries&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :=&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #</span><span style="font-family:宋体">收集</span>.o<span style="font-family:宋体">的</span></p>  <p><span>extra_clean &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :=&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #</span></p>  <p>&nbsp;</p>  <p><span>objects&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = $(subst .c,.o,$(sources))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #</span><span style="font-family:宋体">调用函数由</span>.c<span style="font-family:宋体">的文件得到</span>.o<span style="font-family:宋体">的文件</span></p>  <p><span>dependencies = $(subst .c,.d,$(sources))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #</span><span style="font-family:宋体">调用函数由</span>.c<span style="font-family:宋体">的文件得到</span>.d<span style="font-family:宋体">的文件，</span>.d<span style="font-family:宋体">文件是用来得到子目录</span>.o<span style="font-family:宋体">的</span></p>  <p>&nbsp;</p>  <p>include_dirs &nbsp;&nbsp; := lib include</p>  <p><span>CPPFLAGS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; += $(addprefix -I ,$(include_dirs))</span></p>  <p>vpath %.h $(include_dirs)</p>  <p>&nbsp;</p>  <p>MV&nbsp; := mv -f</p>  <p>RM&nbsp; := rm -f</p>  <p>SED := sed</p>  <p>&nbsp;</p>  <p>all:</p>  <p><span>include $(addsuffix /module.mk,$(modules))&nbsp; #</span><span style="font-family:宋体">用函数引入</span>src/main/ module.mk<span style="font-family:宋体">等</span></p>  <p>include $( dependencies)</p>  <p>&nbsp;</p>  <p>.PHONY: all</p>  <p>all: $(programs)</p>  <p>&nbsp;</p>  <p>.PHONY: libraries</p>  <p>libraries: $(libraries)</p>  <p>&nbsp;</p>  <p>.PHONY: clean</p>  <p>clean:</p>  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $(RM) $(objects) $(programs) $(libraries) $(dependencies) $(extra_clean)</span></p>  <p><span>%.d: %.c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #</span><span style="font-family:宋体">后缀规则，描述</span>.d<span style="font-family:宋体">文件的生成</span></p>  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $(CC) $(CFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -M $&lt; | \&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #</span><span style="font-family:宋体">续行符，直接重定向到后面命令</span></p>  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $(SED) 's,\($(notdir $*)\.o\) *:,$(dir $@)\1 $@: ,' &gt; <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#36;&#64;&#46;&#116;&#109;&#112;">$@.tmp</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $(MV) <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#36;&#64;&#46;&#116;&#109;&#112;">$@.tmp</a> $@</span></p>  <p>&nbsp;</p>  <p><span style="font-family:宋体">两个特殊的表达式：</span></p>  <p><span>\($(notdir $*)\.o\) *:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-family:宋体">函数</span>notdir<span style="font-family:宋体">用来取&#8220;含路径的文件名&#8221;中的文件名，匹配出的是</span>.c<span style="font-family:宋体">文件对应的</span>.o<span style="font-family:宋体">文件</span></p>  <p><span>$(dir $@)\1 $@:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-family:宋体">函数</span>dir<span style="font-family:宋体">用来取路径，</span>\1<span style="font-family:宋体">保存的是全面正则表达式的第一个匹配，</span>$@<span style="font-family:宋体">是目标即</span>.d</p>  <p><strong><span style="font-size:16.0pt;font-family:宋体;color:#1F497D">子目录下的</span></strong><strong><span style="font-size:16.0pt;color:#1F497D">module.mk</span></strong></p>  <p><span>local_dir&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; := lib/codec</span></p>  <p><span>local_lib&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; := $(local_dir)/libcodec.a</span></p>  <p><span>local_src&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; := $(addprefix $(local_dir)/,codec.c)</span></p>  <p><span>local_objs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; := $(subst .c,.o,$(local_src))</span></p>  <p>&nbsp;</p>  <p>libraries += $(local_lib)</p>  <p>sources &nbsp; += $(local_src)</p>  <p>&nbsp;</p>  <p>$(local_lib): $(local_objs)</p>  <p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $(AR) $(ARFLAGS) $@ $^</span></p>  <p style="margin-top:6.0pt;text-indent: 21.0pt"><span style="font-family:宋体">在最顶层目录使用</span>make<span style="font-family:宋体">命令，整个项目的执行过程仍然是先建立依赖关系，然后从最底层来执行。这里的情况是：</span></p>  <p style="margin-left:42.0pt;text-indent:-21.0pt;"><span><span>1.<span style="font:7.0pt &quot;Times New Roman&quot;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><span style="font-family:宋体">由</span>include<span style="font-family:宋体">进入，</span>make<span style="font-family:宋体">先会到找每个目录下面找</span>module.mk<span style="font-family:宋体">和</span>.d<span style="font-family:宋体">文件</span></p>  <p style="margin-left:42.0pt;text-indent:-21.0pt;"><span><span>2.<span style="font:7.0pt &quot;Times New Roman&quot;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span>.d<span style="font-family:宋体">的产生需要</span>.c<span style="font-family:宋体">，这在每个子文件中条件已经具备了</span></p>  <p style="margin-left:42.0pt;text-indent:-21.0pt;"><span><span>3.<span style="font:7.0pt &quot;Times New Roman&quot;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span>module.mk<span style="font-family:宋体">的运行需要</span>.o<span style="font-family:宋体">，可能还有其他模块产生的的</span>.a</p>  <p style="margin-left:42.0pt;text-indent:-21.0pt;"><span><span>4.<span style="font:7.0pt &quot;Times New Roman&quot;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span>.o<span style="font-family:宋体">文件的产生，是在生成的</span>.d<span style="font-family:宋体">文件中描述的（由</span>g++ <span style="font-family:宋体">的</span>-M<span style="font-family:宋体">参数实现）</span></p>  <p style="margin-left:42.0pt;text-indent:-21.0pt;"><span><span>5.<span style="font:7.0pt &quot;Times New Roman&quot;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span>.a<span style="font-family:宋体">文件的产生，是在</span>module.mk<span style="font-family:宋体">文件中描述的</span></p>  <p style="margin-left:21.0pt"><span style="font-family:宋体">至此，所有条件都已经具备。从后往前做就可以完成所有任务。</span></p>  <p style="margin-left:0cm;text-indent:0cm;"><span><span>7.<span style="font:7.0pt &quot;Times New Roman&quot;"> </span></span></span>make &#8211;p的输出</p>  <p># GNU Make 3.80</p>  <p><span># Copyright (C) 2002&nbsp; Free Software Foundation, Inc.</span></p>  <p><span># This is free software; see the source for copying conditions.</span></p>  <p><span># There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A</span></p>  <p># PARTICULAR PURPOSE.</p>  <p>&nbsp;</p>  <p>normal command execution occurs here</p>  <p>&nbsp;</p>  <p><span># Make data base, printed on Thu Apr 29 20:58:13 2004</span></p>  <p><span># Variables &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-family:宋体">自动变量、内置变量都在这里</span></p>  <p>...</p>  <p><span># Directories&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-family:宋体">将会被</span>make<span style="font-family:宋体">检查的目录</span></p>  <p>...</p>  <p><span># Implicit Rules&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-family:宋体">隐含虽则，当然也是内置规则</span></p>  <p>...</p>  <p># Pattern-specific variable values</p>  <p>...</p>  <p><span># Files&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-family:宋体">后缀规则在这里</span></p>  <p>...</p>  <p><span># VPATH Search Paths&nbsp;&nbsp;&nbsp;&nbsp; vpath</span><span style="font-family:宋体">的设置</span></p>  <p>&nbsp;</p>  <p>&nbsp;</p></div></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>


	<div class = "postDesc">posted on <span id="post-date">2011-09-06 10:30</span> <a href='http://www.cnblogs.com/welkinwalker/'>welkinwalker</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href ="http://i.cnblogs.com/EditPosts.aspx?postid=2168454" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(2168454);return false;">收藏</a></div>
</div>
<script type="text/javascript">var allowComments=true,isLogined=false,cb_blogId=66454,cb_entryId=2168454,cb_blogApp=currentBlogApp,cb_blogUserGuid='58f5ad81-c310-df11-ba8f-001cf0cd104b',cb_entryCreatedDate='2011/9/6 10:30:00';loadViewCount(cb_entryId);</script>

<a name="!comments"></a><div id="blog-comments-placeholder"></div><script type="text/javascript">var commentManager = new blogCommentManager();commentManager.renderComments(0);</script>
<div id="comment_form" class="commentform">
<a name="commentform"></a>
<div id="divCommentShow"></div>
<div id="comment_nav"><span id="span_refresh_tips"></span><a href="javascript:void(0);" id="lnk_RefreshComments" onclick="return RefreshCommentList();">刷新评论</a><a href="#" onclick="return RefreshPage();">刷新页面</a><a href="#top">返回顶部</a></div>
<div id="comment_form_container"></div>
<div class="ad_text_commentbox" id="ad_text_under_commentbox"></div>
<div id="site_nav_under"><a href="http://www.cnblogs.com/" target="_blank" title="程序员的网上家园">博客园首页</a><a href="http://q.cnblogs.com/" target="_blank" title="程序员问答社区">博问</a><a href="http://news.cnblogs.com/" target="_blank" title="IT新闻">新闻</a><a href="http://home.cnblogs.com/ing/" target="_blank">闪存</a><a href="http://job.cnblogs.com/" target="_blank">程序员招聘</a><a href="http://kb.cnblogs.com/" target="_blank">知识库</a></div>
<div id="ad_under_post_holder"></div>
<script type="text/javascript">
var enableGoogleAd = true;
var googletag = googletag || {};
googletag.cmd = googletag.cmd || [];
fixPostBodyFormat();
loadAdUnderPost();
</script>
<div id="HistoryToday" class="c_ad_block"></div>
<script type="text/javascript">
loadBlogSignature();
LoadPostInfoBlock(cb_blogId, cb_entryId, cb_blogApp, cb_blogUserGuid);
GetPrevNextPost(cb_entryId, cb_blogId, cb_entryCreatedDate);
GetHistoryToday(cb_blogId, cb_blogApp, cb_entryCreatedDate);
</script>
<script type="text/javascript">
    $.ajax({ url: 'http://counter.cnblogs.com/blog/post/' + cb_entryId, type: 'get', dataType: 'script', cache: true });
</script>
</div>

</div>

<!--done-->
<div class="footer">
	
	Copyright &copy;2014 welkinwalker Powered By<a href="/">博客园</a> 模板提供：<a href="http://blog.hjenglish.com">沪江博客</a>
</div>
</body>
</html>

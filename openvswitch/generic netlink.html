               <!DOCTYPE html><html  id="customDoc"><!--STATUS OK--> <head> <meta http-equiv=Content-Type content="text/html; charset=utf-8"> <title> generic netlink_淇水遗风_百度空间</title> <link rel="shortcut icon" href="http://hi.bdimg.com/static/qbase/img/mod/16_favicon.ico?v=116ba471.ico" type=image/x-icon>   <meta name=keywords content="generic netlink,Iproute2"> <meta name=description content="瞻彼淇奥 绿竹猗猗 有匪君子 如切如磋 如琢如磨 瑟兮僴兮 赫兮咺兮 有匪君子 终不可谖兮,generic netlink"><script>window.wpo={start:new Date*1,pid:109,page:'qing'}</script><!--[if IE]><script type="text/javascript">(function(){var a="abbr,article,aside,audio,canvas,datalist,details,dialog,eventsource,figure,footer,header,hgroup,mark,menu,meter,nav,output,progress,section,time,video".split(","),b=a.length;while(b--)document.createElement(a[b])})();</script><![endif]--><script>window.qDomain={"qing":"http://hi.baidu.com","static":"http://hi.bdimg.com","passport":"https://passport.baidu.com","portrait":"http://tx.bdimg.com","hiup":"http://hiup.baidu.com","photo":"http://hiphotos.baidu.com","message":"http://msg.baidu.com","friend":"http://frd.baidu.com","mp3":"http://mp3.baidu.com","ting":"http://ting.baidu.com","image":"http://img.baidu.com","qup":"http://upload.hi.baidu.com","www":"http://www.baidu.com"};window.qUserInfo={"userName":"zmingliu","nickname":"zmingliu","portrait":"70387a6d696e676c69758804","qingUrl":"\/zmingliu","spaceName":"淇水遗风","right":"0","avatarStatus":"1","flagNeedInvite":"0","flagNotInvited":"0","version":"2"};window.qVisitorInfo={"userName":"","nickname":"","portrait":"","isHost": false,"isRandUrl": false,"isForceMoved": false,"loginStatus":"not_login","isOldUser":0,"qingUrl":"","right":"0","version":"0"};window.qPageInfo={"pageUrl":"http:\/\/hi.baidu.com\/zmingliu\/item\/97b66048181ee4af60d7b90d","referUrl":"http:\/\/www.baidu.com\/s?ie=utf-8&bs=do_lookup_genl_family&f=8&rsv_bp=1&wd=genl_family&rsv_n=2&rsv_sug3=1&rsv_sug1=1&rsv_sug4=10&inputT=1331"};window.qUserAvatar={size20:"http://hiphotos.baidu.com/space/scrop=20;q=100/sign=d73b8844f736afc30a52783ac324d9f4/9e3df8dcd100baa11965823f4710b912c9fc2eed.jpg",size40:"http://hiphotos.baidu.com/space/scrop=40;q=100/sign=23425f7779310a55c07a99abc7787799/9e3df8dcd100baa11965823f4710b912c9fc2eed.jpg",size65:"http://hiphotos.baidu.com/space/scrop=65;q=100/sign=ad45fae1b319ebc4c42631c6f21bf9c9/9e3df8dcd100baa11965823f4710b912c9fc2eed.jpg",size110:"http://hiphotos.baidu.com/space/scrop=110;q=100/sign=035e90ed252dd42a5b5746f473066a84/9e3df8dcd100baa11965823f4710b912c9fc2eed.jpg",size160:"http://hiphotos.baidu.com/space/scrop=160;q=100/sign=035e90ed252dd42a5b5746f473066a83/9e3df8dcd100baa11965823f4710b912c9fc2eed.jpg"};window.qVisitorAvatar={size20:"",size40:"",size65:"",size110:"",size160:""};window.qBdsToken="the fisrt two args should be string type:0,1!";window.qErrorInfo={"no":"0","msg":""};window.qServerInfo={"timeStamp":"1370075902"};window.qLongPolling={"url":"http:\/\/m.hi.baidu.com\/i\/msg\/listen"}</script><!--[if (lt IE 8.0)]><link href="http://hi.bdimg.com/static/qbase/css/qbase.css?v=215fffd7.css" type=text/css rel=stylesheet><![endif]--><!--[if (!IE)|(gte IE 8.0)]><!--><link href="http://hi.bdimg.com/static/qbase/css/qbase_datauri.css?v=e77db79b.css" type=text/css rel=stylesheet><!--<![endif]-->     <!--[if (lt IE 8.0)]><link rel=stylesheet type=text/css href="http://hi.bdimg.com/static/qcomment/css/qcomment.css?v=5ba753ab.css"><![endif]--><!--[if (!IE)|(gte IE 8.0)]><!--><link rel=stylesheet type=text/css href="http://hi.bdimg.com/static/qcomment/css/qcomment_datauri.css?v=a90beb01.css"><!--<![endif]--><link rel=stylesheet type=text/css href="http://hi.bdimg.com/static/qhome/css/common/mod_userInfo.css?v=86bf4259.css">   <!--[if (lt IE 8.0)]><link type=text/css rel=stylesheet href="http://hi.bdimg.com/static/qhome/css/detail/20001/detail.css?v=635ae796.css"><![endif]--><!--[if (!IE)|(gte IE 8.0)]><!--><link type=text/css rel=stylesheet href="http://hi.bdimg.com/static/qhome/css/detail/20001/detail_datauri.css?v=0f094a12.css"><!--<![endif]-->    <link rel=stylesheet type=text/css href="http://hi.bdimg.com/static/qpublish/css/editor/shCoreDefault.css?v=79e715f0.css">     <script src="http://hi.bdimg.com/static/qbase/js/qing/qing.js?v=058da7b0.js"></script>  <script>
    /*最终页页面变量*/ 
    window.detailPage = {
        threadId : "97b66048181ee4af60d7b90d",
        blogTitle: "generic netlink" || "无标题",
        contentType : "text",
        originAuthorName : "",
        originPortrait : "",
        originThreadId : ""
    }; 
    </script><script>wpo.head=new Date*1;</script> </head> <body>  <header class=mod-topbar id=modTopbar><iframe class=mod-topbar-bgframe></iframe><div class=mod-topbar-pseudo-real><div class="wrapper-box clearfix"><div class=left-box><a href="http://hi.baidu.com" class=logo-box><span id=baiduSpaceLogo class=q-logo></span></a></div> <div class=center-box><ul class=q-menubox>  <li class="q-menuitem q-newicon"> <a href=http://xiangce.baidu.com target=_blank>相册</a>  <li class="q-menuitem " id=qMenuRecommend><a href="http://hi.baidu.com/index/">广场</a></ul></div>  <div class=right-box><ul class=q-navbox><li class=q-navitem><a href="http://hi.baidu.com/go/login" class=q-goto-login>登录</a><li class="q-navitem q-nav-sp"><span></span><li class=q-navitem><a href="http://hi.baidu.com/go/reg?pmfrom=qingtop">注册</a> </ul><div class="right mod-qhome-follow-box"><a href="#" class="follow-btn a-btn-follow qing-stat-nsclick" data-nsclick=20121012follow_hdbtnaddcare>关注此空间</a></div> </div> </div></div></header>  <section class=mod-page-body> <div class="mod-page-main wordwrap clearfix">  <div class=x-page-container>    <section class="mod-topspaceinfo mod-cs-header"><div class=head-topbar></div><div class=container><h1><a class="space-name cs-header-spacename" href="/zmingliu">淇水遗风</a></h1><p class="space-description cs-header-spacesummary">瞻彼淇奥 绿竹猗猗 有匪君子 如切如磋 如琢如磨 瑟兮僴兮 赫兮咺兮 有匪君子 终不可谖兮</p></div><div class=head-footer></div></section>   <div class=mod-blogpage-wraper> <div class="blog-bg-main-repeat hide"></div>  <div class="grid-80 mod-blogpage"> <div class="blog-bg-main hide"></div>    <div class="mod-text-content mod-post-content mod-cs-contentblock"> <div class=cs-contentblock-bg></div>   <div class="content-head clearfix">  <div class=content-other-info>  <span>2009-08-05 10:25</span>  </div>   <h2 class="title content-title">generic netlink</h2>  </div>  <div id=content class="content mod-cs-content text-content clearfix"> Registering A Family<p>Registering a Generic Netlink family is a simple four step process: define the family, define the operations, register the family, register the operations.   In order to help demonstrate these steps below is a simple example broken down and explained in detail.</p><p>The first step is to define the family itself, which we do by creating an instance of the genl_family structure.  In our simple example we are going to create a new Generic Netlink family named &quot;DOC_EXMPL&quot;.</p>/* attributes */<br /> enum {<br />       DOC_EXMPL_A_UNSPEC,<br />       DOC_EXMPL_A_MSG,<br />       __DOC_EXMPL_A_MAX,<br /> };<br /> #define DOC_EXMPL_A_MAX (__DOC_EXMPL_A_MAX - 1)<br /> /* attribute policy */<br /> static struct nla_policy doc_exmpl_genl_policy[DOC_EXMPL_A_MAX + 1] = {<br />       [DOC_EXMPL_A_MSG] = { .type = NLA_NUL_STRING },<br /> };<br /> /* family definition */<br /> static struct genl_family doc_exmpl_gnl_family = {<br />       .id = GENL_ID_GENERATE,<br />       .hdrsize = 0,<br />       .name = &quot;DOC_EXMPL&quot;,<br />       .version = 1,<br />       .maxattr = DOC_EXMPL_A_MAX,<br /> };<p>Figure 1: The DOC_EXMPL family, attributes and policy</p><p>You can see above that we defined a new family and the family recognizes a single attribute, DOC_EXMPL_A_MSG, which is a NULL terminated string. The GENL_ID_GENERATE macro/constant is really just the value 0x0 and it signifies that we want the Generic Netlink controller to assign the channel number when we register the family.</p><p>The second step is to define the operations for the family, which we do by creating at least one instance of the genl_ops structure. In this example we are only going to define one operation but you can define up to 255 unique operations for each family.</p>/* handler */<br /> static int doc_exmpl_echo(struct sk_buff *skb, struct genl_info *info)<br /> {<br />       /* message handling code goes here; return 0 on success, negative<br />        * values on failure */<br /> }<br /> /* commands */<br /> enum {<br />       DOC_EXMPL_C_UNSPEC,<br />       DOC_EXMPL_C_ECHO,<br />       __DOC_EXMPL_C_MAX,<br /> };<br /> #define DOC_EXMPL_C_MAX (__DOC_EXMPL_C_MAX - 1)<br /> /* operation definition */<br /> static struct genl_ops doc_exmpl_gnl_ops_echo = {<br />       .cmd = DOC_EXMPL_C_ECHO,<br />       .flags = 0,<br />       .policy = doc_exmpl_genl_policy,<br />       .doit = doc_exmpl_echo,<br />       .dumpit = NULL,<br /> };<p>Figure 2: The DOC_EXMPL_C_ECHO operation</p><p>Here we have defined a single operation, DOC_EXMPL_C_ECHO, which uses the Netlink attribute policy we defined above.  Once registered, this particular operation would call the doc_exmpl_echo() function whenever a DOC_EXMPL_C_ECHO message is sent to the DOC_EXMPL family over the Generic Netlink bus.</p><p>The third step is to register the DOC_EXMPL family with the Generic Netlink operation.  We do this with a single function call:</p>int rc;<br /> rc = genl_register_family(&amp;doc_exmpl_gnl_family);<br /> if (rc&#160;!= 0)<br />     goto failure;<p>This call registers the new family name with the Generic Netlink mechanism and requests a new channel number which is stored in the genl_family struct, replacing the GENL_ID_GENERATE value.  It is important to remember to unregister Generic Netlink families when done as the kernel does allocate resources for each registered family.</p><p>The fourth and final step is to register the operations for the family.  Once again this is a simple function call:</p>int rc;<br /> rc = genl_register_ops(&amp;doc_exmpl_gnl_family, &amp;doc_exmpl_gnl_ops_echo);<br /> if (rc&#160;!= 0)<br />     goto failure;<p>This call registers the DOC_EXMPL_C_ECHO operation in association with the DOC_EXMPL family.  The process is now complete.  Other Generic Netlink users can now issue DOC_EXMPL_C_ECHO commands and they will be handled as desired.</p><strong>Kernel Communication</strong><p>The kernel provides two sets of interfaces for sending, receiving and processing Generic Netlink messages.  The majority of the API consists of the general purpose Netlink interfaces, however, there are a small number of interfaces specific to Generic Netlink.  The following two &quot;include&quot; files define the Netlink and Generic Netlink API for the kernel:</p><ul>    <li>include/net/netlink.h</li>    <li>include/net/genetlink.h</li></ul><strong>Sending Messages</strong><p>Sending Generic Netlink messages is a three step process: allocate memory for the message buffer, create the message, send the message.  In order to help demonstrate these steps, below is a simple example using the DOC_EXMPL family.</p><p>The first step is to allocate a Netlink message buffer; the easiest way to do this is with the nlsmsg_new() function.</p>struct sk_buff *skb;<br /> skb = genlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);<br /> if (skb == NULL)<br />     goto failure;<p>Figure 3: Allocating a Generic Netlink message buffer</p><p>The NLMSG_GOODSIZE macro/constant is a good value to use when you do not know the size of the message buffer at the time of allocation.  Don't forget that the genlmsg_new() function automatically adds space for the Netlink and Generic Netlink message headers.</p><p>The second step is to actually create the message payload.  This is obviously something which is very specific to each service, but a simple example is shown below.</p>int rc;<br /> void *msg_head;<br /> /* create the message headers */<br /> msg_head = genlmsg_put(skb, pid, seq, type, 0, flags, DOC_EXMPL_C_ECHO, 1);<br /> if (msg_head == NULL) {<br />     rc = -ENOMEM;<br />     goto failure;<br /> }<br /> /* add a DOC_EXMPL_A_MSG attribute */<br /> rc = nla_put_string(skb, DOC_EXMPL_A_MSG, &quot;Generic Netlink Rocks&quot;);<br /> if (rc&#160;!= 0)<br />     goto failure;<br /> /* finalize the message */<br /> genlmsg_end(skb, msg_head);<p>Figure 4: Creating a Generic Netlink message payload</p><p>The genlmsg_put() function creates the required Netlink and Generic Netlink message headers, populating them with the given values; see the Generic Netlink header file for a description of the parameters.</p><p>/**<br />* genlmsg_put - Add generic netlink header to netlink message<br />* @skb: socket buffer holding the message<br />* @pid: netlink pid the message is addressed to<br />* @seq: sequence number (usually the one of the sender)<br />* @family: generic netlink family<br />* @flags netlink message flags<br />* @cmd: generic netlink command<br />*<br />* Returns pointer to user specific header<br />*/</p><p>The nla_put_string() function is a standard Netlink attribute function which adds a string attribute to the end of the Netlink message; see the Netlink header file for a description of the parameters.The genlmsg_end() function updates the Netlink message header once the message payload has been finalized.  This function should be called before sending the message.</p><p>The third and final step is to send the Generic Netlink message which can be done with a single function call.  The example below is for a unicast send, but interfaces exist for doing a multicast send of Generic Netlink message.</p>int rc;<br /> rc = genlmsg_unicast(skb, pid);<br /> if (rc&#160;!= 0)<br />     goto failure;<p>Figure 5: Sending Generic Netlink messages</p><strong>Receiving Messages</strong><p>Typically, kernel modules act as Generic Netlink servers which means that the act of receiving messages is handled automatically by the Generic Netlink bus. Once the bus receives the message and determines the correct routing, the message is passed directly to the family specific operation callback for processing.  If the kernel is acting as a Generic Netlink client, server response messages can be received over the Generic Netlink socket using standard kernel socket interfaces.</p><strong>Userspace Communication</strong><p>While Generic Netlink messages can be sent and received using the standard socket API it is recommended that user space applications use the libnl library[1].  The libnl library insulates applications from many of the low level Netlink tasks and uses an API which is very similar to the kernel API shown above.</p><strong>Architectural Overview</strong><p>Figure #6 illustrates the basic Generic Netlink architecture which is composed of five different types of components:</p><ol>    <li>The Netlink subsystem which serves as the underlying transport layer for all of the Generic Netlink communications.</li>    <li>The Generic Netlink bus which is implemented inside the kernel, but which is available to userspace through the socket API and inside the kernel via the normal Netlink and Generic Netlink APIs.</li>    <li>The Generic Netlink users who communicate with each other over the Generic Netlink bus; users can exist both in kernel and user space.</li>    <li>The Generic Netlink controller which is part of the kernel and is responsible for dynamically allocating Generic Netlink communication channels and other management tasks. The Generic Netlink controller is implemented as a standard Generic Netlink user, however, it listens on a special, pre-allocated Generic Netlink channel.</li>    <li>The kernel socket API.  Generic Netlink sockets are created with the PF_NETLINK domain and the NETLINK_GENERIC protocol values.</li></ol>+---------------------+      +---------------------+<br />     | (3) application &quot;A&quot; |      | (3) application &quot;B&quot; |<br />     +------+--------------+      +--------------+------+<br />            |                                    |<br />            \                                    /<br />             \                                  /<br />              |                                |<br />      +-------+--------------------------------+-------+<br />      |       &#160;:                              &#160;:       |   user-space<br /> =====+       &#160;:   (5)  kernel socket API     &#160;:       +================<br />      |       &#160;:                              &#160;:       |   kernel-space<br />      +--------+-------------------------------+-------+<br />               |                               |<br />         +-----+-------------------------------+----+<br />         |        (1)  Netlink subsystem            |<br />         +---------------------+--------------------+<br />                               |<br />         +---------------------+--------------------+<br />         |       (2) Generic Netlink bus            |<br />         +--+--------------------------+-------+----+<br />            |                          |       |<br />    +-------+---------+                |       |<br />    |  (4) controller |               /         \<br />    +-----------------+              /           \<br />                                     |           |<br />                  +------------------+--+     +--+------------------+<br />                  | (3) kernel user &quot;X&quot; |     | (3) kernel user &quot;Y&quot; |<br />                  +---------------------+     +---------------------+<p>Figure 6: Generic Netlink Architecture</p><p>When looking at figure #6 it is important to note that any Generic Netlink user can communicate with any other user over the bus using the same API regardless of where the user resides in relation to the kernel/userspace boundary.</p><p>Generic Netlink communications are essentially a series of different communication channels which are multiplexed on a single Netlink family. Communication channels are uniquely identified by channel numbers which are dynamically allocated by the Generic Netlink controller.  The controller is a special Generic Netlink user which listens on a fixed communication channel, number 0x10, which is always present.  Kernel or userspace users which provide services over the Generic Netlink bus establish new communication channels by registering their services with the Generic Netlink controller.  Users who want to use a service query the controller to see if the service exists and to determine the correct channel number.</p><strong>Implementation Details</strong><p>This section provides a more in-depth explanation of the Generic Netlink message formats and data structures.</p><strong>Message Format</strong><p>Generic Netlink uses the standard Netlink subsystem as a transport layer which means that the foundation of the Generic Netlink message is the standard Netlink message format - the only difference is the inclusion of a Generic Netlink message header.  The format of the message is defined as shown below:</p>0                   1                   2                   3<br />  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1<br /> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<br /> |                Netlink message header (nlmsghdr)              |<br /> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<br /> |           Generic Netlink message header (genlmsghdr)         |<br /> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<br /> |             Optional user specific message header             |<br /> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<br /> |           Optional Generic Netlink message payload            |<br /> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<p>Figure 7: Generic Netlink message format</p><p>Figure #7 is included only to give you a rough idea of how Generic Netlink messages are formatted and sent &quot;on the wire&quot;.  In practice the Netlink and Generic Netlink API should insulate most users from the details of the message format and the Netlink message headers.</p><strong>Data Structures</strong><p>This section focuses on the Generic Netlink data structures as they are defined in the kernel.  A similar API exists for userspace applications using the libnl library[1].</p><strong>The genl_family Structure</strong><p>Generic Netlink families are defined by the genl_family structure, which is shown below:</p>struct genl_family<br /> {<br />       unsigned int            id;<br />       unsigned int            hdrsize;<br />       char                    name[GENL_NAMSIZ];<br />       unsigned int            version;<br />       unsigned int            maxattr;<br />       struct nlattr **        attrbuf;<br />       struct list_head        ops_list;<br />       struct list_head        family_list;<br /> };<p>Figure 8: The genl_family structure</p><p>The genl_family structure fields are used in the following manner:</p><ul>    <li>unsigned int id<br />    This is the dynamically allocated channel number. A value of 0x0 signifies that the channel number should be assigned by the controller and the 0x10 value is reserved for use by the controller. Users should always use GENL_ID_GENERATE macro/constant (value 0x0) when registering a new family.</li>    <li>unsigned int hdrsize<br />    If the family makes use of a family specific header, its size is stored here. If there is no family specific header this value should be zero.</li>    <li>char name[GENL_NAMSIZ]<br />    This string should be unique to the family as it is the key that the controller uses to lookup channel numbers when requested.</li>    <li>unsigned int version<br />    Family specific version number.</li>    <li>unsigned int maxattr<br />    Generic Netlink makes use of the standard Netlink attributes; this value holds the maximum number of attributes defined for the Generic Netlink family.</li>    <li>struct nlattr **attrbuf<br />    This is a private field and should not be modified.</li>    <li>struct list_head ops_list<br />    This is a private field and should not be modified.</li>    <li>struct list_head family_list<br />    This is a private field and should not be modified.</li></ul><strong>The genl_ops Structure</strong><p>Generic Netlink operations are defined by the genl_ops structure, which is shown below:</p>struct genl_ops<br /> {<br />       u8                      cmd;<br />       unsigned int            flags;<br />       struct nla_policy       *policy;<br />       int                     (*doit)(struct sk_buff *skb,<br />                                       struct genl_info *info);<br />       int                     (*dumpit)(struct sk_buff *skb,<br />                                         struct netlink_callback *cb);<br />       struct list_head        ops_list;<br /> };<p>Figure 9: The genl_ops structure</p><p>The genl_ops structure fields are used in the following manner:</p><ul>    <li>u8 cmd<br />    This value is unique across the corresponding Generic Netlink family and is used to reference the operation.</li>    <li>unsigned int flags<br />    This field is used to specify any special attributes of the operation. The following flags may be used (multiple flags can be OR'd together):    <ul>        <li>GENL_ADMIN_PERM<br />        The operation requires the CAP_NET_ADMIN privilege</li>    </ul>    </li>    <li>struct nla_policy policy<br />    This field defines the Netlink attribute policy for the operation request message. If specified, the Generic Netlink mechanism uses this policy to verify all of the attributes in the operation request message before calling the operation handler.<br />    The attribute policy is defined as an array of nla_policy structures indexed by the attribute number. The nla_policy structure is defined as shown in figure #11.</li>    <li>int (*doit)(struct skbuff *skb, struct genl_info *info)<br />    This callback is similar in use to the standard Netlink doit() callback, the primary difference being the change in parameters.<br />    The doit() handler receives two parameters: the first is the message buffer which triggered the handler and the second is a Generic Netlink genl_info structure which is defined as shown in figure #10.</li>    <li>int (*dumpit)(struct sk_buff *skb, struct netlink_callback *cb)<br />    This callback is similar in use to the standard Netlink dumpit() callback. The dumpit() callback is invoked when the Generic Netlink message is received with the NLM_F_DUMP flag set.<br />    The main difference between the dumpit() handler and the doit() handler is that the dumpit() handler does not allocate a message buffer for a response; a pre-allocated sk_buff is passed to the dumpit() handler as the first parameter. The dumpit() handler should fill the message buffer with the appropriate response message and return the size of the sk_buff, i.e. sk_buff-&gt;len, and the message buffer will automatically be sent to the Generic Netlink client that initiated the request. As long as the dumpit() handler returns a value greater than zero it will be called again with a newly allocated message buffer to fill. When the handler has no more data to send it should return zero; error conditions are indicated by returning a negative value. If necessary, state can be preserved in the netlink_callback parameter which is passed to the dumpit() handler; the netlink_callback parameter values will be preserved across handler calls for a single request.</li>    <li>struct list_head ops_list<br />    This is a private field and should not be modified.</li></ul><strong>The genl_info Structure</strong><p>Generic Netlink message information is passed by the genl_info structure, which is shown below:</p>struct genl_info<br />    {<br />       u32                     snd_seq;<br />       u32                     snd_pid;<br />       struct nlmsghdr *       nlhdr;<br />       struct genlmsghdr *     genlhdr;<br />       void *                  userhdr;<br />       struct nlattr **        attrs;<br />    };<p>Figure 10: The genl_info structure</p><p>The fields are populated in the following manner:</p><ul>    <li>u32 snd_seq<br />    This is the Netlink sequence number of the request.</li>    <li>u32 snd_pid<br />    This is the Netlink PID of the client which issued the request; it is important to note that the Netlink PID is not the same as the standard kernel PID.</li>    <li>struct nlmsghdr *nlhdr<br />    This is set to point to the Netlink message header of the request.</li>    <li>struct genlmsghdr *genlhdr<br />    This is set to point to the Generic Netlink message header of the request.</li>    <li>void *userhdr<br />    If the Generic Netlink family makes use of a family specific header, this pointer will be set to point to the start of the family specific header.</li>    <li>struct nlattr **attrs<br />    The parsed Netlink attributes from the request; if the Generic Netlink family definition specified a Netlink attribute policy then the attributes would have already been validated.<br />    The doit() handler should do whatever processing is necessary and return zero on success or a negative value on failure. Negative return values will cause an NLMSG_ERROR message to be sent while a zero return value will only cause the NLMSG_ERROR message to be sent if the request is received with the NLM_F_ACK flag set.</li></ul><strong>The nla_policy Structure</strong><p>Generic Netlink attribute policy is defined by the nla_policy structure, which is shown below:</p>struct nla_policy<br />    {<br />       u16             type;<br />       u16             len;<br />    };<p>Figure 11: The nla_policy structure</p><p>The fields are used in the following manner:</p><ul>    <li>u16 type<br />    This specifies the type of the attribute; presently the following types are defined for general use:    <ul>        <li>NLA_UNSPEC<br />        Undefined type</li>        <li>NLA_U8<br />        An 8-bit unsigned integer</li>        <li>NLA_U16<br />        A 16-bit unsigned integer</li>        <li>NLA_U32<br />        A 32-bit unsigned integer</li>        <li>NLA_U64<br />        A 64-bit unsigned integer</li>        <li>NLA_FLAG<br />        A simple boolean flag</li>        <li>NLA_MSECS<br />        A 64-bit time value in msecs</li>        <li>NLA_STRING<br />        A variable length string</li>        <li>NLA_NUL_STRING<br />        A variable length NULL terminated string</li>        <li>NLA_NESTED<br />        A stream of attributes</li>    </ul>    </li>    <li>u16 len<br />    When the attribute type is one of the string types then this field should be set to the maximum length of the string, not including the terminal NULL byte. If the attribute type is unknown or NLA_UNSPEC then this field should be set to the exact length of the attribute's payload.<br />    Unless the attribute type is one of the fixed-length types above, a value of zero indicates that no validation of the attribute should be performed.</li></ul><strong>Recommendations</strong><p>The Generic Netlink mechanism is a very flexible communications mechanism and as a result there are many different ways it can be used. The following recommendations are based on conventions within the Linux kernel and should be followed whenever possible. While not all existing kernel code follows the recommendations outlined here, all new code should consider these recommendations as requirements.</p><strong>Attributes And Message Payloads</strong><p>When defining new Generic Netlink message formats you must make use of the Netlink attributes wherever possible. The Netlink attribute mechanism has been carefully designed to allow for future message expansion while preserving backward compatibility. There are also additional benefits from using Netlink attributes which include developer familiarity and basic input checking.</p><p>Most common data structures can be represented with Netlink attributes:</p><dl><dd> scalar values&#160;; Most scalar values already have well-defined attribute types; see section 4 for details. </dd><dd> structures&#160;; Structures can be represented using a nested attribute with the structure fields represented as attributes in the payload of the container attribute. </dd><dd> arrays&#160;; Arrays can be represented by using a single nested attribute as a container with several of the same attribute type inside each representing a spot in the array. </dd></dl><p>It is also important to use unique attributes as much as possible. This helps make the most of the Netlink attribute mechanisms and provides for easy changes to the message format in the future.</p><strong>Operation Granularity</strong><p>While it may be tempting to register a single operation for a Generic Netlink family and multiplex multiple sub-commands on the single operation, this is strongly discouraged for security reasons. Combining multiple behaviors into one operation makes it difficult to restrict the operations using the existing Linux kernel security mechanisms.</p><strong>Acknowledgment and Error Reporting</strong><p>It is often necessary for Generic Netlink services to return an ACK or error code to the client. It is not necessary to implement an explicit acknowledgment message as Netlink already provides a flexible acknowledgment and error reporting message type called NLMSG_ERROR. When an error occurs an NLMSG_ERROR message is returned to the client with the error code returned by the Generic Netlink operation handler. Clients can also request the NLMSG_ERROR message when no error has occurred by setting the NLM_F_ACK flag on requests.</p> </div>    <div class="mod-tagbox clearfix">   <a class="tag" href="/tag/Iproute2/feeds">#Iproute2</a>  </div> <div class="mod-post-info clearfix">  <div class=x-bdshare>  <div id=bdshare class="bdshare_t bds_tools get-codes-bdshare" data="{'wbuid':1727466295}"> <span class=bds_more>分享到：</span> <a class=bds_qzone></a> <a class=bds_tsina></a> <a class=bds_tqq></a> <a class=bds_renren></a> </div> <script id=bdshare_js data="type=tools&amp;uid=713670"></script> <script id=bdshell_js></script> <script>
        var bds_config = {'bdTop':240};
                    var all_img = qing.g('content').getElementsByTagName('img');
            if(all_img.length>0){
                bds_config.bdPic = all_img[0].src;
            }
                document.getElementById("bdshell_js").src = "http://bdimg.share.baidu.com/static/js/shell_v2.js?v=66280422.js?cdnversion=" + Math.ceil(new Date()/3600000);
    </script> </div> <div class="op-box mod-cs-opBox">  <a class="report-btn hide" target=_blank href="#"> 举报 </a>  <span class=pv>浏览(268)</span> <a class=comment-bnt id=commentBnt href="#" onclick="return false"> 评论<span class=comment-nub></span> </a>   <a href="#" id=shareBnt onclick="return false" class=share-bnt> 转载<span id=shareNub class=share-nub></span> </a>   </div> </div>   </div>    <div class=mod-share-detail id=shareDetail style=display:none></div>   <div class=mod-relate-blogs id=relateBlog> <h3 class=relate-title>你可能也喜欢</h3> <ul class="relate-blog-list clearfix">   <li  class=first > <a href="http://hi.baidu.com/linconner/item/8138dd1a826e3624d0d66dde" target=_blank class=qing-stat-nsclick data-nsclick=m_20121105_detail_relates_img> <img src="http://b.hiphotos.baidu.com/space/scrop=90/sign=a920d96fd52a283447f871542b88f0da/d000baa1cd11728b8e694550c9fcc3cec3fd2c78.jpg" class=relate-img alt="爱-莫文蔚" title="爱-莫文蔚"> </a> <a href="http://hi.baidu.com/linconner/item/8138dd1a826e3624d0d66dde" target=_blank class="relate-txt qing-stat-nsclick" data-nsclick=m_20121105_detail_relates_txt>爱-莫文蔚</a>    <li > <a href="http://hi.baidu.com/jingluobujing/item/a3c0e94469f5abf71381da99" target=_blank class=qing-stat-nsclick data-nsclick=m_20121105_detail_relates_img> <img src="http://c.hiphotos.baidu.com/space/scrop=90/sign=f0a66cb7e1fe9925cf522e0f449567ef/b21bb051f8198618fcf59bf64bed2e738bd4e616.jpg" class=relate-img alt="Thank you，让我的灵魂在幻彩夜空中漫步" title="Thank you，让我的灵魂在幻彩夜空中漫步"> </a> <a href="http://hi.baidu.com/jingluobujing/item/a3c0e94469f5abf71381da99" target=_blank class="relate-txt qing-stat-nsclick" data-nsclick=m_20121105_detail_relates_txt>Thank you，让我的灵魂在幻彩夜空中漫步</a>    <li > <a href="http://hi.baidu.com/feidan__ya/item/eb05d833e4bcc8ffde2221f1" target=_blank class=qing-stat-nsclick data-nsclick=m_20121105_detail_relates_img> <img src="http://a.hiphotos.baidu.com/space/scrop=90/sign=70599474aec379317936c1769bf98e75/0dd7912397dda144a59d3ac0b3b7d0a20cf4862f.jpg" class=relate-img alt="《北京遇上西雅图》所有插曲片头片尾曲出处及下载链接。一起相约帝国~" title="《北京遇上西雅图》所有插曲片头片尾曲出处及下载链接。一起相约帝国~"> </a> <a href="http://hi.baidu.com/feidan__ya/item/eb05d833e4bcc8ffde2221f1" target=_blank class="relate-txt qing-stat-nsclick" data-nsclick=m_20121105_detail_relates_txt>《北京遇上西雅图》所有插曲片头片尾曲出处及下载链接。一起相约帝国~</a>    <li > <a href="http://hi.baidu.com/zcfutpequlbgrtq/item/5f7012a8457eae148919d3f7" target=_blank class=qing-stat-nsclick data-nsclick=m_20121105_detail_relates_img> <img src="http://e.hiphotos.baidu.com/space/scrop=90/sign=6e719712342ac65c635b212c8bcf8b21/8694a4c27d1ed21b5a026597ac6eddc450da3ffc.jpg" class=relate-img alt="简蓝发布的音乐" title="简蓝发布的音乐"> </a> <a href="http://hi.baidu.com/zcfutpequlbgrtq/item/5f7012a8457eae148919d3f7" target=_blank class="relate-txt qing-stat-nsclick" data-nsclick=m_20121105_detail_relates_txt>简蓝发布的音乐</a>    <li > <a href="http://hi.baidu.com/yidou/item/6dfaf9d4457183facb0c39fe" target=_blank class=qing-stat-nsclick data-nsclick=m_20121105_detail_relates_img> <img src="http://c.hiphotos.baidu.com/space/scrop=90/sign=c11afd55fc039245a5eba650f7a99df2/91529822720e0cf3d51e45630a46f21fbf09aab8.jpg" class=relate-img alt="亦豆发布的音乐" title="亦豆发布的音乐"> </a> <a href="http://hi.baidu.com/yidou/item/6dfaf9d4457183facb0c39fe" target=_blank class="relate-txt qing-stat-nsclick" data-nsclick=m_20121105_detail_relates_txt>亦豆发布的音乐</a>    <li > <a href="http://hi.baidu.com/ddmascot/item/3c4b31005318b111addc70e8" target=_blank class=qing-stat-nsclick data-nsclick=m_20121105_detail_relates_img> <img src="http://c.hiphotos.baidu.com/space/scrop=90/sign=0177bb7615ce36d3a65ac46f4ace03b7/c9fcc3cec3fdfc03c887a414d43f8794a5c2269a.jpg" class=relate-img alt="ddmascot发布的音乐" title="ddmascot发布的音乐"> </a> <a href="http://hi.baidu.com/ddmascot/item/3c4b31005318b111addc70e8" target=_blank class="relate-txt qing-stat-nsclick" data-nsclick=m_20121105_detail_relates_txt>ddmascot发布的音乐</a>    <li > <a href="http://hi.baidu.com/zmingliu/item/fc544294642824d81e427130" target=_blank class=qing-stat-nsclick data-nsclick=m_20121105_detail_relates_img> <img src="http://e.hiphotos.baidu.com/space/scrop=90/sign=0d8d279e6059252da7495a5b44a63a0b/9e3df8dcd100baa11965823f4710b912c9fc2eed.jpg" class=relate-img alt="媒体相关库" title="媒体相关库"> </a> <a href="http://hi.baidu.com/zmingliu/item/fc544294642824d81e427130" target=_blank class="relate-txt qing-stat-nsclick" data-nsclick=m_20121105_detail_relates_txt>媒体相关库</a>   </ul> </div>   <div class="mod-detail-pager clearfix">  <div class=detail-nav-pre> <a href="http://hi.baidu.com/zmingliu/item/b4d0c21eedfe1121f7625c30" hidefocus title="上一篇"></a> </div>   <div class=detail-nav-next> <a href="http://hi.baidu.com/zmingliu/item/094d06cce91d7f66f6c95d30" hidefocus title="下一篇"></a> </div>  </div>   <div id=commentDetail class="mod-comment-detail clearfix mod-cs-comment">   <div class=mod-recent-readers> <h3 class=recent-readers-title>本文最近访客</h3> <ul class="readers-list clearfix">    <li  class=first > <a target=_blank href="http://hi.baidu.com/xootus"> <img src="http://hiphotos.baidu.com/space/scrop%3D65%3Bq%3D100/sign%3De2b6bc1ed158ccbf1fe2f26569e58a0b/5882b2b7d0a20cf460c5eb7376094b36adaf99c0.jpg" title="xootus" alt="xootus" class=portrait> </a> <a target=_blank href="http://hi.baidu.com/xootus" class=user-name title="xootus"> xootus </a> <div class=visit-time data-visit-time="1366683181"></div>      <li > <a target=_blank href="http://hi.baidu.com/sx_liang"> <img src="http://hiphotos.baidu.com/space/scrop%3D65%3Bq%3D100/sign%3Dafdff49b8794a4c20e7da0747ec92de0/3b292df5e0fe9925c5667cc434a85edf8db1713f.jpg" title="sx_liang" alt="sx_liang" class=portrait> </a> <a target=_blank href="http://hi.baidu.com/sx_liang" class=user-name title="sx_liang"> sx_liang </a> <div class=visit-time data-visit-time="1358646869"></div>    </ul> </div>  <div class=comment-title>评论</div> <div class=comment-content></div> </div>   </div>  </div>  </div> </div> </section>  <footer class="mod-footer mod-cs-footer"><div class="clearfix hidden-box"></div><div class=footer-box><div class=inner-box><a href=http://help.baidu.com/question?prod_en=hi target=_blank>帮助中心</a><span>&nbsp;|&nbsp;</span><a href=http://tieba.baidu.com/p/1781683739 target=_blank>空间客服</a><span>&nbsp;|&nbsp;</span><a href=http://tousu.baidu.com/hi/add target=_blank>投诉中心</a><span>&nbsp;|&nbsp;</span><a href=http://www.baidu.com/search/hi_contract.html target=_blank>空间协议</a></div><div class=copy-box>&copy;2013&nbsp;Baidu</div></div></footer>  <script src="http://hi.bdimg.com/static/qbase/js/mod/mod_foot.js?v=747a1d59.js"></script> <script>
        	qing.dom.ready(function(){
                if (qVisitorInfo.loginStatus == 'activated'){
                    qext.stat.ns('m_20121012_loga_num');
					qext.fn.setStoken();
				}
			});
        </script>        <script>qext.stat.ns('m_20120425_');</script>  <script src="http://hi.bdimg.com/static/qcomment/js/qcmt_import.js?v=ac96f988.js"></script>  <script src="http://hi.bdimg.com/static/qpublish/js/editor/shCore.js?v=bcf5a2e1.js"></script> <script>
        SyntaxHighlighter.highlight();
    </script>   <script src="http://hi.bdimg.com/static/qhome/js/detail/20001/detail.js?v=7ff54b94.js"></script>   <script>wpo.tti=new Date*1;</script><script src="http://hi.baidu.com/cm/static/js/allsite.js?v=68594928.js?v=201306011638"></script><script>document.write(unescape("%3Cscript src='http://hm.baidu.com/h.js%3F8c869b543955d43e496c2efee5b55823' type='text/javascript'%3E%3C/script%3E"));qext.stat.ns('m_20120713_qing_pv');</script>
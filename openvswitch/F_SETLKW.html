<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>fcntl使用 - and_tt - 博客园</title>
<link type="text/css" rel="stylesheet" href="http://common.cnblogs.com/blog/css/common.css?id=20130323"/>
<link id="MainCss" type="text/css" rel="stylesheet" href="http://common.cnblogs.com/Skins/BOOK/style.css?id=20130323"/>
<link type="text/css" rel="stylesheet" href="http://common.cnblogs.com/blog/css/common2.css"/>
<link type="text/css" rel="stylesheet" href="http://common.cnblogs.com/css/shStyle.css"/>
<link title="RSS" type="application/rss+xml" rel="alternate" href="http://www.cnblogs.com/andtt/rss"/>
<link title="RSD" type="application/rsd+xml" rel="EditURI" href="http://www.cnblogs.com/andtt/rsd.xml"/>
<link type="application/wlwmanifest+xml" rel="wlwmanifest" href="http://www.cnblogs.com/andtt/wlwmanifest.xml"/>
<script src="http://common.cnblogs.com/script/jquery.js" type="text/javascript"></script>  
<script type="text/javascript">
var currentBlogApp = 'andtt';
</script>
<script src="http://common.cnblogs.com/blog/script/common.js?id=20130323" type="text/javascript"></script> 
<script src="http://common.cnblogs.com/script/json2.js" type="text/javascript"></script>
<script type="text/javascript" src="http://common.cnblogs.com/script/syntaxHighlighter.js"></script>
</head>
<body>
<a name="top"></a>

<script type="text/javascript">
	try {
		if (screen.availWidth > 1200) {
			document.getElementById("MainCss").href = '/Skins/BOOK/style2.css';
		}
	} catch (e) { }
</script>

<div id="header">
<div id="HeaderTitle">
<div id="Title">
<a id="Header1_HeaderTitle" class="headermaintitle" href="http://www.cnblogs.com/andtt/">and_tt</a>
</div>
<div id="subTitle"></div>
</div>
</div>

<div id="main">
	
	
	<div class="post">
		<h2>
			<a id="cb_post_title_url" href="http://www.cnblogs.com/andtt/articles/2178875.html">fcntl使用</a>
		</h2>
		<div id="cnblogs_post_body"><p style="line-height: 22px; margin-top: 0px; margin-right: 0px; margin-left: 0px; padding: 0px;"><span size="3" style="line-height: 25px; font-size: small;"><span color="#0000ff" style="line-height: 25px; color: #0000ff;">功能描述：根据文件描述词来操作文件的特性。</span></span></p>
<p style="line-height: 22px; margin-top: 0px; margin-right: 0px; margin-left: 0px; padding: 0px;"><span size="3" style="line-height: 25px; font-size: small;">#include &lt;unistd.h&gt;<br style="line-height: 25px;" />#include &lt;fcntl.h&gt;&nbsp;<br style="line-height: 25px;" />int fcntl(int fd, int cmd);&nbsp;<br style="line-height: 25px;" />int fcntl(int fd, int cmd, long arg);&nbsp;<br style="line-height: 25px;" />int fcntl(int fd, int cmd, struct flock *lock);</span></p>
<p style="line-height: 22px; margin-top: 0px; margin-right: 0px; margin-left: 0px; padding: 0px;"><span size="3" style="line-height: 25px; font-size: small;"><span color="#0000ff" style="line-height: 25px; color: #0000ff;">[描述]</span><br style="line-height: 25px;" />fcntl()针对(文件)描述符提供控制。参数fd是被参数cmd操作(如下面的描述)的描述符。针对cmd的值，fcntl能够接受第三个参数int arg。</span><span size="3" style="line-height: 25px; font-size: small;"><span color="#0000ff" style="line-height: 25px; color: #0000ff;"><span color="#000000" style="line-height: 25px; color: #000000;"></span></span></span></p>
<p style="line-height: 22px; margin-top: 0px; margin-right: 0px; margin-left: 0px; padding: 0px;"><span size="3" style="line-height: 25px; font-size: small;"><span color="#0000ff" style="line-height: 25px; color: #0000ff;">[返回值]<br style="line-height: 25px;" /></span><span color="#000000" style="line-height: 25px; color: #000000;">fcntl()的返回值</span></span><span size="3" style="line-height: 25px; font-size: small;"><span color="#000000" style="line-height: 25px; color: #000000;">与命令有关。如果出错，所有命令都返回－1，如果成功则返回某个其他值。</span>下列三个命令有特定返回值：F_DUPFD , F_GETFD , F_GETFL以及F_GETOWN。<br style="line-height: 25px;" /><span color="#000000" style="line-height: 25px; color: #000000;">&nbsp;&nbsp;&nbsp; F_DUPFD&nbsp;&nbsp; 返回新的文件描述符<br style="line-height: 25px;" />&nbsp;&nbsp;&nbsp; F_GETFD&nbsp;&nbsp; 返回相应标志<br style="line-height: 25px;" />&nbsp;&nbsp;&nbsp; F_GETFL , F_GETOWN&nbsp;&nbsp; 返回一个正的进程ID或负的进程组ID</span></span></p>
<p style="line-height: 22px; margin-top: 0px; margin-right: 0px; margin-left: 0px; padding: 0px;">&nbsp;</p>
<p style="line-height: 22px; margin-top: 0px; margin-right: 0px; margin-left: 0px; padding: 0px;"><span size="3" style="line-height: 25px; font-size: small;"><span color="#0000ff" style="line-height: 25px; color: #0000ff;">fcntl函数有5种功能：</span>&nbsp;<br style="line-height: 25px;" />1. 复制一个现有的描述符(cmd=F_DUPFD).&nbsp;<br style="line-height: 25px;" />2. 获得／设置文件描述符标记(cmd=F_GETFD或F_SETFD).&nbsp;<br style="line-height: 25px;" />3. 获得／设置文件状态标记(cmd=F_GETFL或F_SETFL).&nbsp;<br style="line-height: 25px;" />4. 获得／设置异步I/O所有权(cmd=F_GETOWN或F_SETOWN).&nbsp;<br style="line-height: 25px;" />5. 获得／设置记录锁(cmd=F_GETLK , F_SETLK或F_SETLKW).</span></p>
<p style="line-height: 22px; margin-top: 0px; margin-right: 0px; margin-left: 0px; padding: 0px;"><span size="3" style="line-height: 25px; font-size: small;"><span color="#008000" style="line-height: 25px; color: #008000;"><strong style="line-height: 25px;">1. cmd值的F_DUPFD&nbsp;：</strong></span>&nbsp;<br style="line-height: 25px;" /><span color="#3366ff" style="line-height: 25px; color: #3366ff;">F_DUPFD</span>&nbsp;&nbsp;&nbsp; 返回一个如下描述的(文件)描述符：<br style="line-height: 25px;" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &middot;最小的大于或等于arg的一个可用的描述符<br style="line-height: 25px;" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &middot;与原始操作符一样的某对象的引用<br style="line-height: 25px;" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &middot;如果对象是文件(file)的话，则返回一个新的描述符，这个描述符与arg共享相同的偏移量(offset)<br style="line-height: 25px;" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &middot;相同的访问模式(读，写或读/写)<br style="line-height: 25px;" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &middot;相同的文件状态标志(如：两个文件描述符共享相同的状态标志)<br style="line-height: 25px;" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &middot;与新的文件描述符结合在一起的close-on-exec标志被设置成交叉式访问execve(2)的系统调用</span></p>
<p style="line-height: 22px; margin-top: 0px; margin-right: 0px; margin-left: 0px; padding: 0px;"><span size="3" style="line-height: 25px; font-size: small;">实际上调用dup(oldfd)；<br style="line-height: 25px;" />等效于</span><br style="line-height: 22px;" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span size="3" style="line-height: 25px; font-size: small;">&nbsp; fcntl(oldfd, F_DUPFD, 0);</span></p>
<p style="line-height: 22px; margin-top: 0px; margin-right: 0px; margin-left: 0px; padding: 0px;"><span size="3" style="line-height: 25px; font-size: small;">而调用dup2(oldfd, newfd)；<br style="line-height: 25px;" />等效于<br style="line-height: 25px;" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; close(oldfd)；<br style="line-height: 25px;" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fcntl(oldfd, F_DUPFD, newfd)；</span></p>
<p style="line-height: 22px; margin-top: 0px; margin-right: 0px; margin-left: 0px; padding: 0px;"><span size="3" style="line-height: 25px; font-size: small;"><span color="#008000" style="line-height: 25px; color: #008000;"><strong style="line-height: 25px;">2. cmd值的F_GETFD和F_SETFD：</strong></span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br style="line-height: 25px;" /><span color="#3366ff" style="line-height: 25px; color: #3366ff;">F_GETFD</span>&nbsp;&nbsp;&nbsp; 取得与文件描述符fd联合的close-on-exec标志，类似FD_CLOEXEC。如果返回值和FD_CLOEXEC进行与运算结果是0的话，文件保持交叉式访问exec()，否则如果通过exec运行的话，文件将被关闭(arg 被忽略)&nbsp;&nbsp;</span><span size="3" style="line-height: 25px; font-size: small;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br style="line-height: 25px;" /><span color="#3366ff" style="line-height: 25px; color: #3366ff;">F_SETFD</span>&nbsp;&nbsp;&nbsp; 设置close-on-exec标志，该标志以参数arg的FD_CLOEXEC位决定，应当了解很多现存的涉及文件描述符标志的程序并不使用常数 FD_CLOEXEC，而是将此标志设置为0(系统默认，在exec时不关闭)或1(在exec时关闭)&nbsp;&nbsp;&nbsp;&nbsp;</span></p>
<p style="line-height: 22px; margin-top: 0px; margin-right: 0px; margin-left: 0px; padding: 0px;"><span color="#0000ff" size="3" style="line-height: 25px; color: #0000ff; font-size: small;">在修改文件描述符标志或文件状态标志时必须谨慎，先要取得现在的标志值，然后按照希望修改它，最后设置新标志值。不能只是执行F_SETFD或F_SETFL命令，这样会关闭以前设置的标志位。</span>&nbsp;</p>
<p style="line-height: 22px; margin-top: 0px; margin-right: 0px; margin-left: 0px; padding: 0px;"><span size="3" style="line-height: 25px; font-size: small;"><span color="#008000" style="line-height: 25px; color: #008000;"><strong style="line-height: 25px;">3.&nbsp;cmd值的F_GETFL和F_SETFL：</strong></span>&nbsp;&nbsp;&nbsp;<br style="line-height: 25px;" /><span color="#3366ff" style="line-height: 25px; color: #3366ff;">F_GETFL</span>&nbsp;&nbsp;&nbsp; 取得fd的文件状态标志，如同下面的描述一样(arg被忽略)，在说明open函数时，已说明<br style="line-height: 25px;" />了文件状态标志。不幸的是，三个存取方式标志 (O_RDONLY ,&nbsp;O_WRONLY , 以及O_RDWR)并不各占1位。(这三种标志的值各是0 , 1和2，由于历史原因，这三种值互斥 &mdash; 一个文件只能有这三种值之一。) 因此首先<span color="#00ccff" style="line-height: 25px; color: #00ccff;">必须用屏蔽字O_ACCMODE相与取得存取方式位</span>，然后将结果与这三种值相比较。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br style="line-height: 25px;" /><span color="#3366ff" style="line-height: 25px; color: #3366ff;">F_SETFL</span>&nbsp;&nbsp;&nbsp; 设置给arg描述符状态标志，可以更改的几个标志是：O_APPEND，O_NONBLOCK，O_SYNC 和 O_ASYNC。<span color="#00ccff" style="line-height: 25px; color: #00ccff;">而fcntl的文件状态标志总共有7个：O_RDONLY , O_WRONLY , O_RDWR , O_APPEND , O_NONBLOCK , O_SYNC和O_ASYNC</span></span></p>
<p style="line-height: 22px; margin-top: 0px; margin-right: 0px; margin-left: 0px; padding: 0px;"><span size="3" style="line-height: 25px; font-size: small;"><span color="#0000ff" style="line-height: 25px; color: #0000ff;"><span color="#0000ff" style="line-height: 25px; color: #0000ff;">可更改的几个标志如下面的描述：</span><br style="line-height: 25px;" /></span><span color="#3366ff" style="line-height: 25px; color: #3366ff;">&nbsp;&nbsp;&nbsp; O_NONBLOCK</span>&nbsp;&nbsp; 非阻塞I/O，如果read(2)调用没有可读取的数据，或者如果write(2)操作将阻塞，则read或write调用将返回-1和EAGAIN错误<br style="line-height: 25px;" /><span color="#3366ff" style="line-height: 25px; color: #3366ff;">&nbsp;&nbsp;&nbsp; O_APPEND</span>&nbsp;&nbsp;&nbsp;&nbsp; 强制每次写(write)操作都添加在文件大的末尾，相当于open(2)的O_APPEND标志<br style="line-height: 25px;" /><span color="#3366ff" style="line-height: 25px; color: #3366ff;">&nbsp;&nbsp;&nbsp; O_DIRECT</span>&nbsp;&nbsp;&nbsp;&nbsp; 最小化或去掉reading和writing的缓存影响。系统将企图避免缓存你的读或写的数据。如果不能够避免缓存，那么它将最小化已经被缓存了的数据造成的影响。如果这个标志用的不够好，将大大的降低性能<br style="line-height: 25px;" /><span color="#3366ff" style="line-height: 25px; color: #3366ff;">&nbsp;&nbsp;&nbsp; O_ASYNC</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当I/O可用的时候，允许SIGIO信号发送到进程组，例如：当有数据可以读的时候</span></p>
<p style="line-height: 22px; margin-top: 0px; margin-right: 0px; margin-left: 0px; padding: 0px;"><span size="3" style="line-height: 25px; font-size: small;"><span color="#008000" style="line-height: 25px; color: #008000;"><strong style="line-height: 25px;">4.&nbsp;cmd值的F_GETOWN和F_SETOWN：</strong></span>&nbsp;&nbsp;&nbsp;<br style="line-height: 25px;" /><span color="#3366ff" style="line-height: 25px; color: #3366ff;">F_GETOWN</span>&nbsp;&nbsp; 取得当前正在接收SIGIO或者SIGURG信号的进程id或进程组id，进程组id返回的是负值(arg被忽略)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br style="line-height: 25px;" /><span color="#3366ff" style="line-height: 25px; color: #3366ff;">F_SETOWN</span>&nbsp;&nbsp; 设置将接收SIGIO和SIGURG信号的进程id或进程组id，进程组id通过提供负值的arg来说明(arg绝对值的一个进程组ID)，否则arg将被认为是进程id</span></p>
<p style="line-height: 22px; margin-top: 0px; margin-right: 0px; margin-left: 0px; padding: 0px;"><span size="3" style="line-height: 25px; font-size: small;"><strong style="line-height: 25px;"><span color="#008000" style="line-height: 25px; color: #008000;">&nbsp;5.</span><span color="#008000" style="line-height: 25px; color: #008000;">&nbsp;cmd值的<span color="#008000" style="line-height: 25px; color: #008000;">F_GETLK, F_SETLK或F_SETLKW</span>：</span></strong></span><span size="3" style="line-height: 25px; font-size: small;"><span color="#0000ff" style="line-height: 25px; color: #0000ff;">&nbsp;<span color="#000000" style="line-height: 25px; color: #000000;">获得／设置记录锁的功能，</span><span color="#000000" style="line-height: 25px; color: #000000;">成功则返回0，若有错误则返回-1，错误原因存于errno。</span><br style="line-height: 25px;" /></span><span color="#3366ff" style="line-height: 25px; color: #3366ff;">F_GETLK</span>&nbsp;&nbsp;&nbsp; 通过第三个参数arg(一个指向flock的结构体)取得第一个阻塞lock description指向的锁。取得的信息将覆盖传到fcntl()的flock结构的信息。如果没有发现能够阻止本次锁(flock)生成的锁，这个结构将不被改变，除非锁的类型被设置成F_UNLCK&nbsp;&nbsp;&nbsp;&nbsp;<br style="line-height: 25px;" /><span color="#3366ff" style="line-height: 25px; color: #3366ff;">F_SETLK</span>&nbsp;&nbsp;&nbsp; 按照指向结构体flock的指针的第三个参数arg所描述的锁的信息设置或者清除一个文件的segment锁。F_SETLK被用来实现共享(或读)锁(F_RDLCK)或独占(写)锁(F_WRLCK)，同样可以去掉这两种锁(F_UNLCK)。如果共享锁或独占锁不能被设置，fcntl()将立即返回EAGAIN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br style="line-height: 25px;" /><span color="#3366ff" style="line-height: 25px; color: #3366ff;">F_SETLKW</span>&nbsp;&nbsp; 除了共享锁或独占锁被其他的锁阻塞这种情况外，这个命令和F_SETLK是一样的。如果共享锁或独占锁被其他的锁阻塞，进程将等待直到这个请求能够完成。当fcntl()正在等待文件的某个区域的时候捕捉到一个信号，如果这个信号没有被指定SA_RESTART, fcntl将被中断</span></p>
<p style="line-height: 22px; margin-top: 0px; margin-right: 0px; margin-left: 0px; padding: 0px;"><span size="3" style="line-height: 25px; font-size: small;">当一个共享锁被set到一个文件的某段的时候，其他的进程可以set共享锁到这个段或这个段的一部分。共享锁阻止任何其他进程set独占锁到这段保护区域的任何部分。如果文件描述符没有以读的访问方式打开的话，共享锁的设置请求会失败。</span></p>
<p style="line-height: 22px; margin-top: 0px; margin-right: 0px; margin-left: 0px; padding: 0px;"><span size="3" style="line-height: 25px; font-size: small;">独占锁阻止任何其他的进程在这段保护区域任何位置设置共享锁或独占锁。如果文件描述符不是以写的访问方式打开的话，独占锁的请求会失败。</span></p>
<p style="line-height: 22px; margin-top: 0px; margin-right: 0px; margin-left: 0px; padding: 0px;"><span size="3" style="line-height: 25px; font-size: small;"><span color="#0000ff" style="line-height: 25px; color: #0000ff;">结构体flock的指针：</span><br style="line-height: 25px;" />struct flcok&nbsp;<br style="line-height: 25px;" />{&nbsp;<br style="line-height: 25px;" />short int l_type; /* 锁定的状态*/</span></p>
<p style="line-height: 22px; margin-top: 0px; margin-right: 0px; margin-left: 0px; padding: 0px;"><span size="3" style="line-height: 25px; font-size: small;">//以下的三个参数用于分段对文件加锁，若对整个文件加锁，则：l_whence=SEEK_SET, l_start=0, l_len=0<br style="line-height: 25px;" />short int l_whence; /*决定l_start位置*/&nbsp;<br style="line-height: 25px;" />off_t l_start; /*锁定区域的开头位置*/&nbsp;<br style="line-height: 25px;" />off_t l_len; /*锁定区域的大小*/</span></p>
<p style="line-height: 22px; margin-top: 0px; margin-right: 0px; margin-left: 0px; padding: 0px;"><span size="3" style="line-height: 25px; font-size: small;">pid_t l_pid; /*锁定动作的进程*/&nbsp;<br style="line-height: 25px;" />};</span></p>
<p style="line-height: 22px; margin-top: 0px; margin-right: 0px; margin-left: 0px; padding: 0px;"><span size="3" style="line-height: 25px; font-size: small;"><span color="#3366ff" style="line-height: 25px; color: #3366ff;">l_type 有三种状态：</span>&nbsp;<br style="line-height: 25px;" />F_RDLCK&nbsp;&nbsp; 建立一个供读取用的锁定&nbsp;<br style="line-height: 25px;" />F_WRLCK&nbsp;&nbsp; 建立一个供写入用的锁定&nbsp;<br style="line-height: 25px;" />F_UNLCK&nbsp;&nbsp; 删除之前建立的锁定</span></p>
<p style="line-height: 22px; margin-top: 0px; margin-right: 0px; margin-left: 0px; padding: 0px;"><span size="3" style="line-height: 25px; font-size: small;"><span color="#3366ff" style="line-height: 25px; color: #3366ff;">l_whence 也有三种方式：</span>&nbsp;<br style="line-height: 25px;" />SEEK_SET&nbsp;&nbsp; 以文件开头为锁定的起始位置&nbsp;<br style="line-height: 25px;" />SEEK_CUR&nbsp;&nbsp; 以目前文件读写位置为锁定的起始位置&nbsp;<br style="line-height: 25px;" />SEEK_END&nbsp;&nbsp; 以文件结尾为锁定的起始位置</span></p>
<p style="line-height: 22px; margin-top: 0px; margin-right: 0px; margin-left: 0px; padding: 0px;"><br style="line-height: 22px;" /><span size="3" style="line-height: 25px; font-size: small;"><span color="#0000ff" style="line-height: 25px; color: #0000ff;">fcntl文件锁有两种类型：建议性锁和强制性锁</span><br style="line-height: 25px;" /><span color="#3366ff" style="line-height: 25px; color: #3366ff;">建议性锁是这样规定的</span>：每个使用上锁文件的进程都要检查是否有锁存在，当然还得尊重已有的锁。内核和系统总体上都坚持不使用建议性锁，它们依靠程序员遵守这个规定。<br style="line-height: 25px;" /><span color="#3366ff" style="line-height: 25px; color: #3366ff;">强制性锁是由内核执行的</span>：当文件被上锁来进行写入操作时，在锁定该文件的进程释放该锁之前，内核会阻止任何对该文件的读或写访问，每次读或写访问都得检查锁是否存在。</span></p>
<p style="line-height: 22px; margin-top: 0px; margin-right: 0px; margin-left: 0px; padding: 0px;"><span size="3" style="line-height: 25px; font-size: small;"><span color="#3366ff" style="line-height: 25px; color: #3366ff;">系统默认fcntl都是建议性锁，强制性锁是非POSIX标准的。</span>如果要使用强制性锁，要使整个系统可以使用强制性锁，那么得需要重新挂载文件系统，mount使用参数 -0 mand 打开强制性锁，或者关闭已加锁文件的组执行权限并且打开该文件的set-GID权限位。<br style="line-height: 25px;" /><span color="#3366ff" style="line-height: 25px; color: #3366ff;">建议性锁只在cooperating processes之间才有用</span>。对cooperating process的理解是最重要的，它指的是会影响其它进程的进程或被别的进程所影响的进程，<span color="#3366ff" style="line-height: 25px; color: #3366ff;">举两个例子：</span><br style="line-height: 25px;" />(1) 我们可以同时在两个窗口中运行同一个命令，对同一个文件进行操作，那么这两个进程就是cooperating&nbsp; processes<br style="line-height: 25px;" />(2) cat file | sort，那么cat和sort产生的进程就是使用了pipe的cooperating processes</span></p>
<p style="line-height: 22px; margin-top: 0px; margin-right: 0px; margin-left: 0px; padding: 0px;"><span size="3" style="line-height: 25px; font-size: small;"><span color="#0000ff" style="line-height: 25px; color: #0000ff;">使用fcntl文件锁进行I/O操作必须小心：</span>进程在开始任何I/O操作前如何去处理锁，在对文件解锁前如何完成所有的操作，是必须考虑的。如果在设置锁之前打开文件，或者读取该锁之后关闭文件，另一个进程就可能在上锁/解锁操作和打开/关闭操作之间的几分之一秒内访问该文件。当一个进程对文件加锁后，无论它是否释放所加的锁，只要文件关闭，内核都会自动释放加在文件上的建议性锁(这也是建议性锁和强制性锁的最大区别)，所以不要想设置建议性锁来达到永久不让别的进程访问文件的目的(强制性锁才可以)；强制性锁则对所有进程起作用。</span></p>
<p style="line-height: 22px; margin-top: 0px; margin-right: 0px; margin-left: 0px; padding: 0px;"><span size="3" style="line-height: 25px; font-size: small;"><span color="#0000ff" style="line-height: 25px; color: #0000ff;">fcntl使用三个参数 F_SETLK/F_SETLKW， F_UNLCK和F_GETLK 来分别要求、释放、测试record locks</span>。record locks是对文件一部分而不是整个文件的锁，这种细致的控制使得进程更好地协作以共享文件资源。fcntl能够用于读取锁和写入锁，<span color="#3366ff" style="line-height: 25px; color: #3366ff;">read lock也叫shared lock(共享锁)， 因为多个cooperating process能够在文件的同一部分建立读取锁；write lock被称为exclusive lock(排斥锁)，因为任何时刻只能有一个cooperating process在文件的某部分上建立写入锁。</span>如果cooperating processes对文件进行操作，那么它们可以同时对文件加read lock，在一个cooperating process加write lock之前，必须释放别的cooperating process加在该文件的read lock和wrtie lock，也就是说，对于文件只能有一个write lock存在，read lock和wrtie lock不能共存。</span></p>
<p style="line-height: 22px; margin-top: 0px; margin-right: 0px; margin-left: 0px; padding: 0px;"><span color="#ff6600" size="4" style="line-height: 28px; color: #ff6600; font-size: medium;"><strong style="line-height: 28px;">下面的例子使用F_GETFL获取<span size="3" style="line-height: 25px; font-size: small;"><span size="4" style="line-height: 28px; font-size: medium;">fd的文件</span>状态标志</span>。</strong></span></p>
<p style="line-height: 22px; margin-top: 0px; margin-right: 0px; margin-left: 0px; padding: 0px;">#include&lt;fcntl.h&gt;<br style="line-height: 22px;" />#include&lt;unistd.h&gt;<br style="line-height: 22px;" />#include&lt;iostream&gt;<br style="line-height: 22px;" />#include&lt;errno.h&gt;<br style="line-height: 22px;" />using namespace std;</p>
<p style="line-height: 22px; margin-top: 0px; margin-right: 0px; margin-left: 0px; padding: 0px;">int main(int argc,char* argv[])<br style="line-height: 22px;" />{<br style="line-height: 22px;" />&nbsp; int fd, var;<br style="line-height: 22px;" />&nbsp; //&nbsp; fd=open("new",O_RDWR);<br style="line-height: 22px;" />&nbsp; if (argc!=2)<br style="line-height: 22px;" />&nbsp; {<br style="line-height: 22px;" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; perror("--");<br style="line-height: 22px;" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout&lt;&lt;"请输入参数，即文件名！"&lt;&lt;endl;<br style="line-height: 22px;" />&nbsp; }</p>
<p style="line-height: 22px; margin-top: 0px; margin-right: 0px; margin-left: 0px; padding: 0px;">&nbsp; if((var=fcntl(atoi(argv[1]), F_GETFL, 0))&lt;0)<br style="line-height: 22px;" />&nbsp; {<br style="line-height: 22px;" />&nbsp;&nbsp;&nbsp;&nbsp; strerror(errno);<br style="line-height: 22px;" />&nbsp;&nbsp;&nbsp;&nbsp; cout&lt;&lt;"fcntl file error."&lt;&lt;endl;<br style="line-height: 22px;" />&nbsp; }</p>
<p style="line-height: 22px; margin-top: 0px; margin-right: 0px; margin-left: 0px; padding: 0px;">&nbsp; switch(var &amp; O_ACCMODE)<br style="line-height: 22px;" />&nbsp; {<br style="line-height: 22px;" />&nbsp;&nbsp; case O_RDONLY : cout&lt;&lt;"Read on<wbr style="line-height: 22px;">ly.."&lt;&lt;endl;<br style="line-height: 22px;" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br style="line-height: 22px;" />&nbsp;&nbsp; case O_WRONLY : cout&lt;&lt;"Write on<wbr style="line-height: 22px;">ly.."&lt;&lt;endl;<br style="line-height: 22px;" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br style="line-height: 22px;" />&nbsp;&nbsp; case O_RDWR&nbsp;&nbsp; : cout&lt;&lt;"Read wirte.."&lt;&lt;endl;<br style="line-height: 22px;" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br style="line-height: 22px;" />&nbsp;&nbsp; default&nbsp; : break;<br style="line-height: 22px;" />&nbsp; }</wbr></wbr></p>
<p style="line-height: 22px; margin-top: 0px; margin-right: 0px; margin-left: 0px; padding: 0px;">&nbsp;if (val &amp; O_APPEND)<br style="line-height: 22px;" />&nbsp;&nbsp;&nbsp; cout&lt;&lt;",append"&lt;&lt;endl;</p>
<p style="line-height: 22px; margin-top: 0px; margin-right: 0px; margin-left: 0px; padding: 0px;">&nbsp;if (val &amp; O_NONBLOCK)<br style="line-height: 22px;" />&nbsp;&nbsp;&nbsp; cout&lt;&lt;",noblocking"&lt;&lt;endl;</p>
<p style="line-height: 22px; margin-top: 0px; margin-right: 0px; margin-left: 0px; padding: 0px;">&nbsp;cout&lt;&lt;"exit 0"&lt;&lt;endl;</p>
<p style="line-height: 22px; margin-top: 0px; margin-right: 0px; margin-left: 0px; padding: 0px;">&nbsp;exit(0);<br style="line-height: 22px;" />}</p></div><div id="MySignature"></div>
<script type="text/javascript">
var isLogined = false;
var cb_blogId = 93280;
var cb_entryId = 2178875;
var cb_blogApp = currentBlogApp;
var cb_blogUserGuid = "d9bb4e94-06b4-e011-8673-842b2b196315";
var cb_entryCreatedDate = '2011/9/16 16:06:00';
var enableGoogleAd = true;
var googletag = googletag || {};
googletag.cmd = googletag.cmd || [];
</script>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
<script type="text/javascript">
    //SyntaxHighlighter.config.strings.expandSource = '<span><img src="http://static.cnblogs.com/images/expand-code.gif" alt="" class="expand-code-icon"/>View Code</span>';
    $(function () {             
        fixPostBodyFormat();
        loadAdUnderPost();
        loadBlogSignature();
        LoadPostInfoBlock(cb_blogId, cb_entryId, cb_blogApp, cb_blogUserGuid);
        GetPrevNextPost(cb_entryId, cb_blogId, cb_entryCreatedDate);        
        GetHistoryToday(cb_blogId, cb_blogApp, cb_entryCreatedDate);        
    });
</script>
		<p class="postfoot">
			posted on <span id="post-date">2011-09-16 16:06</span> <a href='http://www.cnblogs.com/andtt/'>and_tt</a> 阅读(7927) 评论(<span id="post-comment-count">1</span>) &nbsp;<a href="http://www.cnblogs.com/andtt/admin/EditArticles.aspx?postid=2178875" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(2178875);return false;">收藏</a>
		</p>
	</div>
	<img src ="http://www.cnblogs.com/andtt/aggbug/2178875.html?type=2&amp;webview=1" width="1" height="1" alt=""/>
	
	<div id="blog-comments-placeholder"></div><script type="text/javascript">var commentManager = new blogCommentManager();commentManager.loadComments();</script>
<div id="comment_form" class="commentform">
<div id="divCommentShow"></div>
<div id="comment_nav"><span id="span_refresh_tips"></span><a href="javascript:void(0);" id="lnk_RefreshComments" onclick="return RefreshCommentList();">刷新评论</a><a href="#" onclick="return RefreshPage();">刷新页面</a><a href="#top">返回顶部</a></div>
<div id="comment_form_container"></div>

<script type="text/javascript">
    if (typeof commentManager === 'undefined') {
        commentManager = new blogCommentManager();
    }
    commentManager.loadCommentForm();   
</script>

<div class="ad_text_commentbox" id="ad_text_under_commentbox"></div>
<div id="site_nav_under"><a href="http://www.cnblogs.com/" target="_blank" title="程序员的网上家园">博客园首页</a><a href="http://q.cnblogs.com/" target="_blank" title="程序员问答社区">博问</a><a href="http://news.cnblogs.com/" target="_blank" title="IT新闻">新闻</a><a href="http://home.cnblogs.com/ing/" target="_blank">闪存</a><a href="http://job.cnblogs.com/" target="_blank">程序员招聘</a><a href="http://kb.cnblogs.com/" target="_blank">知识库</a></div>
<div id="ad_under_post_holder"></div>
<div id="HistoryToday" class="c_ad_block"></div>
</div>





	
<p id="footer">
	Powered by: 
	<br />
	
	<a id="Footer1_Hyperlink3" NAME="Hyperlink1" href="http://www.cnblogs.com/" style="font-family:Verdana;font-size:12px;">博客园</a>
	<br />
	Copyright &copy; and_tt
</p>
</div>
<div id="rightmenu">
	
		<div id="blog-calendar-block" style="display:none"><div id="blog-calendar"></div>
</div>
		
<h3>导航</h3>
<ul>
			<li><a id="MyLinks1_HomeLink" href="http://www.cnblogs.com/">博客园</a></li>
			<li><a id="MyLinks1_MyHomeLink" href="http://www.cnblogs.com/andtt/">首页</a></li>
			<li><a id="MyLinks1_NewPostLink" rel="nofollow" href="http://www.cnblogs.com/andtt/admin/EditPosts.aspx?opt=1">新随笔</a></li>
			<li><a id="MyLinks1_ContactLink" accesskey="9" rel="nofollow" href="http://space.cnblogs.com/msg/send/and_tt">联系</a></li>
			<li><a id="MyLinks1_Syndication" href="http://www.cnblogs.com/andtt/rss">订阅</a><a id="MyLinks1_XMLLink" href="http://www.cnblogs.com/andtt/rss"><img src="http://www.cnblogs.com/images/xml.gif" alt="订阅" /></a>
			<li><a id="MyLinks1_Admin" rel="nofollow" href="http://www.cnblogs.com/andtt/admin/EditPosts.aspx">管理</a></li>
</ul>
		
<h3>统计</h3>
	<ul>
		<li>随笔 - 6
		<li>文章 - 21
		<li>评论 - 1
		<li>引用 - 0
	</li>
</ul>
		
<h3>公告</h3>
	<div id="blog-news"></div>

		<div id="blog-sidecolumn"></div>
	
</div>
			
			
			
			
			 

	

<script type="text/javascript" src="http://common.cnblogs.com/script/google-analytics.js"></script>
</body>
</html>
